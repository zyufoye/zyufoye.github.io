<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeQL入门</title>
    <url>/2025/12/07/CodeQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="CodeQL-入门"><a href="#CodeQL-入门" class="headerlink" title="CodeQL 入门"></a>CodeQL 入门</h1><p>在网络安全和代码审计的领域，静态应用程序安全测试（Static application security testing，SAST）工具层出不穷。但在 2019 年 GitHub 收购 Semmle 之后，CodeQL 迅速成为了业界顶流。</p>
<p>传统的扫描工具往往像是一个黑盒，你输入代码，它吐出报告。但 CodeQL 不同，它的核心理念非常有意思： <code>Code as Data</code> 代码即数据，CodeQL 把源代码转化成一个关系型数据库，而漏洞挖掘的过程，就变成了一次次编写 SQL（其实是 QL）查询语句的过程。</p>
<p>CodeQL 工具包含两大部分组成：</p>
<ul>
<li>核心引擎(闭源)：用于解析源代码并存储于数据库，以及执行 QL 语句从数据库中进行查询；</li>
<li>SDK代码库(开源)：包含各编程语言对应的 QL 代码库(属性&#x2F;谓词&#x2F;等)，以便快速编写查询语句。</li>
</ul>
<p>这给了安全研究员和开发者极大的自由度——不再受限于工具内置的规则，可以自己定义“什么样的代码长相存在漏洞”。这篇 Blog 记录了我第一次使用 CodeQL 进行静态代码分析的过程。</p>
<span id="more"></span>

<h2 id="一、CodeQL-核心工作流"><a href="#一、CodeQL-核心工作流" class="headerlink" title="一、CodeQL 核心工作流"></a>一、CodeQL 核心工作流</h2><p>使用 CodeQL 主要分为三个步骤：</p>
<ol>
<li><p><strong>创建数据库（Create Database）</strong>： 在编译&#x2F;构建代码的过程中，CodeQL 会“旁路监听”，捕捉所有的编译命令、文件结构、函数调用关系，生成一个快照数据库；</p>
</li>
<li><p><strong>编写&#x2F;运行查询（Analyze）</strong>： 使用一种类似 SQL 的面向对象查询语言（QL），在数据库中查找符合特征的代码片段；</p>
</li>
<li><p><strong>生成结果（Results）</strong>： 输出分析报告（通常是 SARIF 格式），定位到具体的代码行号。</p>
</li>
</ol>
<h2 id="二、CodeQL-安装"><a href="#二、CodeQL-安装" class="headerlink" title="二、CodeQL 安装"></a>二、CodeQL 安装</h2><p>运行 CodeQL 需要安装 CodeQL CLI 工具，分开下载的话需要分别下载 CodeQL binary 和 SDK，需要放在相同目录下且版本保持一致，也可以直接下载捆绑包，以 Ubuntu 环境为例，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.16.1/codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvzf codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/aono/codeqlsrc/codeql</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>检测是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql --version</span><br></pre></td></tr></table></figure>

<p>可以使用  <code>codeQL resolve languages</code> 可以查看支持的编程语言。</p>
<h2 id="三、CodeQL-简单使用"><a href="#三、CodeQL-简单使用" class="headerlink" title="三、CodeQL 简单使用"></a>三、CodeQL 简单使用</h2><p>指定项目创建数据库，以 Java 目标（<a href="https://github.com/l4yn3/micro_service_seclab%EF%BC%89%E4%B8%BA%E4%BE%8B%EF%BC%8C%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87">https://github.com/l4yn3/micro_service_seclab）为例，项目通过</a> mvn 构建，首先安装 mvn：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install maven -y</span><br></pre></td></tr></table></figure>

<p>创建数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database create java_db --language=java --source-root=./test/micro_service_seclab/</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_1.png"></p>
<p>使用默认规则进行查询，生成 SARIF 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database analyze java_db/ --format=sarif-latest --output=java_result.sarif</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_2.png"></p>
]]></content>
      <categories>
        <category>SAST</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO链接站内文章方法</title>
    <url>/2025/12/11/HEXO%E9%93%BE%E6%8E%A5%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Hexo链接站内文章方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link markdown-learning-by-maxiang 点击这里查看这篇文章 %&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>markdown-learning-by-maxiang</code> 为文章名称，我测试了同目录下修改为自己文章名称可以成功，注意不要加路径，如果文章名称有空格就用双引号引起来。<code>点击这里查看这篇文章</code> 是显示的内容，如果不写的话就默认是文章名称。</p>
<p>参考链接：<a href="https://github.com/iissnan/hexo-theme-next/issues/978">https://github.com/iissnan/hexo-theme-next/issues/978</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP stdio与sse模式的区别</title>
    <url>/2025/12/15/MCP-stdio%E4%B8%8Esse%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="SSE-和-stdio-模式对比"><a href="#SSE-和-stdio-模式对比" class="headerlink" title="SSE 和 stdio 模式对比"></a>SSE 和 stdio 模式对比</h2><h3 id="架构差异"><a href="#架构差异" class="headerlink" title="架构差异"></a>架构差异</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">stdio 模式：</span><br><span class="line">Cursor/Claude Desktop</span><br><span class="line">    └─ 启动子进程：python server.py</span><br><span class="line">        └─ stdin/stdout 通信</span><br><span class="line">        └─ 服务器生命周期由客户端管理</span><br><span class="line"></span><br><span class="line">SSE 模式：</span><br><span class="line">独立运行：python server.py (后台持续运行)</span><br><span class="line">    ↑</span><br><span class="line">    └─ HTTP SSE 连接</span><br><span class="line">    ↑</span><br><span class="line">Cursor/Claude Desktop (通过 HTTP 连接)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>stdio 模式</th>
<th>SSE 模式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>启动方式</strong></td>
<td>客户端自动启动</td>
<td>手动启动（独立进程）</td>
</tr>
<tr>
<td><strong>通信协议</strong></td>
<td>stdin&#x2F;stdout 管道</td>
<td>HTTP + Server-Sent Events</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>单一客户端</td>
<td>多客户端支持</td>
</tr>
<tr>
<td><strong>调试难度</strong></td>
<td>难（日志混在一起）</td>
<td>易（可直接查看终端）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>生产环境</td>
<td>开发调试</td>
</tr>
<tr>
<td><strong>进程管理</strong></td>
<td>自动（随客户端）</td>
<td>手动（需要单独管理）</td>
</tr>
<tr>
<td><strong>网络要求</strong></td>
<td>无</td>
<td>需要监听端口</td>
</tr>
<tr>
<td><strong>日志可见性</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="测试时为什么选择-SSE？"><a href="#测试时为什么选择-SSE？" class="headerlink" title="测试时为什么选择 SSE？"></a>测试时为什么选择 SSE？</h3><ul>
<li><p>✅ 开发调试更方便：可以直接在终端看到所有日志，手动重启服务器，用浏览器测试连接；</p>
</li>
<li><p>✅ 多客户端支持：多个 IDE 可以同时连接，可以同时在 Cursor 和 Claude Desktop 中使用；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL-MCP架构解读</title>
    <url>/2025/12/15/CodeQL-MCP%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>本片内容以 <a href="https://github.com/JordyZomer/codeql-mcp">https://github.com/JordyZomer/codeql-mcp</a> 为基础，进行 CodeQL MCP 的开发学习。</p>
<h2 id="CodeQL-MCP-整体架构分析"><a href="#CodeQL-MCP-整体架构分析" class="headerlink" title="CodeQL-MCP 整体架构分析"></a>CodeQL-MCP 整体架构分析</h2><p>项目中包含了两个核心文件 <code>codeqlclient.py</code> 和  <code>server.py</code> ：</p>
<p><strong><code>codeqlclient.py</code></strong> 是一个底层通信客户端，负责与 CodeQL 查询服务器建立并管理 JSON-RPC 连接。它封装了进程启动、请求发送、响应解析、异步任务跟踪等复杂逻辑，提供了数据库注册、查询执行、结果解码等核心操作的原始接口。该文件不依赖任何高层框架，专注于可靠、高效地与 CodeQL 引擎交互，可作为独立库在不同上下文中复用。</p>
<p><strong><code>server.py</code></strong> 是一个基于 Model Context Protocol（MCP）的服务层实现，利用 FastMCP 框架将 <code>codeqlclient.py</code> 提供的底层能力包装为用户友好的异步 API 工具。它定义了清晰的 HTTP 可调用接口，处理参数验证、错误反馈和结果格式化，使外部系统能通过标准 MCP 协议便捷地使用 CodeQL 功能，而无需关心底层通信细节。</p>
<p>在 <code>codeqlclient.py</code> 中包含了一个核心类结构 CodeQLQueryServer 主要模块如下：</p>
<ol>
<li>服务器进程管理</li>
</ol>
<ul>
<li>启动&#x2F;停止 ：通过 start() 和 stop() 方法管理 CodeQL 子进程</li>
<li>进程通信 ：使用标准输入&#x2F;输出进行 JSON-RPC 通信</li>
<li>线程管理 ：<ul>
<li>_read_loop() ：主线程，读取服务器响应；_stderr_loop() ：处理标准错误输出；异步处理：支持并发请求</li>
</ul>
</li>
</ul>
<ol start="2">
<li>通信协议层</li>
</ol>
<ul>
<li>JSON-RPC 2.0：定义消息格式，请求&#x2F;响应结构，支持异步调用</li>
</ul>
<ol start="3">
<li>功能模块</li>
</ol>
<ul>
<li><p>数据库管理</p>
<ul>
<li>register_databases() ：注册数据库</li>
<li>deregister_databases() ：注销数据库</li>
</ul>
</li>
<li><p>查询执行</p>
<ul>
<li>evaluate_queries() ：执行完整查询</li>
<li>quick_evaluate() ：快速评估（针对特定代码位置）</li>
<li>evaluate_and_wait() ：同步执行查询</li>
<li>quick_evaluate_and_wait() ：同步快速评估</li>
</ul>
</li>
<li><p>结果处理</p>
<ul>
<li>decode_bqrs() ：解码 BQRS 结果文件</li>
</ul>
</li>
<li><p>代码分析辅助</p>
<ul>
<li>find_class_identifier_position() ：查找类标识符位置</li>
<li>find_predicate_identifier_position() ：查找谓词标识符位置</li>
</ul>
</li>
<li><p>进度回调机制（支持实时进度更新）</p>
<ul>
<li>wait_for_progress_done() ：等待进度完成</li>
<li>wait_for_completion_callback() ：等待异步操作完成</li>
<li>wait_for_progress_done() 创建进度跟踪器</li>
<li>wait_for_completion_callback() 创建完成处理器</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据流：用户请求 -&gt; send_request()-&gt;JSON-RPC 消息-&gt;CodeQL 服务器-&gt;CodeQL 引擎-&gt;服务器响应-&gt;_read_loop()-&gt;_handle_message()-&gt;回调函数</p>
</blockquote>
<span id="more"></span>

<h2 id="关键模块解读"><a href="#关键模块解读" class="headerlink" title="关键模块解读"></a>关键模块解读</h2><h3 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h3><p>启动 CodeQL 查询服务器进程，并建立通信通道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.proc = subprocess.Popen(</span><br><span class="line">    [</span><br><span class="line">        <span class="variable language_">self</span>.codeql_path,        <span class="comment"># CodeQL 可执行文件路径</span></span><br><span class="line">        <span class="string">&quot;execute&quot;</span>,               <span class="comment"># 执行命令</span></span><br><span class="line">        <span class="string">&quot;query-server2&quot;</span>,         <span class="comment"># 启动查询服务器版本2</span></span><br><span class="line">        <span class="string">&quot;--debug&quot;</span>,               <span class="comment"># 启用调试模式</span></span><br><span class="line">        <span class="string">&quot;--tuple-counting&quot;</span>,      <span class="comment"># 启用元组计数（性能监控）</span></span><br><span class="line">        <span class="string">&quot;--threads=0&quot;</span>,           <span class="comment"># 使用所有可用线程（0=自动）</span></span><br><span class="line">        <span class="string">&quot;--evaluator-log-level&quot;</span>, <span class="comment"># 设置评估器日志级别</span></span><br><span class="line">        <span class="string">&quot;5&quot;</span>,                     <span class="comment"># 日志级别5（详细）</span></span><br><span class="line">        <span class="string">&quot;-v&quot;</span>,                    <span class="comment"># 详细输出</span></span><br><span class="line">        <span class="string">&quot;--log-to-stderr&quot;</span>,       <span class="comment"># 日志输出到标准错误</span></span><br><span class="line">    ],</span><br><span class="line">    stdin=subprocess.PIPE,      <span class="comment"># 标准输入管道（用于发送请求）</span></span><br><span class="line">    stdout=subprocess.PIPE,     <span class="comment"># 标准输出管道（用于接收响应）</span></span><br><span class="line">    stderr=subprocess.PIPE,     <span class="comment"># 标准错误管道（用于日志/错误）</span></span><br><span class="line">    text=<span class="literal">True</span>,                  <span class="comment"># 以文本模式处理输入输出</span></span><br><span class="line">    bufsize=<span class="number">1</span>,                  <span class="comment"># 行缓冲模式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>启动读取线程：创建一个守护线程来持续读取服务器的标准输出，处理 JSON-RPC 响应。同时还有读取标准错误输出，防止缓冲区阻塞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.reader_thread = threading.Thread(</span><br><span class="line">    target=<span class="variable language_">self</span>._read_loop,  <span class="comment"># 目标函数：读取循环</span></span><br><span class="line">    daemon=<span class="literal">True</span>              <span class="comment"># 守护线程（主程序退出时自动结束）</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.reader_thread.start()   <span class="comment"># 启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.stderr_thread = threading.Thread(</span><br><span class="line">    target=<span class="variable language_">self</span>._stderr_loop,  <span class="comment"># 目标函数：标准错误循环</span></span><br><span class="line">    daemon=<span class="literal">True</span>                <span class="comment"># 守护线程</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.stderr_thread.start()     <span class="comment"># 启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="stderr-loop"><a href="#stderr-loop" class="headerlink" title="_stderr_loop()"></a>_stderr_loop()</h3><p>标准错误处理循环：持续读取 CodeQL服务器的标准错误输出，防止stderr管道堵塞，在 start() 中作为守护线程启动。</p>
<h3 id="read-loop"><a href="#read-loop" class="headerlink" title="_read_loop()"></a>_read_loop()</h3><p>主读取循环：读取并解析服务器响应，处理 JSON-RPC over HTTP 风格的消息格式。</p>
<h3 id="handle-message"><a href="#handle-message" class="headerlink" title="_handle_message()"></a>_handle_message()</h3><p>消息分发器：是核心的消息处理函数，处理三种类型的消息：</p>
<ul>
<li>进度更新消息 ( ql&#x2F;progressUpdated )：处理查询执行进度更新</li>
<li>评估进度消息 ( evaluation&#x2F;progress )：处理评估操作的进度信息</li>
<li>请求响应消息：处理异步请求的响应</li>
</ul>
<h3 id="send"><a href="#send" class="headerlink" title="_send()"></a>_send()</h3><p>发送请求：发送JSON-RPC 请求到服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, payload</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.proc <span class="keyword">or</span> <span class="keyword">not</span> <span class="variable language_">self</span>.proc.stdin:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] Tried to send but process not running.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        data = json.dumps(payload)</span><br><span class="line">        content = <span class="string">f&quot;Content-Length: <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>\r\n\r\n<span class="subst">&#123;data&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n[→] Sending request:\n<span class="subst">&#123;json.dumps(payload, indent=<span class="number">2</span>)&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.proc.stdin.write(content)</span><br><span class="line">        <span class="variable language_">self</span>.proc.stdin.flush()</span><br></pre></td></tr></table></figure>

<h3 id="send-request"><a href="#send-request" class="headerlink" title="send_request()"></a>send_request()</h3><p>高级发送接口：发送异步请求并管理回调，为每个请求生成唯一ID，关联请求 ID 与回调函数，支持进度回调注册和状态跟踪。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h3><p>停止服务器</p>
<h3 id="find-class-identifier-position"><a href="#find-class-identifier-position" class="headerlink" title="find_class_identifier_position()"></a>find_class_identifier_position()</h3><p>在 QL 文件中查找类名标识符的位置，返回基于 1 的行列坐标。CodeQL 快速评估功能的关键组件，通过定位代码中的特定标识符，实现对部分代码的针对性分析。</p>
<h3 id="find-predicate-identifier-position"><a href="#find-predicate-identifier-position" class="headerlink" title="find_predicate_identifier_position()"></a>find_predicate_identifier_position()</h3><p>在 QL 文件中查找谓词（predicate）名称的位置，返回基于 1 的行列坐标。</p>
<p>类名查找和谓词查找可以用于支持CodeQL的快速评估功能，就是只执行查询的一部分，而不是执行全量查询，可以进行快速迭代和调试。</p>
<h3 id="register-databases-deregister-databases"><a href="#register-databases-deregister-databases" class="headerlink" title="register_databases() &amp;&amp; deregister_databases()"></a>register_databases() &amp;&amp; deregister_databases()</h3><p>注册注销数据库：向 CodeQL 查询服务器注册一个或多个数据库，使其可用于查询执行。</p>
<p>这是CodeQL客户端资源管理的核心，确保数据库在查询执行前正确注册，在执行后及时清理，是高效使用 CodeQL 服务器的关键组件。</p>
<h3 id="evaluate-queries"><a href="#evaluate-queries" class="headerlink" title="evaluate_queries()"></a>evaluate_queries()</h3><p>执行完整的 CodeQL 查询 ：在指定的数据库上运行一个 QL 查询文件，并将结果保存到输出文件。</p>
<ul>
<li>query_path ：QL 查询文件路径</li>
<li>db_path ：CodeQL 数据库路径</li>
<li>output_path ：结果输出文件路径（BQRS 格式）</li>
<li>callback ：异步完成回调（可选）</li>
<li>progress_callback ：进度回调（可选）</li>
</ul>
<p>默认完成处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">on_done</span>(<span class="params">result</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[evaluateQueries] done:&quot;</span>, result)</span><br><span class="line">    <span class="keyword">if</span> result.get(<span class="string">&quot;resultType&quot;</span>) != <span class="number">0</span>:  <span class="comment"># 0表示成功</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;result.get(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;Unknown error&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>发送异步请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.send_request(</span><br><span class="line">    <span class="string">&quot;evaluation/runQuery&quot;</span>,      <span class="comment"># JSON-RPC方法</span></span><br><span class="line">    params,                     <span class="comment"># 参数</span></span><br><span class="line">    callback <span class="keyword">or</span> on_done,        <span class="comment"># 使用用户回调或默认回调</span></span><br><span class="line">    progress_callback=progress_callback  <span class="comment"># 进度回调</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>函数会执行整个 QL 文件的所有查询，支持回调和进度跟踪。</p>
<h3 id="evaluate-and-wait"><a href="#evaluate-and-wait" class="headerlink" title="evaluate_and_wait()"></a>evaluate_and_wait()</h3><p>同步执行完整查询的便捷方法，其中包装了 evaluate_queries() 的异步功能，使用 wait_for_progress_done() 等待查询完成，简化了同步使用场景。</p>
<h3 id="quick-evaluate-and-wait"><a href="#quick-evaluate-and-wait" class="headerlink" title="quick_evaluate_and_wait()"></a>quick_evaluate_and_wait()</h3><p>同步执行快速评估，包装了quick_evaluate() 的异步功能，但是需要指定代码位置（行、列）。</p>
<h3 id="quick-evaluate"><a href="#quick-evaluate" class="headerlink" title="quick_evaluate()"></a>quick_evaluate()</h3><p>执行快速评估（Quick Evaluation） ：只执行 QL 查询文件中 特定代码片段 的查询，而不是整个文件。</p>
<ul>
<li>file_path ：QL 查询文件路径</li>
<li>db_path ：CodeQL 数据库路径</li>
<li>output_path ：结果输出文件路径</li>
<li>start_line , start_col ：起始位置（1-based）</li>
<li>end_line , end_col ：结束位置（1-based）</li>
<li>callback ：异步完成回调</li>
<li>progress_callback ：进度回调</li>
</ul>
<h3 id="wait-for-progress-done-wait-for-completion-callback"><a href="#wait-for-progress-done-wait-for-completion-callback" class="headerlink" title="wait_for_progress_done() &amp;&amp; wait_for_completion_callback()"></a>wait_for_progress_done() &amp;&amp; wait_for_completion_callback()</h3><p>功能 ：创建一个进度完成等待器 和 完成回调等待器。这两个函数都是 异步转同步 的工具：</p>
<ul>
<li>将异步回调模式转换为同步等待模式</li>
<li>简化了不需要复杂异步处理的场景</li>
<li>提供了更直观的API使用方式</li>
</ul>
<h2 id="MCP-Server-构建"><a href="#MCP-Server-构建" class="headerlink" title="MCP Server 构建"></a>MCP Server 构建</h2><p>基于 FastMCP 框架构建的 CodeQL 分析服务器，提供了 6 个工具来与 CodeQL 进行交互。</p>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>服务器初始化：使用 FastMCP 创建名为 “CodeQL” 的 MCP 服务器，实例化 CodeQLQueryServer 并启动，用于处理 CodeQL 查询操作。</p>
<h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><ol>
<li>register_database</li>
</ol>
<p>注册 CodeQL 数据库到查询服务器。验证数据库路径和必需的 src.zip 文件是否存在。</p>
<ol start="2">
<li>quick_evaluate</li>
</ol>
<p>快速评估 CodeQL 查询文件中的特定类或谓词，自动定位符号位置并执行评估。</p>
<ol start="3">
<li>decode_bqrs</li>
</ol>
<p>解码 CodeQL 结果文件（.bqrs 格式），支持 CSV（用于问题查询）或 JSON（用于路径问题）格式。</p>
<ol start="4">
<li>evaluate_query</li>
</ol>
<p>在指定数据库上运行完整的 CodeQL 查询文件。</p>
<ol start="5">
<li>find_class_position</li>
</ol>
<p>查找查询文件中类定义的准确位置（行号和列号）。</p>
<ol start="6">
<li>find_predicate_position</li>
</ol>
<p>查找查询文件中谓词定义的准确位置（行号和列号）。</p>
<h3 id="MCP-Server-代码"><a href="#MCP-Server-代码" class="headerlink" title="MCP Server 代码"></a>MCP Server 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mcp = FastMCP(<span class="string">&quot;CodeQL&quot;</span>)</span><br><span class="line">qs = CodeQLQueryServer()</span><br><span class="line">qs.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">register_database</span>(<span class="params">db_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This tool registers a CodeQL database given a path&quot;&quot;&quot;</span></span><br><span class="line">    db_path_resolved = Path(db_path).resolve()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> db_path_resolved.exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Database path does not exist: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    source_zip = db_path_resolved / <span class="string">&quot;src.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> source_zip.exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Missing required src.zip in: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    db_entry = &#123;</span><br><span class="line">        <span class="string">&quot;uri&quot;</span>: Path(db_path).resolve().as_uri(),</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;sourceArchiveZip&quot;</span>: (Path(db_path) / <span class="string">&quot;src.zip&quot;</span>).resolve().as_uri(),</span><br><span class="line">            <span class="string">&quot;dbDir&quot;</span>: Path(db_path).resolve().as_uri(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    callback, done, result_holder = qs.wait_for_completion_callback()</span><br><span class="line">    qs.register_databases(</span><br><span class="line">        [db_path],</span><br><span class="line">        callback=callback,</span><br><span class="line">        progress_callback=<span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">&quot;[progress] register:&quot;</span>, msg),</span><br><span class="line">    )</span><br><span class="line">    done.wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Database registered: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">quick_evaluate</span>(<span class="params"></span></span><br><span class="line"><span class="params">    file: <span class="built_in">str</span>, db: <span class="built_in">str</span>, symbol: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="string">&quot;/tmp/quickeval.bqrs&quot;</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This will allow you to quick_evaluate either a class or a predicate in a codeql query&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start, scol, end, ecol = qs.find_class_identifier_position(file, symbol)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        start, scol, end, ecol = qs.find_predicate_identifier_position(</span><br><span class="line">            file, symbol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qs.quick_evaluate_and_wait(</span><br><span class="line">            file, db, output_path, start, scol, end, ecol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> re:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;re&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">decode_bqrs</span>(<span class="params">bqrs_path: <span class="built_in">str</span>, fmt: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This can be used to decode CodeQL results, format is either csv for problem queries or json for path-problems&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> qs.decode_bqrs(bqrs_path, fmt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">evaluate_query</span>(<span class="params"></span></span><br><span class="line"><span class="params">    query_path: <span class="built_in">str</span>, db_path: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="string">&quot;/tmp/eval.bqrs&quot;</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Runs a CodeQL query on a given database&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qs.evaluate_and_wait(query_path, db_path, output_path)</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> re:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;re&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_class_position</span>(<span class="params">file: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds startline, startcol, endline endcol of a class for quickeval&quot;&quot;&quot;</span></span><br><span class="line">    start, scol, end, ecol = qs.find_class_identifier_position(file, name)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;start_line&quot;</span>: start,</span><br><span class="line">        <span class="string">&quot;start_col&quot;</span>: scol,</span><br><span class="line">        <span class="string">&quot;end_line&quot;</span>: end,</span><br><span class="line">        <span class="string">&quot;end_col&quot;</span>: ecol,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_predicate_position</span>(<span class="params">file: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds startline, startcol, endline endcol of a predicate for quickeval&quot;&quot;&quot;</span></span><br><span class="line">    start, scol, end, ecol = qs.find_predicate_identifier_position(file, name)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;start_line&quot;</span>: start,</span><br><span class="line">        <span class="string">&quot;start_col&quot;</span>: scol,</span><br><span class="line">        <span class="string">&quot;end_line&quot;</span>: end,</span><br><span class="line">        <span class="string">&quot;end_col&quot;</span>: ecol,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting CodeQL MCP server...&quot;</span>)</span><br><span class="line">    mcp.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="MCP-Server-测试"><a href="#MCP-Server-测试" class="headerlink" title="MCP Server 测试"></a>MCP Server 测试</h2><p>以注册数据库为例，进行MCP Server功能测试：</p>
<p>首先启动 MCP Server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(really_mcp) PS D:\Projects\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">[*] Read loop started</span><br><span class="line">INFO:     Started server process [23464]</span><br><span class="line">INFO:     Waiting <span class="keyword">for</span> application startup.</span><br><span class="line">INFO:     Application startup complete.</span><br><span class="line">INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 cursor 的 MCP tools 页面加载对应工具，选择启用状态：</p>
<p><img src="/../uploads/CodeQL_MCP_1.png"></p>
<p>对应配置文件如下：</p>
<p><img src="/../uploads/CodeQL_MCP_2.png"></p>
<p>MCP Server状态与 Tools 调用情况：</p>
<p><img src="/../uploads/CodeQL_MCP_3.png"></p>
<p>以上验证 CodeQL MCP 可成功调用并执行。</p>
<p>与服务器通信的数据包数据：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Accepted</span><br><span class="line">[12/15/25 20:26:54] INFO     Processing request of type CallToolRequest                   server.py:674</span><br><span class="line">[DEBUG] Sending evaluation/registerDatabases with progressId=0</span><br><span class="line"></span><br><span class="line">[→] Sending request:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;method&quot;: &quot;evaluation/registerDatabases&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;body&quot;: &#123;</span><br><span class="line">      &quot;databases&quot;: [</span><br><span class="line">        &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;progressId&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[stdout] Content-Length: 102</span><br><span class="line">[raw response body] &#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:1,&quot;result&quot;:&#123;&quot;registeredDatabases&quot;:[&quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">[←] Received response:</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">    ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INFO:     127.0.0.1:56577 - &quot;POST /messages/?session_id=d8bc9c141a864777b7a094f0a6abc6ad HTTP/1.1&quot; 202 Accepted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java漏洞靶场搭建学习(一)：环境搭建与Springboot架构</title>
    <url>/2025/12/09/Java%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8ESpringboot%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Java漏洞靶场搭建学习"><a href="#Java漏洞靶场搭建学习" class="headerlink" title="Java漏洞靶场搭建学习"></a>Java漏洞靶场搭建学习</h1><p>在学习 Java Web 安全的过程中，目前状态是只能理解相关的漏洞原理，根据 PoC 做题或者复现漏洞，但是这些对于 <strong>代码审计、漏洞挖掘、SDL</strong> 等都没有实质性帮助，想要在学习或工作过程中提升相关能力，计划实现以下目标：</p>
<ul>
<li>理解漏洞产生的真实上下文；</li>
<li>搭建一个可控、可扩展的实验环境；</li>
<li>训练从代码层面定位与修复问题的能力；</li>
</ul>
<p>这篇博客记录了学习搭建 Java 漏洞靶场的过程，作为一个学习记录，为后续能够快速搭建测试环境，验证代码审计工具能力奠定基础。</p>
<span id="more"></span>

<h2 id="项目选用"><a href="#项目选用" class="headerlink" title="项目选用"></a>项目选用</h2><p>本文以 <a href="https://github.com/l4yn3/micro_service_seclab">micro_service_seclab</a> 为基础进行练习。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/l4yn3/micro_service_seclab.git</span><br></pre></td></tr></table></figure>

<p>拿到java项目，导入IDEA，对于有pom.xml的项目，可以直接使用mvn进行构建。</p>
<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--链接数据库</span></span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE micro_service_seclab</span><br><span class="line">  <span class="keyword">CHARACTER SET</span> utf8mb4</span><br><span class="line">  <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用数据库</span></span><br><span class="line">USE micro_service_seclab;</span><br></pre></td></tr></table></figure>

<p>执行sql文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> \d D:\Code\micro_service_seclab</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line">mysql -u root -p micro_service_seclab &lt; micro_service_seclab.sql</span><br></pre></td></tr></table></figure>

<p>需要找到 application.properties  文件，修改对应的数据库用户名和密码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/micro_service_seclab</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=1234</span></span><br></pre></td></tr></table></figure>

<p>在pom.xml的路径下，执行mvn命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure>

<p>启动后访问 <a href="http://127.0.0.1:8080/sqlinjection/one?username=yueshen">http://127.0.0.1:8080/sqlinjection/one?username=yueshen</a> 即可看到返回以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;username&quot;</span>:<span class="string">&quot;yueshen&quot;</span>,<span class="string">&quot;sex&quot;</span>:1,<span class="string">&quot;age&quot;</span>:33&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h2><h3 id="Spring-Boot-三层架构"><a href="#Spring-Boot-三层架构" class="headerlink" title="Spring-Boot 三层架构"></a>Spring-Boot 三层架构</h3><p>该项目核心是一个 Spring Boot Web 应用，通过不同的 Controller 暴露漏洞演示接口；底层再通过 Logic&#x2F;DAO&#x2F;DB&#x2F;MyBatis 访问数据库或触发危险点。</p>
<p>调用链（一次请求的完整路径）：</p>
<blockquote>
<p>HTTP 请求 → controller（漏洞入口） → logic（业务&#x2F;场景封装） → dao&#x2F;mapper（数据访问&#x2F;危险实现） → db&#x2F;mysql</p>
</blockquote>
<p>用通俗的话来记录，就是：</p>
<p>Controller 提供靶场入口，Logic 做业务组织，DAO&#x2F;Mapper 负责数据库或危险 API 调用，data 是实体&#x2F;数据模型，db 是数据库初始化&#x2F;连接辅助。</p>
<ul>
<li><code>Controller</code>：漏洞入口层，对外提供 HTTP API，用户通过 HTTP 打开，它负责把请求带入对应的漏洞场景；</li>
<li><code>Logic</code>：业务场景封装层，存放 Service 的一些东西，把 Controller 参数变成底层可执行的动作；</li>
<li><code>Dao</code>：数据访问层，做数据持久化，方法针对数据库操作；</li>
<li><code>Mapper</code>：MyBatis Mapper 接口层，存放 MyBatis 的接口定义；</li>
<li><code>data</code>：数据模型 实体层 对应数据库表或接口数据结构；</li>
</ul>
<h3 id="部署搭建记录"><a href="#部署搭建记录" class="headerlink" title="部署搭建记录"></a>部署搭建记录</h3><p>首先选择新建项目：</p>
<p><img src="/../uploads/java_range1.png"></p>
<p>通过Springboot Initializr初始化项目:</p>
<p><img src="/../uploads/java_range2.png"></p>
<p>选择相关依赖：</p>
<p><img src="/../uploads/java_range3.png"></p>
<p>初始化项目结构如下：</p>
<p><img src="/../uploads/java_range4.png"></p>
<p>依赖还是存在一些问题，因为靶场对应的是Java1.8版本，但是IDEA创建project时只有17、21和25可选项（这个应该有办法解决，后续再搞），不过目前已经清楚了Springboot的架构是什么样子。</p>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="db-IndexDb-java"><a href="#db-IndexDb-java" class="headerlink" title="db&#x2F;IndexDb.java"></a>db&#x2F;IndexDb.java</h3><p><code>IndexDb.java</code> 是一个基于 <code>JdbcTemplate</code> 的数据库访问类，负责从 students 和 teachers 表中查询数据，同时为了漏洞靶场演示，刻意使用字符串拼接 SQL，存在明显的 SQL 注入风险。</p>
<p>详细解读：</p>
<ul>
<li><p>被标记为 @Repository，供其他层（如 IndexLogic &#x2F; Controller）注入使用。</p>
</li>
<li><p>内部定义了两个 RowMapper，把查询结果映射成 Student 和 Teacher 对象。</p>
</li>
<li><p>提供多种查询方法：</p>
<ol>
<li><p>按用户名模糊查询学生：getStudent &#x2F; getStudentWithOptional</p>
</li>
<li><p>按 id 查询学生：getStudentById</p>
</li>
<li><p>按 id 查询教师：getTeacherById</p>
</li>
<li><p>使用 IN 条件批量用户名查询学生：getStudentWithIn &#x2F; getStudentWithInLong</p>
</li>
</ol>
</li>
</ul>
<p>所有 SQL 都是直接拼接字符串（包括 Optional、List 的拼接）作为靶场中演示 SQL 注入的重要部分。截取部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexDb</span></span><br><span class="line"><span class="comment"> * 使用 Spring 的 JdbcTemplate 直接操作数据库的仓库类。</span></span><br><span class="line"><span class="comment"> * 主要提供针对 students / teachers 表的查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：本类为了配合“Java 漏洞靶场”，大量使用字符串拼接构造 SQL，</span></span><br><span class="line"><span class="comment"> *       实际上存在典型的 SQL 注入风险，用于安全演示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexDb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring 注入 JdbcTemplate，用于执行 SQL 语句</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Student 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Student&gt; ROW_MAPPER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        student.setSex(rs.getInt(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        student.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Teacher 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Teacher&gt; ROW_MAPPER_TEACHER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        teacher.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        teacher.setSex(rs.getBoolean(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        teacher.setName(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生信息。</span></span><br><span class="line"><span class="comment">     * 漏洞点：直接拼接 username 到 SQL 中，存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 安全写法示例（被注释掉）：使用占位符并绑定参数</span></span><br><span class="line">        <span class="comment">// String sql = &quot;select * from students where username like ?&quot;;</span></span><br><span class="line">        <span class="comment">// return jdbcTemplate.query(sql, new Object[]&#123;&quot;%&quot; + username + &quot;%&quot;&#125;, ROW_MAPPER);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名进行模糊查询。</span></span><br><span class="line"><span class="comment">     * 实际上仍然是字符串拼接，同样存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithOptional</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username.get() + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 id 精确查询学生。</span></span><br><span class="line"><span class="comment">     * 漏洞点：将 id 转成字符串再拼接到 SQL 中，存在注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithInt</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where id = &#x27;&quot;</span> + String.valueOf(id) + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithInt, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="logic-IndexLogic-java"><a href="#logic-IndexLogic-java" class="headerlink" title="logic&#x2F;IndexLogic.java"></a>logic&#x2F;IndexLogic.java</h3><p><code>IndexLogic.java</code> 本质上是<strong>Service 层的一个浅封装</strong>：</p>
<ul>
<li>用 <code>@Service</code> 标记，表示这是业务逻辑层的 Bean；</li>
<li>通过 <code>@Autowired</code> 注入 <code>IndexDb</code>（4.1节对应的那个数据库访问类）；</li>
<li>对外提供一组方法：<code>getStudent</code> &#x2F; <code>getStudentById</code> &#x2F; <code>getStudentWithOptional</code> &#x2F; <code>getStudentWithIn</code> &#x2F; <code>getStudentWithInLong</code> &#x2F; <code>getTeacherById</code>；</li>
<li>每个方法都<strong>直接把参数原样转发给 <code>IndexDb</code>，不做额外处理</strong>，相当于“转发层”；</li>
<li>因为 <code>IndexDb</code> 里面的 SQL 是拼接的，所以这些 Service 方法也就“顺带”暴露出 SQL 注入漏洞场景，方便 Controller 调用。</li>
</ul>
<p>可以理解为：<br><strong>Controller -&gt; IndexLogic -&gt; IndexDb -&gt; Databases</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexLogic</span></span><br><span class="line"><span class="comment"> * 业务逻辑层（Service），对外提供学生 / 老师相关的查询接口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当前实现非常薄，只是简单地把调用转发给 IndexDb，</span></span><br><span class="line"><span class="comment"> * 主要起到：Controller 与 DB 操作之间的“中间层”作用，</span></span><br><span class="line"><span class="comment"> * 方便保持三层架构的结构清晰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于底层 IndexDb 使用字符串拼接 SQL，</span></span><br><span class="line"><span class="comment"> * 这些方法实际也用于配合漏洞靶场演示 SQL 注入场景。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexLogic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入数据库访问类 IndexDb</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IndexDb indexDb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudent(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithOptional(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（字符串列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithIn</span><span class="params">(List&lt;String&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithIn(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（Long 列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithInLong</span><span class="params">(List&lt;Long&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithInLong(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据“id/userName”查询老师</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getTeacherById</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getTeacherById(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IndexLogic 是 Controller 和 IndexDb 之间的桥梁，把各种查询操作组织成业务接口，方便暴露为 HTTP 靶场接口。</strong></p>
<hr>
<h3 id="mapper-IStudentMapper-java"><a href="#mapper-IStudentMapper-java" class="headerlink" title="mapper&#x2F;IStudentMapper.java"></a>mapper&#x2F;IStudentMapper.java</h3><p>IStudentMapper 是 students 表的 MyBatis 接口，其中 <code>queryAllByAnnotations</code> 用注解 + <code>$&#123;&#125;</code> 拼串，专门用来检测注解式 SQL 注入漏洞。</p>
<p>Mapper <strong>≈</strong> 映射器，他的作用是把 “Java 方法调用” 映射成 “SQL 语句执行”，再把结果映射回 Java 对象。也可以称为“MyBatis 帮忙自动实现的 DAO 接口”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IStudentMapper</span></span><br><span class="line"><span class="comment"> * MyBatis 的 Mapper 接口，对 students 表提供查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个接口有两个目的：</span></span><br><span class="line"><span class="comment"> * 1）正常的查询方法（queryAll），SQL 通常写在 XML 中；</span></span><br><span class="line"><span class="comment"> * 2）使用注解 + $&#123;&#125; 拼接参数的方式，故意制造 SQL 注入漏洞，</span></span><br><span class="line"><span class="comment"> *    用于测试代码扫描工具是否能识别注解里的注入问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一：常规查询方法</span></span><br><span class="line"><span class="comment">     * SQL 写在 resources/mappers/IStudentMapper.xml 中，</span></span><br><span class="line"><span class="comment">     * 一般会使用 #&#123;name&#125; 这种占位符，属于参数绑定写法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAll</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式二：注解式 SQL，故意使用 $&#123;&#125; 直接拼接参数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里的 SQL：</span></span><br><span class="line"><span class="comment">     *   select * from students where username =&#x27;$&#123;name&#125;&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * $&#123;name&#125; 会被原样替换到 SQL 中，存在明显的 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     * 这是靶场中专门用来测试“静态扫描工具能否发现注解里的 SQL 注入”的例子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from students where username =&#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAllByAnnotations</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="data-Person-java"><a href="#data-Person-java" class="headerlink" title="data&#x2F;Person.java"></a>data&#x2F;Person.java</h3><p>data 文件夹下专门存放了“数据模型”，可以保存数据库和业务里的“实体对象”。同时作为各个层次之间传递数据的载体：</p>
<ul>
<li><p>db&#x2F;IndexDb 查出来的是 List<Student>、List<Teacher></p>
</li>
<li><p>logic&#x2F;IndexLogic 接收&#x2F;返回的也是这些对象</p>
</li>
<li><p>Controller 对外返回的 JSON，其实就是把这些 data 类序列化出去</p>
</li>
</ul>
<p>👉 这样 Controller、Service、DAO 都围绕同一套“数据结构”在交流。</p>
<p>Person 是用 JPA+Hibernate 映射出来的人员表实体，用 UUID 当主键，并强制 username 和 nickname 的唯一性与非空约束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person 实体类：</span></span><br><span class="line"><span class="comment"> * 映射数据库中的 person 表（默认表名），</span></span><br><span class="line"><span class="comment"> * 使用 UUID 作为主键，包含唯一且必填的 username / nickname 字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主键 ID，使用自定义的 UUID 生成策略</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(generator = &quot;idGenerator&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 昵称列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;nickname&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dao-PersonRepository-java"><a href="#dao-PersonRepository-java" class="headerlink" title="dao&#x2F;PersonRepository.java"></a>dao&#x2F;PersonRepository.java</h3><p><code>PersonRepository</code> 是一个基于 Spring Data JPA 的 DAO 接口，负责对 Person 实体做数据库查询：根据 username 和 nickname 查人，供 Controller 或 Service 调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersonRepository</span></span><br><span class="line"><span class="comment"> * 基于 Spring Data JPA 的 DAO 接口，</span></span><br><span class="line"><span class="comment"> * 用于对 Person 实体进行数据库访问操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过继承 JpaRepository，可以直接使用通用的增删改查方法，</span></span><br><span class="line"><span class="comment"> * 同时也可以定义派生查询方法或自定义 <span class="doctag">@Query</span> 查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Person, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Spring Data JPA 的“方法名派生查询”功能，</span></span><br><span class="line"><span class="comment">     * 根据 username 字段查询 Person 列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 等价于：SELECT p FROM Person p WHERE p.username = ?1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 <span class="doctag">@Query</span> 手写 JPQL 查询，根据 nickname 查询。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT nickname FROM Person WHERE nickname = &#x27;?1&#x27;&quot;)</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByNickname</span><span class="params">(String nickname)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="controller-VulnerabilitiesController-java"><a href="#controller-VulnerabilitiesController-java" class="headerlink" title="controller&#x2F;VulnerabilitiesController.java"></a>controller&#x2F;VulnerabilitiesController.java</h3><p><code>controller</code> 文件夹用来存放项目里的控制器类，也就是对外暴露 HTTP 接口的那一层。在 Spring Boot 里，Controller 负责接收浏览器或工具（如 Postman、burp）的请求，解析参数，把请求转交给逻辑层（logic&#x2F;service），再把返回结果封装成 JSON 或页面响应。</p>
]]></content>
      <categories>
        <category>Java Security</category>
      </categories>
      <tags>
        <tag>Java Security</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（一）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-概念"><a href="#MCP-概念" class="headerlink" title="MCP 概念"></a>MCP 概念</h2><p>MCP 编程快速入门，MCP 全称 Model Context Protocol 模型上下文协议，其定义了 LLMs 与外部世界的互动方式，MCP 提供了一种标准化方法，使任意 LLMs 能够轻松连接各种数据源和工具，实现信息的高效交互和处理。</p>
<p>目前的 AI 朝着两个方向发展：<strong>掌握更多信息</strong> 或 <strong>控制更多工具</strong>，在没有联网搜索之前，LLM 的数据来源只有训练时和推理时我们提供的数据。</p>
<p>在MCP出现之前，如果LLM要访问外部数据，通常使用<code>Function Call</code>的方式，<code>Function Call</code>通过给模型预设函数描述（包括函数名、参数说明、返回值格式等），让模型在合适的时候返回一个符合结构的 JSON 格式，外部系统再解析这个 JSON，调用实际的后端函数。关于 <code>Function Call</code> 和<code>MCP</code> 的具体区别在 <a href="/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Function Call和MCP的区别">Function Call和MCP的区别</a></p>
<p>但 <code>Function Call</code> 的方式没有一个统一的开发规范，你开发的函数我不能用，我开发的函数你不能用，而且开发起来很麻烦，为了解决这个问题，MCP 出现了。MCP作为LLMs的标准化工具箱，可以通过MCP调用外界的AI工具，而AI工具在开发的时候也需要遵循MCP协议。MCP 允许应用以标准化的方式向 LLM 提供上下文，并将<strong>提供上下文的逻辑</strong>与<strong>实际的LLM交互逻辑”</strong>解耦。</p>
<p>在没有 MCP 之前，如果我们希望让模型使用本地数据，通常需要把这些数据直接复制到对话框中，让模型从文本中获取信息。而有了 MCP 之后，我们可以为特定能力编写一个 MCP Server，例如数据库读取、GitHub 操作、文件系统访问或获取当前时间等。模型通过 MCP 与这些 Server 通信，就能在无需手动粘贴数据的情况下，实时访问这些外部资源。</p>
<p><img src="/../uploads/MCP_1.png"></p>
<p>MCP 服务器可以提供三种主要类型的功能:</p>
<ol>
<li>资源访问：客户端读取文件等数据；</li>
<li>工具调用：由LLM调用的函数；</li>
<li>Prompt模板：预先编写的帮助客户完成特定任务的Prompt；</li>
</ol>
<span id="more"></span>

<h2 id="MCP-Deno-开发"><a href="#MCP-Deno-开发" class="headerlink" title="MCP Deno 开发"></a>MCP Deno 开发</h2><p>使用python的SDK，简单实现下面功能，用来加深理解：</p>
<ol>
<li>构建可连接到任何 MCP Server 的 MCP Client</li>
<li>创建公开资源、提示和工具的 MCP Server</li>
<li>使用 stdio 和 SSE 等标准传输</li>
<li>处理所有 MCP 协议消息和生命周期事件</li>
</ol>
<p>一般关于MCP的项目，开发者们都喜欢用uv来管理，不晓得为什么，但是跟着用一下，相关安装使用方法参照 <a href="/2025/12/10/uv%E4%BD%BF%E7%94%A8/" title="uv使用">uv使用</a> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的项目</span></span><br><span class="line">uv init mcp-demo</span><br><span class="line"><span class="built_in">cd</span> mcp-demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">uv venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">uv add <span class="string">&quot;mcp[cli]&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这样一个uv管理的python MCP 项目就初始化完成了。</p>
<p>接下来编写第一个简单Demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 FastMCP 实例</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例工具</span></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例资源</span></span><br><span class="line"><span class="meta">@mcp.resource(<span class="params"><span class="string">&quot;greeting://&#123;name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;FastMCP Demo Server is running ......&quot;</span>)</span><br><span class="line">    mcp.run()</span><br></pre></td></tr></table></figure>

<p>示例代码中，使用了FastMCP来初始化一个MCP Server实例，分别创建了三个函数：</p>
<ul>
<li>echo：字符串输出；</li>
<li>add：两个数字相加；</li>
<li>greet：输入字符串，拼接后返回字符串；</li>
</ul>
<p>通过两个注解，赋予了函数不同的能力：</p>
<ul>
<li>@tool()：函数可以直接被AI调用；</li>
<li>@resource()：像API接口一样被调用，其中的参数 greeting:&#x2F;&#x2F;{name} 是一个自定义的 URI， 可以拆解为两个部分。greeting 是随便起的前缀，name是动态参数的名称，在访问的时候需要传入。</li>
</ul>
<p>测试命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mcp dev server.py</span><br></pre></td></tr></table></figure>

<p><code>mcp dev</code>是开发调试模式，输入这条命令后，会打开一个 MCP Inspector ，可以直观地检查和测试 MCP Server（server.py）是否正常工作。</p>
<p><img src="/../uploads/MCP_2.png"></p>
<p>点击 Connect ，选择 Tools，List Tools，即可列出 MCP 中定义的工具，可以输入测试内容进行 run tools测试:</p>
<p><img src="/../uploads/MCP_3.png"></p>
<p>在 Resources 标签页下，可以看到定义的资源函数 greet:</p>
<p><img src="/../uploads/MCP_4.png"></p>
<p>传入动态参数，mcp server 就会返回 json 格式的响应，并将我们输入的 api 拼接后返回。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>博客记录了对于 MCP 的理解，以及一个简单的Demo，后续在这个基础上继续完善。</p>
<p>对 MCP Server 的开发是 MCP应用的重点，作者提到 MCP Server 其实就是定义一些函数，让智能体调用。在函数中可以实现简单逻辑、接口调用和各种操作，并通过注解赋予函数不同的能力。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>什么是MCP？本地如何开发MCP Server：<a href="https://cloud.tencent.com/developer/article/2511642">https://cloud.tencent.com/developer/article/2511642</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（三）</title>
    <url>/2025/12/12/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-Server-开发实践"><a href="#MCP-Server-开发实践" class="headerlink" title="MCP Server 开发实践"></a>MCP Server 开发实践</h2><p>对于大部分 AI 开发者来说，MCP 只需要关心 Server 的实现，通过一个简单示例学习如何实现一个 MCP Server。</p>
<p>MCP Server 可以提供三种主要类型的功能：</p>
<ul>
<li>Resources（资源）：类似文件的数据，可以被客户端读取；</li>
<li>Tools（工具）：可以被LLM调用的函数；</li>
<li>Prompt（提示）：预先编写的模版，帮助用户完成特定任务；</li>
</ul>
<p>任务：使用Python实现一个MCP Server，用来统计当前桌面上的 txt 文件数量和获取对应文件的名字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MCP Server</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;桌面 TXT 文件统计器&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_desktop_txt_files</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Count the number of .txt files on the desktop.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Get the desktop path</span></span><br><span class="line">    username = os.getenv(<span class="string">&quot;USER&quot;</span>) <span class="keyword">or</span> os.getenv(<span class="string">&quot;USERNAME&quot;</span>)</span><br><span class="line">    desktop_path = Path(<span class="string">f&quot;C:\\Users\\<span class="subst">&#123;username&#125;</span>\\Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Count .txt files</span></span><br><span class="line">    txt_files = <span class="built_in">list</span>(desktop_path.glob(<span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(txt_files)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_desktop_txt_files</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get a list of all .txt filenames on the desktop.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Get the desktop path</span></span><br><span class="line">    username = os.getenv(<span class="string">&quot;USER&quot;</span>) <span class="keyword">or</span> os.getenv(<span class="string">&quot;USERNAME&quot;</span>)</span><br><span class="line">    desktop_path = Path(<span class="string">f&quot;C:\\Users\\<span class="subst">&#123;username&#125;</span>\\Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get all .txt files</span></span><br><span class="line">    txt_files = <span class="built_in">list</span>(desktop_path.glob(<span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the filenames</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> txt_files:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No .txt files found on desktop.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Format the list of filenames</span></span><br><span class="line">    file_list = <span class="string">&quot;\n&quot;</span>.join([<span class="string">f&quot;- <span class="subst">&#123;file.name&#125;</span>&quot;</span> <span class="keyword">for</span> file <span class="keyword">in</span> txt_files])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(txt_files)&#125;</span> .txt files on desktop:\n<span class="subst">&#123;file_list&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Initialize and run the server</span></span><br><span class="line">    mcp.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MCP-Server-测试"><a href="#MCP-Server-测试" class="headerlink" title="MCP Server 测试"></a>MCP Server 测试</h3><p>测试 MCP Server， <code>mcp dev server.py</code> ，进行服务测试。</p>
<p><img src="/../uploads/MCP_12.png"></p>
<p>如图所示，成功生成了对应的 Tool Result ，即为测试成功。</p>
<h3 id="接入-Claude-Desktop"><a href="#接入-Claude-Desktop" class="headerlink" title="接入 Claude Desktop"></a>接入 Claude Desktop</h3><p>这里 Claude Desktop 注册时需要手机号绑定，目前没有外国手机号，所以找了个平替的平台 Trae。</p>
<p>配置文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server_txt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\77319\\.local\\bin\\uv.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--directory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;D:\\Code\\mcp-demo&quot;</span><span class="punctuation">,</span> <span class="comment">// 你的项目路径（这里是我的）</span></span><br><span class="line">        <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;server_txt.py&quot;</span> <span class="comment">// 你的 MCP Server 文件名</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>手动添加 MCP 配置：</p>
<p><img src="/../uploads/MCP_13.png"></p>
<p>选择 MCP ：</p>
<p><img src="/../uploads/MCP_14.png"></p>
<p>提出问题：帮我分析桌面txt文件的含义</p>
<p>思考过程：</p>
<p>用户让我推测桌面txt文件名的含义，之前已经通过MCP工具获取到桌面上有3个txt文件：</p>
<ul>
<li>3.多模态信息融合.txt</li>
<li>API Key.txt</li>
<li>密码本.txt<br>我需要基于文件名来推测它们的含义，不需要查看文件内容。让我分析每个文件名：</li>
</ul>
<ol>
<li><p>“3.多模态信息融合.txt”：</p>
<ul>
<li>“3.” 可能表示这是一系列文件中的第3个</li>
<li>“多模态信息融合” 是一个专业术语，通常指将不同类型的数据（如文本、图像、音频等）结合起来进行分析和处理</li>
<li>这个文件可能包含关于多模态信息融合技术的笔记、研究或资料</li>
</ul>
</li>
<li><p>“API Key.txt”：</p>
<ul>
<li>“API Key” 是应用程序接口密钥的缩写，用于身份验证和授权</li>
<li>这个文件可能包含各种服务或平台的API密钥</li>
</ul>
</li>
<li><p>“密码本.txt”：</p>
<ul>
<li>“密码本” 通常指存储密码的文档</li>
<li>这个文件可能包含各种账户的用户名和密码信息</li>
</ul>
</li>
</ol>
<p>我需要将这些分析整理成一个清晰的回应。</p>
<p>回复内容：</p>
<p>基于之前获取的桌面上的txt文件名，我可以推测它们的含义。让我分析每个文件名并提供合理的解释。基于桌面txt文件名，我可以做出以下推测：</p>
<ol>
<li><p><strong>3.多模态信息融合.txt</strong></p>
<ul>
<li>“3.” 可能表示这是一系列相关文件中的第3个</li>
<li>“多模态信息融合” 是人工智能领域的专业术语，指将不同类型的数据（如文本、图像、音频、视频等）结合起来进行分析和处理的技术</li>
<li>这个文件很可能包含关于多模态信息融合技术的研究资料、学习笔记或项目文档</li>
</ul>
</li>
<li><p><strong>API Key.txt</strong></p>
<ul>
<li>“API Key”（应用程序接口密钥）是用于身份验证和授权的安全凭证</li>
<li>这个文件可能存储了各种在线服务、开发平台或应用程序的API密钥，方便用户在开发或使用相关服务时快速获取</li>
</ul>
</li>
<li><p><strong>密码本.txt</strong></p>
<ul>
<li>“密码本” 是一个常见的术语，指专门用于记录密码的文档</li>
<li>这个文件很可能包含了用户在各种网站、应用程序或服务上的账户名称和对应的密码信息，用于集中管理和记忆</li>
</ul>
</li>
</ol>
<p>这些文件都与数字信息管理和技术相关，可能是用户在学习、工作或日常使用计算机时创建的重要参考文档。</p>
<p>上述结果表明 MCP Server 已经可以正常工作。</p>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（二）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="模型如何确定工具选用？"><a href="#模型如何确定工具选用？" class="headerlink" title="模型如何确定工具选用？"></a>模型如何确定工具选用？</h2><p>Anthropic 详细解释了这个问题：模型在什么时候确定使用哪些工具。</p>
<p>当用户提出一个问题时：</p>
<ol>
<li>客户端（Claude Desktop &#x2F; Cursor）将问题发送给 Claude；</li>
<li>Claude 分析可用的工具，并决定使用哪一个（或多个）；</li>
<li>客户端通过 MCP Server 执行所选的工具；</li>
<li>工具的执行结果被送回给 Claude；</li>
<li>Claude 结合执行结果构造最终的 prompt 并生成自然语言的回应；</li>
<li>回应最终展示给用户！</li>
</ol>
<p>MCP Server 是由 Claude 主动选择并调用的，这个主动选择的过程可以分为两步：</p>
<ol>
<li>由 LLM（Claude）确定使用哪些 MCP Server；</li>
<li>执行对应的 MCP Server 并对执行结果进行重新处理；</li>
</ol>
<p>MCP 流程图如下：</p>
<p><img src="/../uploads/MCP_11.jpg"></p>
<p>流程图展示了 LLM 在接收到用户输入后，根据系统提示中提供的指令与工具描述，决定是否需要调用外部工具（包括 MCP Server 提供的工具）。<br>首先，用户输入与系统 prompt（包含工具的结构化描述）一同交给模型生成 Message1。如果模型判断某个任务需要借助工具完成（Case 1），它会生成一段结构化的 Tool call JSON，并由外部执行环境或 MCP Server 负责实际执行工具逻辑。执行结果再返回给模型，模型基于这份结果生成最终回答；<br>如果模型判断不需要工具（Case 2），则直接生成最终输出。<br>整个流程体现了：LLM 负责“决定用什么工具及如何调用”，而 MCP Servers 等外部系统负责“实际执行任务并返回数据”，从而实现模型与外部能力的协作。</p>
<span id="more"></span>

<h2 id="模型如何智能选择工具？"><a href="#模型如何智能选择工具？" class="headerlink" title="模型如何智能选择工具？"></a>模型如何智能选择工具？</h2><p>模型如何确定该使用哪些工具，MCP 官方提供的 client example 示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="comment"># 初始化所有的 mcp server</span></span><br><span class="line">     <span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable language_">self</span>.servers:</span><br><span class="line">         <span class="keyword">await</span> server.initialize()</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 获取所有的 tools 命名为 all_tools</span></span><br><span class="line">     all_tools = []</span><br><span class="line">     <span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable language_">self</span>.servers:</span><br><span class="line">         tools = <span class="keyword">await</span> server.list_tools()</span><br><span class="line">         all_tools.extend(tools)</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 将所有的 tools 的功能描述格式化成字符串供 LLM 使用</span></span><br><span class="line">     <span class="comment"># tool.format_for_llm() 我放到了这段代码最后，方便阅读。</span></span><br><span class="line">     <span class="comment"># 为 LLM 生成工具说明文档，告诉模型：有哪些工具、各自干啥、要什么参数。</span></span><br><span class="line">     tools_description = <span class="string">&quot;\n&quot;</span>.join(</span><br><span class="line">         [tool.format_for_llm() <span class="keyword">for</span> tool <span class="keyword">in</span> all_tools]</span><br><span class="line">     )</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 这里就不简化了，以供参考，实际上就是基于 prompt 和当前所有工具的信息</span></span><br><span class="line">     <span class="comment"># 询问 LLM（Claude） 应该使用哪些工具。</span></span><br><span class="line">     system_message = (</span><br><span class="line">         <span class="string">&quot;You are a helpful assistant with access to these tools:\n\n&quot;</span></span><br><span class="line">         <span class="string">f&quot;<span class="subst">&#123;tools_description&#125;</span>\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span></span><br><span class="line">         <span class="string">&quot;If no tool is needed, reply directly.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span></span><br><span class="line">         <span class="string">&quot;the exact JSON object format below, nothing else:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">         <span class="string">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\n&#x27;</span></span><br><span class="line">         <span class="string">&#x27;    &quot;arguments&quot;: &#123;\n&#x27;</span></span><br><span class="line">         <span class="string">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\n&#x27;</span></span><br><span class="line">         <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;&#125;\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;After receiving a tool&#x27;s response:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;1. Transform the raw data into a natural, conversational response\n&quot;</span></span><br><span class="line">         <span class="string">&quot;2. Keep responses concise but informative\n&quot;</span></span><br><span class="line">         <span class="string">&quot;3. Focus on the most relevant information\n&quot;</span></span><br><span class="line">         <span class="string">&quot;4. Use appropriate context from the user&#x27;s question\n&quot;</span></span><br><span class="line">         <span class="string">&quot;5. Avoid simply repeating the raw data\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Please use only the tools that are explicitly defined above.&quot;</span></span><br><span class="line">     )</span><br><span class="line">     messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_message&#125;]</span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="comment"># Final... 假设这里已经处理了用户消息输入.</span></span><br><span class="line">         messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 将 system_message 和用户消息输入一起发送给 LLM</span></span><br><span class="line">         llm_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line"> ​</span><br><span class="line">     ... <span class="comment"># 后面和确定使用哪些工具无关</span></span><br><span class="line">     </span><br><span class="line"> ​</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Represents a tool with its properties and formatting.&quot;&quot;&quot;</span></span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">         self, name: <span class="built_in">str</span>, description: <span class="built_in">str</span>, input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span></span><br><span class="line"><span class="params">     </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">         <span class="variable language_">self</span>.name: <span class="built_in">str</span> = name</span><br><span class="line">         <span class="variable language_">self</span>.description: <span class="built_in">str</span> = description</span><br><span class="line">         <span class="variable language_">self</span>.input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = input_schema</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 把工具的名字 / 工具的用途（description）和工具所需要的参数（args_desc）转化为文本</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">format_for_llm</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">         <span class="string">&quot;&quot;&quot;Format tool information for LLM.</span></span><br><span class="line"><span class="string"> ​</span></span><br><span class="line"><span class="string">         Returns:</span></span><br><span class="line"><span class="string">             A formatted string describing the tool.</span></span><br><span class="line"><span class="string">         &quot;&quot;&quot;</span></span><br><span class="line">         args_desc = []</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&quot;properties&quot;</span> <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema:</span><br><span class="line">             <span class="keyword">for</span> param_name, param_info <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema[<span class="string">&quot;properties&quot;</span>].items():</span><br><span class="line">                 arg_desc = (</span><br><span class="line">                     <span class="string">f&quot;- <span class="subst">&#123;param_name&#125;</span>: <span class="subst">&#123;param_info.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;No description&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line">                 )</span><br><span class="line">                 <span class="keyword">if</span> param_name <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema.get(<span class="string">&quot;required&quot;</span>, []):</span><br><span class="line">                     arg_desc += <span class="string">&quot; (required)&quot;</span></span><br><span class="line">                 args_desc.append(arg_desc)</span><br><span class="line"> ​</span><br><span class="line">         <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> Tool: <span class="subst">&#123;self.name&#125;</span></span></span><br><span class="line"><span class="string"> Description: <span class="subst">&#123;self.description&#125;</span></span></span><br><span class="line"><span class="string"> Arguments:</span></span><br><span class="line"><span class="string"> <span class="subst">&#123;<span class="built_in">chr</span>(<span class="number">10</span>).join(args_desc)&#125;</span></span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>模型会通过 Prompt 来确定当前有哪些工具，通过将工具的具体使用描述以文本的形式传递给模型，供模型了解有哪些工具以及结合实时情况进行选择。</p>
<blockquote>
<p><strong>从所有 MCP Server 中“收集工具 → 转成给 LLM 看得懂的文字说明 → 拼到 system prompt 里 → 让 LLM 根据这些工具描述来决定要不要调用工具、调用哪个工具。</strong></p>
</blockquote>
<p>在整个 MCP 的大图景里，这段代码扮演的是<strong>中间协调者 &#x2F; 适配层</strong>：</p>
<ol>
<li>对下游（MCP Servers）</li>
</ol>
<ul>
<li><p>负责初始化所有 MCP Server</p>
</li>
<li><p>通过 list_tools() 探测每个 server 暴露的工具</p>
</li>
<li><p>把工具的 JSON Schema 等结构化信息，抽象成 Tool 对象</p>
</li>
</ul>
<ol start="2">
<li>对上游（LLM）</li>
</ol>
<ul>
<li><p>把所有工具信息整合并转成人类语言说明（format_for_llm）</p>
</li>
<li><p>把说明塞进 system prompt，告诉 LLM 它有哪些能力可以用</p>
</li>
<li><p>通过严格的 JSON 格式约束，让 LLM 以稳定可解析的方式返回“我要用哪个工具+参数”</p>
</li>
</ul>
<ol start="3">
<li>对中间逻辑（Router &#x2F; Orchestrator）</li>
</ol>
<ul>
<li><p>后续根据 LLM 的工具选择 JSON 再去调用相应 MCP server 的 tool</p>
</li>
<li><p>把结果反馈给 LLM，让它生成自然语言答复</p>
</li>
</ul>
<blockquote>
<p><strong>它让“多 MCP Server 的工具”对 LLM 看起来像一组统一、清晰、可选择的工具菜单。</strong></p>
</blockquote>
<h2 id="工具执行和结果反馈机制"><a href="#工具执行和结果反馈机制" class="headerlink" title="工具执行和结果反馈机制"></a>工具执行和结果反馈机制</h2><p>工具的执行就是把 system prompt 指令和工具调用描述，还有用户消息一起发送给模型，然后接收模型的回复。当模型分析用户请求后，它会决定是否需要调用工具。如果回复中包含结构化 json 格式的工具调用请求，则客户端会根据这个 json 代码执行对应的工具。</p>
<p>如果模型执行了 tool call，则工具执行的结果 result 会和 system prompt 和用户消息一起重新发送给模型，请求模型生成最终回复。同时，如果 tool call 的 json 代码存在问题或者模型产生了幻觉，那么系统会 skip 掉无效的调用请求。</p>
<p>工具执行的相关代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">     ... <span class="comment"># 上面已经介绍过了，模型如何选择工具</span></span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="comment"># 假设这里已经处理了用户消息输入.</span></span><br><span class="line">         messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 获取 LLM 的输出</span></span><br><span class="line">         llm_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 处理 LLM 的输出（如果有 tool call 则执行对应的工具）</span></span><br><span class="line">         result = <span class="keyword">await</span> <span class="variable language_">self</span>.process_llm_response(llm_response)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 如果 result 与 llm_response 不同，说明执行了 tool call （有额外信息了）</span></span><br><span class="line">         <span class="comment"># 则将 tool call 的结果重新发送给 LLM 进行处理。</span></span><br><span class="line">         <span class="keyword">if</span> result != llm_response:</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: result&#125;)</span><br><span class="line"> ​</span><br><span class="line">             final_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line">             logging.info(<span class="string">&quot;\nFinal response: %s&quot;</span>, final_response)</span><br><span class="line">             messages.append(</span><br><span class="line">                 &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: final_response&#125;</span><br><span class="line">             )</span><br><span class="line">         <span class="comment"># 否则代表没有执行 tool call，则直接将 LLM 的输出返回给用户。</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: llm_response&#125;) </span><br></pre></td></tr></table></figure>

<p>两个要点：</p>
<ol>
<li>工具对应的文档很重要： 模型通过工具描述文本来理解和选择工具，因此精心编写工具的名称、docstring 和参数说明至关重要；</li>
<li>由于 MCP 的选择是基于 prompt 的，所以任何模型其实都适配 MCP，只要能提供对应的工具描述。但是当你使用非 Claude 模型时，MCP 使用的效果和体验难以保证（没有做专门的训练，这个不太确定，后续需要测试一下）。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><strong>MCP 的本质</strong>：它是一个统一的协议标准，使 AI 模型能够以一致的方式连接各种数据源和工具，类似于 AI 世界的”USB-C”接口。</li>
<li><strong>MCP 的价值</strong>：它解决了传统 function call 的平台依赖问题，提供了更统一、开放、安全、灵活的工具调用机制，让用户和开发者都能从中受益。</li>
<li>使用与开发：对于普通用户，MCP 提供了丰富的现成工具，用户可以在不了解任何技术细节的情况下使用；对于开发者，MCP 提供了清晰的架构和 SDK，使工具开发变得相对简单。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>MCP(Model Context Protocol)一篇就够了：<a href="https://zhuanlan.zhihu.com/p/29001189476">https://zhuanlan.zhihu.com/p/29001189476</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>OSCP学习心得</title>
    <url>/2025/12/12/OSCP%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>在 OSCP 的学习和练习以及打靶场或者渗透测试过程中，我认为本质上不是掌握了多少工具，而是在规定时间内，能不能把渗透的全流程跑完，关键步骤上思维能否发散，能否有较为全面的思考和枚举，所以重心还是在思路上，渗透的思路和应对关键点时的经验，所以记录一些自己的思考。</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>重点在于覆盖面和可用性：</p>
<ul>
<li>覆盖面：全端口（服务）扫描，不要漏掉服务，不然可能会找不到正确的入口点；</li>
<li>可用性：不同服务、版本都有什么漏洞，是否具备利用条件，无法利用的话是不是加了什么限制，是需要绕过限制还是需要转变路径，这些属于能否实现利用的范畴；</li>
</ul>
<blockquote>
<p><strong>信息收集要得出一个结论：我到底能打哪些入口？哪些入口最可能实现边界突破？</strong></p>
</blockquote>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞利用阶段不要盲目跑exp，最好是先验证控制程度，再拿shell。</p>
<p>先确定漏洞是否真实存在，漏洞可控点在哪里，输入如何影响输出，然后再确认控制深度（能否读写文件&#x2F;命令执行&#x2F;鉴权绕过），最后在拿稳定shell。</p>
<blockquote>
<p><strong>先看能不能验证清楚，在考虑能否一步到位。</strong></p>
</blockquote>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>提权并没有深入学习太多，但是感觉应该在于找到“权限边界被破坏”的证据，可以根据历史经验寻找线索，找到稳定可复现的思路。</p>
<h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><blockquote>
<p><strong>信任关系+凭证流向</strong>: 从以控制主机把影响力扩到更有价值的主机&#x2F;账号&#x2F;网段等。</p>
</blockquote>
<hr>
<p>⭐<strong>持续更新 To be continued……</strong></p>
]]></content>
      <categories>
        <category>OSCP</category>
      </categories>
      <tags>
        <tag>OSCP</tag>
        <tag>Penetration Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Function Call和MCP的区别</title>
    <url>/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）"><a href="#Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）" class="headerlink" title="Function Call和MCP的核心区别梳理（由GPT 5.1 生成）"></a>Function Call和MCP的核心区别梳理（由GPT 5.1 生成）</h2><h2 id="🧩核心区别总结"><a href="#🧩核心区别总结" class="headerlink" title="🧩核心区别总结"></a>🧩核心区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Function Call</th>
<th>MCP（Model Context Protocol）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>让模型按照开发者定义的结构化方式返回“调用某函数所需的参数”。</td>
<td>让模型与外部工具、服务、数据源通过统一协议进行双向通信。</td>
</tr>
<tr>
<td><strong>角色</strong></td>
<td>模型只“产生命令”（函数+参数），不执行。执行由外部应用完成。</td>
<td>除生成调用外，还可以<strong>发现、注册、调度、执行</strong>外部资源。</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单、轻量级、多数场景够用。</td>
<td>更底层、更通用，可连接复杂系统。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>调用某个特定函数、处理结构化任务。</td>
<td>接入多个工具、多数据源、插件系统、企业级工作流。</td>
</tr>
</tbody></table>
<hr>
<span id="more"></span>

<h2 id="🧠Function-Call-是什么？"><a href="#🧠Function-Call-是什么？" class="headerlink" title="🧠Function Call 是什么？"></a>🧠Function Call 是什么？</h2><p><strong>Function Call</strong> 是模型输出的一种结构化格式，模型输出它想调用什么函数并且要传什么参数。模型只负责<strong>输出结构化 JSON</strong>，实际执行由相关程序完成。</p>
<p><strong>Function Call</strong>提供的是 API 层的能力，由开发者定义可调用函数列表，模型产出：函数名 + 参数，适用于简单逻辑。</p>
<h3 id="✔-Function-Call-示例"><a href="#✔-Function-Call-示例" class="headerlink" title="✔ Function Call 示例"></a>✔ Function Call 示例</h3><p>假设开发者定义了一个函数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取城市天气&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;city&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用户问：</p>
<blockquote>
<p>“明天北京天气如何？”</p>
</blockquote>
<p>模型可能返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后 <strong>相关程序</strong> 执行 get_weather(“北京”) 并把结果再返回给模型或用户。</p>
<p>📌 <strong>关键点：模型不会执行，只会返回结构体。</strong></p>
<h2 id="🧠MCP（Model-Context-Protocol）是什么？"><a href="#🧠MCP（Model-Context-Protocol）是什么？" class="headerlink" title="🧠MCP（Model Context Protocol）是什么？"></a>🧠MCP（Model Context Protocol）是什么？</h2><p>MCP 是一个<strong>通用协议</strong>，用于管理工具（tools），连接外部数据源（database、文件系统等），让模型能够发现并调用这些资源，同时统一不同工具的接口格式。</p>
<p>可以把 MCP 理解为：</p>
<blockquote>
<p><strong>模型与外部世界的“操作系统抽象层”</strong><br>它让模型能直接访问文件、数据库、网络等工具。</p>
</blockquote>
<p>它的“能力”比 Function Call 强得多，因为：</p>
<p>👉 <strong>Function Call 只能调用开发人员手工写死的函数</strong><br>👉 <strong>MCP 可以动态加载工具包、文件系统服务、环境服务，让模型像操作系统用户一样访问资源</strong></p>
<hr>
<h3 id="✔-MCP-示例"><a href="#✔-MCP-示例" class="headerlink" title="✔ MCP 示例"></a>✔ MCP 示例</h3><p>假设 MCP 提供一个工具 <code>fs.read_file</code>。</p>
<p>用户问：</p>
<blockquote>
<p>“打开 &#x2F;docs&#x2F;intro.md 读给我听”</p>
</blockquote>
<p>模型实际会产生这样的消息（非 Function Call 风格，而是 MCP 消息协议）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.read_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/intro.md&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>服务端会执行 <strong>read_file</strong> 并返回文件内容。</p>
<p>模型可以继续请求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.write_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/notes.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里是我总结的内容...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里体现 MCP 的本质：</p>
<ul>
<li>模型知道有哪些工具可用</li>
<li>模型直接“操控”这些工具</li>
<li>具有类似“文件读写”等复杂能力</li>
<li>不需要开发者提前硬编码所有函数</li>
</ul>
<h2 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>Function Call</th>
<th>MCP</th>
</tr>
</thead>
<tbody><tr>
<td>工具发现</td>
<td>手工定义</td>
<td>自动注册，模型可自动学习工具能力</td>
</tr>
<tr>
<td>调用方式</td>
<td>结构化 JSON</td>
<td>双向协议、消息通信</td>
</tr>
<tr>
<td>扩展性</td>
<td>每加一个功能都要新增函数定义</td>
<td>新增 MCP 服务即可扩展工具能力</td>
</tr>
<tr>
<td>模型能力</td>
<td>被动</td>
<td>主动、可规划调用流程</td>
</tr>
<tr>
<td>场景</td>
<td>简单 API 调用、数据结构化</td>
<td>IDE、数据库集成、文件系统、GitHub 操作、企业自动化</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11 Java环境变量配置</title>
    <url>/2025/12/04/Win11-Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>找到JDK的路径，在系统环境变量中新建变量名和变量值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_202</span><br></pre></td></tr></table></figure>

<p>然后在系统变量path中，新建两条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br><span class="line">%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>验证配置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_202&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;javac -version</span><br><span class="line">javac 1.8.0_202</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda安装</title>
    <url>/2025/12/07/Miniconda%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Miniconda 是 Conda 的精简发行版，只包含最核心的包管理系统与 Python，可以快速搭建独立的 Python 环境。在进行数据分析、机器学习或科研开发时，相比于 Anaconda 更轻量、更灵活。</p>
<h2 id="一、Miniconda-安装"><a href="#一、Miniconda-安装" class="headerlink" title="一、Miniconda 安装"></a>一、Miniconda 安装</h2><p>Windows 命令行安装方式，可以快速且安静地下载最新的 64 位 Windows 安装程序，将其重命名为较短的文件名，执行静默安装，然后删除安装程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o .\miniconda.exe</span><br><span class="line">start /wait &quot;&quot; .\miniconda.exe /S</span><br><span class="line">del .\miniconda.exe</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>Windows Powershell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> <span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe&quot;</span> <span class="literal">-outfile</span> <span class="string">&quot;.\miniconda.exe&quot;</span></span><br><span class="line"><span class="built_in">Start-Process</span> <span class="literal">-FilePath</span> <span class="string">&quot;.\miniconda.exe&quot;</span> <span class="literal">-ArgumentList</span> <span class="string">&quot;/S&quot;</span> <span class="literal">-Wait</span></span><br><span class="line"><span class="built_in">del</span> .\miniconda.exe</span><br></pre></td></tr></table></figure>

<p>Linux 64位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="built_in">rm</span> ~/miniconda3/miniconda.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/miniconda3/bin/activate</span><br><span class="line"></span><br><span class="line">conda init --all</span><br></pre></td></tr></table></figure>

<h2 id="二、快速使用"><a href="#二、快速使用" class="headerlink" title="二、快速使用"></a>二、快速使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n environment python=3.12</span><br><span class="line"></span><br><span class="line">conda activate environment</span><br><span class="line"></span><br><span class="line">conda deactivate environment</span><br></pre></td></tr></table></figure>

<p>参考文献：<a href="https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt">https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO使用记录</title>
    <url>/2025/12/04/HEXO%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Hexo-使用记录"><a href="#Hexo-使用记录" class="headerlink" title="Hexo 使用记录"></a>Hexo 使用记录</h1><p>参考文献： <a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
<p>官方文档：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<h2 id="HEXO-简介"><a href="#HEXO-简介" class="headerlink" title="HEXO 简介"></a>HEXO 简介</h2><p>Hexo 是一个基于 Node.js 的快速、简洁且高效的静态博客框架。它拥有超快的渲染速度、灵活的配置方式，以及丰富的主题与插件生态。借助 Markdown 写作，可以轻松生成优雅的静态网页，并部署到 GitHub Pages、Vercel、Netlify 等任意静态托管平台。无论是想建立个人博客、文档站点，还是打造独特的技术分享空间，Hexo 都能提供流畅而高效的创作体验。</p>
<span id="more"></span>

<h2 id="一、Hexo-安装"><a href="#一、Hexo-安装" class="headerlink" title="一、Hexo 安装"></a>一、Hexo 安装</h2><p>Hexo 是一个快速、简单且功能强大的博客框架，可以使用 Markdown （或其他标记语言）编写文章，Hexo 会在几秒钟内生成带有对应主题的静态文件。</p>
<p>安装 Hexo 需要 Node.js 以及 Git 环境。</p>
<p>Node.js 下载地址 <a href="https://nodejs.org/en/download">Node.js Download</a></p>
<p>Git 下载地址 <a href="https://git-scm.com/install/windows">Git Download</a></p>
<p>所有必需组件安装完毕后，即可使用 npm 安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>初始化 Hexo 站点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexo-site</span><br></pre></td></tr></table></figure>
<p>hexo-site 也可以替换为其他路径名，以 hexo-site 为例，网站根目录被称为 <code>hexo-site</code>。 </p>
<p>初始化完成后，可以到网站根目录下，下载对应主题并进行升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-site</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>运行 npm install 时，对 node_modules 目录下主题所做的任何本地更改都将丢失。如果对主题进行了更改，则应在运行 npm install 之前备份这些更改，然后在安装完成后恢复这些更改。</p>
<p>安装完 Hexo 和 NexT 主题后，可以通过修改配置文件来自定义博客。安装 Hexo 时，配套的配置文件位于网站根目录。博客配置文件名为 _config.yml ；我们称之为 Hexo 配置文件 NexT 主题的配置文件需要您自行创建；请在目录下创建一个 _config.next.yml 文件。 网站根目录我们将其称为 Next 配置文件在以下文本中。</p>
<p>创建空的 _config.next.yml 文件后，可以将主题文件夹中的默认配置选项复制到该文件中，以便进行修改和自定义。根据安装方式，NexT 主题的默认配置文件可能位于 themes&#x2F;next&#x2F;_config.yml 或 node_modules&#x2F;hexo-theme-next&#x2F;_config.yml 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>

<h2 id="二、Hexo-个性化设置"><a href="#二、Hexo-个性化设置" class="headerlink" title="二、Hexo 个性化设置"></a>二、Hexo 个性化设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove unnecessary files after hexo generate.</span></span><br><span class="line">minify: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line">darkmode: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:zyufoye/zyufoye.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、Hexo-新建发布文章"><a href="#三、Hexo-新建发布文章" class="headerlink" title="三、Hexo 新建发布文章"></a>三、Hexo 新建发布文章</h2><p>新建发布文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成并部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp;  hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>同步更新部署到github：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>博客侧边栏添加 menu 菜单，以 tags 和 categories 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>同时在index.md 中设置类别，不然点击跳转后不显示任何内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>: categories</span><br></pre></td></tr></table></figure>

<p>设置文章想要显示的内容时，可以用 more 进行切分， more以上的作为显示内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>以上基本配置和简单使用记录完毕，后续有更多需要再持续更新记录。  </p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SARIF文件架构解读</title>
    <url>/2025/12/10/SARIF%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="SARIF-文件架构架构解读"><a href="#SARIF-文件架构架构解读" class="headerlink" title="SARIF 文件架构架构解读"></a>SARIF 文件架构架构解读</h2><p>SARIF（Static Analysis Results Interchange Format）本质是一个 JSON 日志规范，用于统一表达静态分析（SAST、Lint、CodeQL、依赖扫描等）的扫描结果，方便不同工具之间共享、聚合、展示与追踪。</p>
<p>SARIF 简单文件结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;https://json.schemastore.org/sarif-2.1.0.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runs&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;tool&#x27;<span class="punctuation">,</span> &#x27;invocations&#x27;<span class="punctuation">,</span> &#x27;artifacts&#x27;<span class="punctuation">,</span> &#x27;results&#x27;<span class="punctuation">,</span> &#x27;columnKind&#x27;<span class="punctuation">,</span>&#x27;properties&#x27;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SARIF &#x3D; 多次运行 runs 的集合，每次运行包含：工具信息 + 运行元数据 + 被分析对象（artifacts）+ 分析结果（results）</p>
</blockquote>
<p>对各部分内容介绍如下：</p>
<ol>
<li>tool 工具信息：检查员身份信息和检查手册，记录了用哪个工具进行了扫描，版本号是多少，包含了 driver 驱动程序信息 和 rules 检查规则清单；</li>
<li>invocations 调用信息：检查员的工作日志，记录了这次检查是在什么环境下进行的，以及是否顺利完成，executionSuccessful: true&#x2F;false；</li>
<li>artifacts 被扫描的文件：检查了哪些地点，列出了所有被 CodeQL 扫描过的源文件（Source Code），包含文件的路径（location），有时也包含文件的具体内容或哈希值，方便后续定位；</li>
<li><strong>results 结果</strong> ：这是问题清单，这是整份报告里最重要的部分，列出了扫描出来的所有 Bug和漏洞信息，关键单：ruleId 记录违反了哪条规则（对应 tool 里的规则），message 记录问题的具体描述，locations 记录了问题在哪个文件的第几行、第几列；</li>
<li>columnKind 列的计算方式：用于告诉 IDE（如 VS Code）如何正确高亮代码；</li>
<li>properties 附加属性：记录了杂项信息，存放标准字段里放不下的、或者工具特有的自定义数据，可能会包含构建时的标签（Build Tags）、项目的元数据（Project Metadata）和一些给特定显示面板用的统计数据；</li>
</ol>
<p>通俗的讲，就是这一次扫描 (run)，是由名为 CodeQL 的 (tool) 进行的。它在一个特定的时间以特定的参数运行 (invocations)，按照特定的刻度标准 (columnKind)，扫描了这一堆文件 (artifacts)，最后发现了这些漏洞 (results)，并在最后贴了一些标签 (properties)。</p>
<span id="more"></span>

<h2 id="关键信息提取"><a href="#关键信息提取" class="headerlink" title="关键信息提取"></a>关键信息提取</h2><p>要在 CodeQL 生成的 SARIF 报告中提取<strong>漏洞点（Sink）</strong>、<strong>漏洞位置</strong>、<strong>数据流（Source 到 Sink）以及控制流</strong>信息，需要研究 <code>runs</code> -&gt; <code>results</code> 数组中的对象。</p>
<p>SARIF 将这些复杂的逻辑封装在了一个层级分明的结构中。以下是提取这些关键信息所对应的具体字段和解析逻辑：</p>
<hr>
<h3 id="提取核心模块：results-数组"><a href="#提取核心模块：results-数组" class="headerlink" title="提取核心模块：results 数组"></a>提取核心模块：<code>results</code> 数组</h3><p>所有的漏洞信息都在 <code>runs[0].results</code> 列表里，需要遍历这个列表，列表中的每一个对象代表一个具体的漏洞实例。</p>
<h3 id="详细提取指南"><a href="#详细提取指南" class="headerlink" title="详细提取指南"></a>详细提取指南</h3><p>需要关注 <code>results</code> 对象下的以下字段：</p>
<h4 id="A-漏洞的基本信息"><a href="#A-漏洞的基本信息" class="headerlink" title="A. 漏洞的基本信息"></a>A. 漏洞的基本信息</h4><ul>
<li><strong>漏洞名称&#x2F;类型</strong>：<code>ruleId</code><ul>
<li>例如：<code>java/sql-injection</code></li>
</ul>
</li>
<li><strong>漏洞简要描述</strong>：<code>message.text</code><ul>
<li>例如：”This query depends on a user-provided value.”</li>
</ul>
</li>
</ul>
<h4 id="B-漏洞位置-爆发点-Sink"><a href="#B-漏洞位置-爆发点-Sink" class="headerlink" title="B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink"></a>B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink</h4><p>这是 CodeQL 认为漏洞最终发生的地方（例如执行 SQL 查询的那一行）。</p>
<ul>
<li><strong>提取字段</strong>：<code>locations</code> 数组</li>
<li><strong>关键逻辑</strong>：通常取 <code>locations[0]</code>（数组的第一个元素）作为主要位置。</li>
<li><strong>具体内容</strong>：<ul>
<li><strong>文件路径</strong>：<code>locations[0].physicalLocation.artifactLocation.uri</code></li>
<li><strong>起始行号</strong>：<code>locations[0].physicalLocation.region.startLine</code></li>
<li><strong>代码片段</strong>（如果有）：<code>locations[0].physicalLocation.region.snippet.text</code></li>
</ul>
</li>
</ul>
<h4 id="C-数据流与控制流"><a href="#C-数据流与控制流" class="headerlink" title="C. 数据流与控制流"></a>C. 数据流与控制流</h4><p>这是最复杂也是最有价值的部分，描述了污点数据（Taint Data）是如何从<strong>输入源（Source）</strong>一步步流向<strong>爆发点（Sink）</strong>的。</p>
<p>CodeQL 将数据流和控制流统一放在 <code>codeFlows</code> 字段中。</p>
<ul>
<li><strong>提取字段</strong>：<code>codeFlows</code> 数组</li>
<li><strong>结构逻辑</strong>：<ol>
<li><code>codeFlows</code> 下通常包含一个或多个 <code>threadFlows</code>（CodeQL 通常只给出一个最具代表性的路径）。</li>
<li><code>threadFlows</code> 下是一个 <code>locations</code> 列表，这是一个<strong>有序数组</strong>，代表了代码执行的步骤。</li>
</ol>
</li>
</ul>
<p><strong>如何解析这个路径链条：</strong></p>
<ul>
<li><strong>Source（污点源头&#x2F;用户输入）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>第一个元素</strong>。</li>
<li>提取：<code>...locations[0].location.physicalLocation</code> (文件和行号)</li>
<li>含义：例如 <code>request.getParameter(&quot;id&quot;)</code>，这是数据进入系统的位置。</li>
</ul>
</li>
<li><strong>Flow Path（传播路径&#x2F;控制流）</strong>：<ul>
<li>是 <code>threadFlows[0].locations</code> 数组的<strong>中间元素</strong>。</li>
<li>这些步骤展示了数据经过了哪些函数调用、赋值操作或判断逻辑。</li>
<li><strong>关键提取</strong>：<code>location.message.text</code> —— 这里通常会说明“数据被传递给参数 x”或“数据通过函数返回值传播”。</li>
</ul>
</li>
<li><strong>Sink（爆发点&#x2F;最终位置）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>最后一个元素</strong>。</li>
<li>这应该与上面提到的 <strong>B. 漏洞位置</strong> 重合。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：需要提取的-JSON-路径映射表"><a href="#总结：需要提取的-JSON-路径映射表" class="headerlink" title="总结：需要提取的 JSON 路径映射表"></a>总结：需要提取的 JSON 路径映射表</h3><p>为了方便编写脚本（如 Python）提取，这是一个速查表：</p>
<table>
<thead>
<tr>
<th align="left">信息类型</th>
<th align="left">SARIF JSON 路径 (假设当前在 results[i] 对象下)</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>漏洞类型</strong></td>
<td align="left"><code>ruleId</code></td>
<td align="left">漏洞的 ID，如 SQL 注入</td>
</tr>
<tr>
<td align="left"><strong>漏洞描述</strong></td>
<td align="left"><code>message.text</code></td>
<td align="left">人类可读的解释</td>
</tr>
<tr>
<td align="left"><strong>漏洞文件</strong></td>
<td align="left"><code>locations[0].physicalLocation.artifactLocation.uri</code></td>
<td align="left">发生漏洞的文件名</td>
</tr>
<tr>
<td align="left"><strong>漏洞行号</strong></td>
<td align="left"><code>locations[0].physicalLocation.region.startLine</code></td>
<td align="left">发生漏洞的行号</td>
</tr>
<tr>
<td align="left"><strong>数据流路径</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations</code></td>
<td align="left">这是一个列表，包含完整路径</td>
</tr>
<tr>
<td align="left"><strong>数据源 (Source)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[0]</code></td>
<td align="left">路径的第一步</td>
</tr>
<tr>
<td align="left"><strong>传播过程</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[1:-1]</code></td>
<td align="left">路径的中间步骤</td>
</tr>
<tr>
<td align="left"><strong>爆发点 (Sink)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[-1]</code></td>
<td align="left">路径的最后一步</td>
</tr>
</tbody></table>
<h3 id="4-举例说明"><a href="#4-举例说明" class="headerlink" title="4. 举例说明"></a>4. 举例说明</h3><p>假设这是一个 SQL 注入的 <code>result</code> 片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ruleId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java/sql-injection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Query depends on user input.&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// ---&gt; 这里是 B: 漏洞最终爆发的位置 (Sink)</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;artifactLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;codeFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// ---&gt; 这里是 C: 完整的数据流/控制流路径</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;threadFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="comment">// 步骤 1: Source (数据源)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Controller.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">15</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User input source...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 2: 中间传播</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Service.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data passed to function...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 3: Sink (通常与 locations[0] 一致)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data used in SQL query...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><strong>判空处理</strong>：不是所有的 <code>results</code> 都有 <code>codeFlows</code>。简单的代码质量检查（比如“变量未使用”）通常只有 <code>locations</code>，没有数据流路径。只有安全类漏洞（如注入、XSS）通常会有 <code>codeFlows</code>。</li>
<li><strong>路径简繁</strong>：CodeQL 生成的 <code>codeFlows</code> 有时非常详细，如果只关注关键跳板，关注 <code>location.message</code> 比较有帮助。</li>
<li><strong>关联位置</strong>：有时还会看到 <code>relatedLocations</code> 字段，这通常用于辅助说明（例如：指出变量定义的位置），如果不需要极高精度，可以暂时忽略。</li>
</ol>
]]></content>
      <categories>
        <category>CodeQL</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
        <tag>SARIF</tag>
      </tags>
  </entry>
  <entry>
    <title>解决VScode和Trae等无法加载conda虚拟环境的问题</title>
    <url>/2025/12/02/%E8%A7%A3%E5%86%B3VScode%E5%92%8CTrae%E7%AD%89%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>使用 conda 或 miniconda 配置虚拟环境时，当启动虚拟环境时，遇到如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是，运行 <code>conda init</code> 后还是不起作用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ conda init</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda.exe</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda-env.exe</span><br><span class="line">......</span><br><span class="line">no change     C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</span><br><span class="line">modified      HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun</span><br></pre></td></tr></table></figure>

<h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>我是 win11 操作系统，需要以 <strong>管理员身份</strong> 打开powershell窗口，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>重新加载即可生效。</p>
<span id="more"></span>

<h1 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h1><p>简单说，这个问题本质上是：<strong>Conda 的初始化脚本被 PowerShell 的安全策略拦住了，所以每次新开终端时，Conda 都没真正“接管”当前 Shell。</strong></p>
<h2 id="1-conda-init-实际在做什么？"><a href="#1-conda-init-实际在做什么？" class="headerlink" title="1. conda init 实际在做什么？"></a>1. <code>conda init</code> 实际在做什么？</h2><p>在 Windows + PowerShell 下，Conda 并不是简单地靠 <code>conda.exe</code> 来完成环境激活的，而是通过一套 <strong>Shell Hook 脚本</strong> 来接管当前会话：</p>
<p><code>conda init</code> 会在 <code>C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</code> 里写入一段初始化代码，这些脚本会去调用 <code>miniconda3\shell\condabin\conda-hook.ps1</code> 等文件，往当前 PowerShell 里注入 <code>conda</code> &#x2F; <code>conda activate</code> 等函数，并设置好 PATH、环境变量等。</p>
<p><strong>只有这些 Hook 每次打开 PowerShell 时能顺利执行，当前终端才真正“支持” <code>conda activate</code>。</strong></p>
<p>所以当你看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实意思是：<strong>当前这个 PowerShell 会话里没有被注入 Conda 的 Hook 脚本</strong>，所以它感觉自己还没 init。</p>
<h2 id="2-PowerShell-执行策略的限制"><a href="#2-PowerShell-执行策略的限制" class="headerlink" title="2. PowerShell 执行策略的限制"></a>2. PowerShell 执行策略的限制</h2><p>PowerShell 为了安全，有一个 <strong>执行策略（Execution Policy）</strong>，决定哪些脚本可以被执行：</p>
<p>常见几种：</p>
<ul>
<li><code>Restricted</code>：完全禁止执行脚本；</li>
<li><code>AllSigned</code>：所有脚本都必须是签名的；</li>
<li><code>RemoteSigned</code>：本地脚本可以执行，从互联网下载的脚本必须签名。</li>
</ul>
<p>在我机器上的情况是：</p>
<ul>
<li><p>Conda 的这些 hook &#x2F; profile 脚本属于 <strong>本地脚本</strong>；</p>
</li>
<li><p>但默认配置策略过于严格，导致：</p>
<ul>
<li>打开 PowerShell 时，<code>profile.ps1</code> &#x2F; <code>conda-hook.ps1</code> 没有被执行；</li>
<li>于是 <code>conda</code> 函数、自动激活逻辑统统都没加载进当前会话；</li>
<li>终端自然就会提示你先 <code>conda init</code>。</li>
</ul>
</li>
</ul>
<p>也就是说：<code>conda init</code> 写入的配置已经在那儿了，但每次启动 PowerShell 时都被策略挡在门外。 当以管理员身份执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>等于允许系统执行本地脚本，只对来源不明的远程脚本做限制。</p>
<p>这样一来，再次打开 PowerShell &#x2F; VSCode 内置终端时，<code>profile.ps1</code> 会被正常加载，里面调用的 <code>conda-hook.ps1</code> 等本地脚本可以顺利执行， VSCode &#x2F; Trae 里就可以正常加载和激活 Conda 虚拟环境，不再报 Run ‘conda init’ before ‘conda activate’错误。</p>
]]></content>
      <categories>
        <category>Trouble shooting</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Trouble shooting</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows结束进程</title>
    <url>/2025/12/09/Windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>今天在跑 Springboot 的 Java 项目时，遇到了端口占用问题，记一下 Windows 的根据相关端口杀进程命令。</p>
<p>首先查找占用 8080 的 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></table></figure>

<p>然后根据 PID 强制结束进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /PID 3836</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>实验</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;netstat -ano | findstr :8080</span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       3836</span><br><span class="line">  TCP    [::]:8080              [::]:0                 LISTENING       3836</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;taskkill /F /PID 3836</span><br><span class="line">成功: 已终止 PID 为 3836 的进程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>kali安装ssh</title>
    <url>/2025/12/10/kali%E5%AE%89%E8%A3%85ssh/</url>
    <content><![CDATA[<h1 id="kali-linux-安装ssh服务"><a href="#kali-linux-安装ssh服务" class="headerlink" title="kali linux 安装ssh服务"></a>kali linux 安装ssh服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl start ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh <span class="comment">#设置开机自启</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl status ssh <span class="comment">#查看运行状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Kali Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>uv使用</title>
    <url>/2025/12/10/uv%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>uv是一个用 Rust 编写的极快的 Python 包和项目管理工具。</p>
<p>官方文档参考：<a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a></p>
<h2 id="uv安装"><a href="#uv安装" class="headerlink" title="uv安装"></a>uv安装</h2><p>Linux &amp; MacOS 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Windows powershell 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell -ExecutionPolicy ByPass -c <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>以Windows为例，下载uv并配置环境变量，在powershell中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\<span class="number">77319</span>&gt; powershell <span class="literal">-ExecutionPolicy</span> ByPass <span class="literal">-c</span> <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br><span class="line">Downloading uv <span class="number">0.9</span>.<span class="number">17</span> (x86_64<span class="literal">-pc-windows-msvc</span>)</span><br><span class="line">Installing to C:\Users\<span class="number">77319</span>\.local\bin</span><br><span class="line">  uv.exe</span><br><span class="line">  uvx.exe</span><br><span class="line">  uvw.exe</span><br><span class="line">everything<span class="string">&#x27;s installed!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To add C:\Users\77319\.local\bin to your PATH, either restart your shell or run:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    set Path=C:\Users\77319\.local\bin;%Path%   (cmd)</span></span><br><span class="line"><span class="string">    $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;   (powershell)</span></span><br><span class="line"><span class="string">(base) PS C:\Users\77319&gt; $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入uv -h</p>
<p><img src="/../uploads/uv.png"></p>
<p>即表示安全成功。</p>
<h2 id="uv使用"><a href="#uv使用" class="headerlink" title="uv使用"></a>uv使用</h2><p>以官方实践为例，展示uv如何初始化一个 Python 项目、添加依赖、运行工具、生成锁文件并同步环境。  </p>
<p><code>uv init example</code> — 创建一个新的 Python 项目模板  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~$ uv init myproject_test</span><br><span class="line">Initialized project `myproject-test` at `/home/zyu/myproject_test`</span><br><span class="line">(base) zyu@zyu-virtual-machine:~$ <span class="built_in">cd</span> myproject_test/</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ tree .</span><br><span class="line">.</span><br><span class="line">├── main.py</span><br><span class="line">├── pyproject.toml</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv add ruff</code> — 安装依赖并更新 pyproject  </p>
<p>自动创建项目虚拟环境，安装依赖包ruff，把依赖写入pyproject.toml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv add ruff</span><br><span class="line">Using CPython 3.13.9 interpreter at: /home/zyu/miniconda3/bin/python3</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 864ms</span><br><span class="line">Prepared 1 package <span class="keyword">in</span> 1.30s</span><br><span class="line">Installed 1 package <span class="keyword">in</span> 1ms</span><br><span class="line"> + ruff==0.14.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv run ruff check</code> — 运行 ruff 检查代码  </p>
<p> 使用项目虚拟环境里的 ruff 执行代码风格检查 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv run ruff check</span><br><span class="line">All checks passed!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv lock</code> — 生成锁文件 : 解析所有依赖版本  , 生成 <code>uv.lock</code>（类似 Pipfile.lock &#x2F; poetry.lock），保证这个项目未来依赖安装一致、可复现。  </p>
<p><code>uv sync</code> — 按锁文件同步虚拟环境 ： 根据 <code>uv.lock</code> 安装或更新依赖  ， 确保 <code>.venv/</code> 完全匹配锁文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv lock</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.84ms</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv <span class="built_in">sync</span></span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.70ms</span><br><span class="line">Audited 1 package <span class="keyword">in</span> 0.09ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uvx pycowsay &#39;hello world!&#39; </code> uvx 等价于 <code>uv tool run</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uvx pycowsay <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line">Installed 1 package <span class="keyword">in</span> 5ms</span><br><span class="line">/home/zyu/.cache/uv/archive-v0/nYZiOnUm3DMddg7I9DLwr/lib/python3.13/site-packages/pycowsay/main.py:27: SyntaxWarning: invalid escape sequence <span class="string">&#x27;\ &#x27;</span></span><br><span class="line">  \   ^__^</span><br><span class="line"></span><br><span class="line">  ------------</span><br><span class="line">&lt; hello world! &gt;</span><br><span class="line">  ------------</span><br><span class="line">   \   ^__^</span><br><span class="line">    \  (oo)\_______</span><br><span class="line">       (__)\       )\/\</span><br><span class="line">           ||----w |</span><br><span class="line">           ||     ||</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是官方提供的示例Demo。</p>
<p>在实际项目中使用（以<a href="https://github.com/JordyZomer/codeql-mcp#">https://github.com/JordyZomer/codeql-mcp#</a>为例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">error: No virtual environment found; run `uv venv` to create an environment, or pass `--system` to install into a non-virtual environment</span><br></pre></td></tr></table></figure>

<p> 使用 <code>uv pip</code> 安装依赖，但当前目录没有虚拟环境，所以 uv 不知道该把包装到哪里。  uv 的原则是如果不指定装到哪里，它默认要找一个虚拟环境（.venv），如果找不到就报错。所以需要先创建虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv venv</span><br><span class="line">Using CPython 3.11.7 interpreter at: C:\Users\77319\anaconda3\python.exe</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Activate with: .venv\Scripts\activate</span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">Resolved 60 packages <span class="keyword">in</span> 1.61s</span><br><span class="line">Prepared 60 packages <span class="keyword">in</span> 3.56s</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/60] Installing wheels...                                                warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.                                                                                            </span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.                                                                                    </span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.                                                                             </span><br><span class="line">Installed 60 packages <span class="keyword">in</span> 4.17s</span><br><span class="line"> + annotated-types==0.7.0                                                                       </span><br><span class="line"> + anyio==4.12.0                                                                                </span><br><span class="line"> + attrs==25.4.0                                                                                </span><br><span class="line"> + authlib==1.6.5                                                                               </span><br><span class="line"> + beartype==0.22.8                                                                             </span><br><span class="line"> + cachetools==6.2.2</span><br><span class="line"> + certifi==2025.11.12</span><br><span class="line"> + cffi==2.0.0</span><br><span class="line"> + charset-normalizer==3.4.4</span><br><span class="line"> + click==8.3.1</span><br><span class="line"> + colorama==0.4.6</span><br><span class="line"> + cryptography==46.0.3</span><br><span class="line"> + cyclopts==4.3.0</span><br><span class="line"> + diskcache==5.6.3</span><br><span class="line"> + dnspython==2.8.0</span><br><span class="line"> + docstring-parser==0.17.0</span><br><span class="line"> + docutils==0.22.3</span><br><span class="line"> + email-validator==2.3.0</span><br><span class="line"> + exceptiongroup==1.3.1</span><br><span class="line"> + fastmcp==2.13.3</span><br><span class="line"> + h11==0.16.0</span><br><span class="line"> + httpcore==1.0.9</span><br><span class="line"> + httpx==0.28.1</span><br><span class="line"> + httpx-sse==0.4.3</span><br><span class="line"> + idna==3.11</span><br><span class="line"> + jsonschema==4.25.1</span><br><span class="line"> + jsonschema-path==0.3.4</span><br><span class="line"> + jsonschema-specifications==2025.9.1</span><br><span class="line"> + markdown-it-py==4.0.0</span><br><span class="line"> + mcp==1.22.0</span><br><span class="line"> + mdurl==0.1.2</span><br><span class="line"> + openapi-pydantic==0.5.1</span><br><span class="line"> + pathable==0.4.4</span><br><span class="line"> + pathvalidate==3.3.1</span><br><span class="line"> + platformdirs==4.5.1</span><br><span class="line"> + py-key-value-aio==0.3.0</span><br><span class="line"> + py-key-value-shared==0.3.0</span><br><span class="line"> + pycparser==2.23</span><br><span class="line"> + pydantic==2.12.5</span><br><span class="line"> + pydantic-core==2.41.5</span><br><span class="line"> + pydantic-settings==2.12.0</span><br><span class="line"> + pygments==2.19.2</span><br><span class="line"> + pyjwt==2.10.1</span><br><span class="line"> + pyperclip==1.11.0</span><br><span class="line"> + python-dotenv==1.2.1</span><br><span class="line"> + python-multipart==0.0.20</span><br><span class="line"> + pywin32==311</span><br><span class="line"> + pyyaml==6.0.3</span><br><span class="line"> + referencing==0.36.2</span><br><span class="line"> + requests==2.32.5</span><br><span class="line"> + rich==14.2.0</span><br><span class="line"> + rich-rst==1.3.2</span><br><span class="line"> + rpds-py==0.30.0</span><br><span class="line"> + sse-starlette==3.0.3</span><br><span class="line"> + starlette==0.50.0</span><br><span class="line"> + typing-extensions==4.15.0</span><br><span class="line"> + typing-inspection==0.4.2</span><br><span class="line"> + urllib3==2.6.1</span><br><span class="line"> + uvicorn==0.38.0</span><br><span class="line"> + websockets==15.0.1</span><br></pre></td></tr></table></figure>

<p>关于报错信息可以忽略，大致意思是： uv 想用硬链接（hardlink）加速依赖安装，但我们的缓存目录和安装目录不在同一个文件系统上 → 无法硬链接 → 只能退回到“完整复制”文件，性能稍慢一点。  应该缓存目录在C盘，但是安装目录在D盘。</p>
<p>运行mcp服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">Error: typer is required. Install with <span class="string">&#x27;pip install mcp[cli]&#x27;</span></span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install mcp[cli]</span><br><span class="line">Resolved 37 packages <span class="keyword">in</span> 710ms</span><br><span class="line">Prepared 2 packages <span class="keyword">in</span> 138ms</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/2] Installing wheels...                                                 warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.</span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.</span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.</span><br><span class="line">Installed 2 packages <span class="keyword">in</span> 56ms</span><br><span class="line"> + shellingham==1.5.4</span><br><span class="line"> + typer==0.20.0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>uv</tag>
      </tags>
  </entry>
</search>
