<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeQL入门</title>
    <url>/2025/12/07/CodeQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="CodeQL-入门"><a href="#CodeQL-入门" class="headerlink" title="CodeQL 入门"></a>CodeQL 入门</h1><p>在网络安全和代码审计的领域，静态应用程序安全测试（Static application security testing，SAST）工具层出不穷。但在 2019 年 GitHub 收购 Semmle 之后，CodeQL 迅速成为了业界顶流。</p>
<p>传统的扫描工具往往像是一个黑盒，你输入代码，它吐出报告。但 CodeQL 不同，它的核心理念非常有意思： <code>Code as Data</code> 代码即数据，CodeQL 把源代码转化成一个关系型数据库，而漏洞挖掘的过程，就变成了一次次编写 SQL（其实是 QL）查询语句的过程。</p>
<p>CodeQL 工具包含两大部分组成：</p>
<ul>
<li>核心引擎(闭源)：用于解析源代码并存储于数据库，以及执行 QL 语句从数据库中进行查询；</li>
<li>SDK代码库(开源)：包含各编程语言对应的 QL 代码库(属性&#x2F;谓词&#x2F;等)，以便快速编写查询语句。</li>
</ul>
<p>这给了安全研究员和开发者极大的自由度——不再受限于工具内置的规则，可以自己定义“什么样的代码长相存在漏洞”。这篇 Blog 记录了我第一次使用 CodeQL 进行静态代码分析的过程。</p>
<span id="more"></span>

<h2 id="一、CodeQL-核心工作流"><a href="#一、CodeQL-核心工作流" class="headerlink" title="一、CodeQL 核心工作流"></a>一、CodeQL 核心工作流</h2><p>使用 CodeQL 主要分为三个步骤：</p>
<ol>
<li><p><strong>创建数据库（Create Database）</strong>： 在编译&#x2F;构建代码的过程中，CodeQL 会“旁路监听”，捕捉所有的编译命令、文件结构、函数调用关系，生成一个快照数据库；</p>
</li>
<li><p><strong>编写&#x2F;运行查询（Analyze）</strong>： 使用一种类似 SQL 的面向对象查询语言（QL），在数据库中查找符合特征的代码片段；</p>
</li>
<li><p><strong>生成结果（Results）</strong>： 输出分析报告（通常是 SARIF 格式），定位到具体的代码行号。</p>
</li>
</ol>
<h2 id="二、CodeQL-安装"><a href="#二、CodeQL-安装" class="headerlink" title="二、CodeQL 安装"></a>二、CodeQL 安装</h2><p>运行 CodeQL 需要安装 CodeQL CLI 工具，分开下载的话需要分别下载 CodeQL binary 和 SDK，需要放在相同目录下且版本保持一致，也可以直接下载捆绑包，以 Ubuntu 环境为例，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.16.1/codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvzf codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/aono/codeqlsrc/codeql</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>检测是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql --version</span><br></pre></td></tr></table></figure>

<p>可以使用  <code>codeQL resolve languages</code> 可以查看支持的编程语言。</p>
<h2 id="三、CodeQL-简单使用"><a href="#三、CodeQL-简单使用" class="headerlink" title="三、CodeQL 简单使用"></a>三、CodeQL 简单使用</h2><p>指定项目创建数据库，以 Java 目标（<a href="https://github.com/l4yn3/micro_service_seclab%EF%BC%89%E4%B8%BA%E4%BE%8B%EF%BC%8C%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87">https://github.com/l4yn3/micro_service_seclab）为例，项目通过</a> mvn 构建，首先安装 mvn：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install maven -y</span><br></pre></td></tr></table></figure>

<p>创建数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database create java_db --language=java --source-root=./test/micro_service_seclab/</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_1.png"></p>
<p>使用默认规则进行查询，生成 SARIF 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database analyze java_db/ --format=sarif-latest --output=java_result.sarif</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_2.png"></p>
]]></content>
      <categories>
        <category>SAST</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL-MCP架构解读</title>
    <url>/2025/12/15/CodeQL-MCP%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>本片内容以 <a href="https://github.com/JordyZomer/codeql-mcp">https://github.com/JordyZomer/codeql-mcp</a> 为基础，进行 CodeQL MCP 的开发学习。</p>
<h2 id="CodeQL-MCP-整体架构分析"><a href="#CodeQL-MCP-整体架构分析" class="headerlink" title="CodeQL-MCP 整体架构分析"></a>CodeQL-MCP 整体架构分析</h2><p>项目中包含了两个核心文件 <code>codeqlclient.py</code> 和  <code>server.py</code> ：</p>
<p><strong><code>codeqlclient.py</code></strong> 是一个底层通信客户端，负责与 CodeQL 查询服务器建立并管理 JSON-RPC 连接。它封装了进程启动、请求发送、响应解析、异步任务跟踪等复杂逻辑，提供了数据库注册、查询执行、结果解码等核心操作的原始接口。该文件不依赖任何高层框架，专注于可靠、高效地与 CodeQL 引擎交互，可作为独立库在不同上下文中复用。</p>
<p><strong><code>server.py</code></strong> 是一个基于 Model Context Protocol（MCP）的服务层实现，利用 FastMCP 框架将 <code>codeqlclient.py</code> 提供的底层能力包装为用户友好的异步 API 工具。它定义了清晰的 HTTP 可调用接口，处理参数验证、错误反馈和结果格式化，使外部系统能通过标准 MCP 协议便捷地使用 CodeQL 功能，而无需关心底层通信细节。</p>
<p>在 <code>codeqlclient.py</code> 中包含了一个核心类结构 CodeQLQueryServer 主要模块如下：</p>
<ol>
<li>服务器进程管理</li>
</ol>
<ul>
<li>启动&#x2F;停止 ：通过 start() 和 stop() 方法管理 CodeQL 子进程</li>
<li>进程通信 ：使用标准输入&#x2F;输出进行 JSON-RPC 通信</li>
<li>线程管理 ：<ul>
<li>_read_loop() ：主线程，读取服务器响应；_stderr_loop() ：处理标准错误输出；异步处理：支持并发请求</li>
</ul>
</li>
</ul>
<ol start="2">
<li>通信协议层</li>
</ol>
<ul>
<li>JSON-RPC 2.0：定义消息格式，请求&#x2F;响应结构，支持异步调用</li>
</ul>
<ol start="3">
<li>功能模块</li>
</ol>
<ul>
<li><p>数据库管理</p>
<ul>
<li>register_databases() ：注册数据库</li>
<li>deregister_databases() ：注销数据库</li>
</ul>
</li>
<li><p>查询执行</p>
<ul>
<li>evaluate_queries() ：执行完整查询</li>
<li>quick_evaluate() ：快速评估（针对特定代码位置）</li>
<li>evaluate_and_wait() ：同步执行查询</li>
<li>quick_evaluate_and_wait() ：同步快速评估</li>
</ul>
</li>
<li><p>结果处理</p>
<ul>
<li>decode_bqrs() ：解码 BQRS 结果文件</li>
</ul>
</li>
<li><p>代码分析辅助</p>
<ul>
<li>find_class_identifier_position() ：查找类标识符位置</li>
<li>find_predicate_identifier_position() ：查找谓词标识符位置</li>
</ul>
</li>
<li><p>进度回调机制（支持实时进度更新）</p>
<ul>
<li>wait_for_progress_done() ：等待进度完成</li>
<li>wait_for_completion_callback() ：等待异步操作完成</li>
<li>wait_for_progress_done() 创建进度跟踪器</li>
<li>wait_for_completion_callback() 创建完成处理器</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据流：用户请求 -&gt; send_request()-&gt;JSON-RPC 消息-&gt;CodeQL 服务器-&gt;CodeQL 引擎-&gt;服务器响应-&gt;_read_loop()-&gt;_handle_message()-&gt;回调函数</p>
</blockquote>
<span id="more"></span>

<h2 id="关键模块解读"><a href="#关键模块解读" class="headerlink" title="关键模块解读"></a>关键模块解读</h2><h3 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h3><p>启动 CodeQL 查询服务器进程，并建立通信通道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.proc = subprocess.Popen(</span><br><span class="line">    [</span><br><span class="line">        <span class="variable language_">self</span>.codeql_path,        <span class="comment"># CodeQL 可执行文件路径</span></span><br><span class="line">        <span class="string">&quot;execute&quot;</span>,               <span class="comment"># 执行命令</span></span><br><span class="line">        <span class="string">&quot;query-server2&quot;</span>,         <span class="comment"># 启动查询服务器版本2</span></span><br><span class="line">        <span class="string">&quot;--debug&quot;</span>,               <span class="comment"># 启用调试模式</span></span><br><span class="line">        <span class="string">&quot;--tuple-counting&quot;</span>,      <span class="comment"># 启用元组计数（性能监控）</span></span><br><span class="line">        <span class="string">&quot;--threads=0&quot;</span>,           <span class="comment"># 使用所有可用线程（0=自动）</span></span><br><span class="line">        <span class="string">&quot;--evaluator-log-level&quot;</span>, <span class="comment"># 设置评估器日志级别</span></span><br><span class="line">        <span class="string">&quot;5&quot;</span>,                     <span class="comment"># 日志级别5（详细）</span></span><br><span class="line">        <span class="string">&quot;-v&quot;</span>,                    <span class="comment"># 详细输出</span></span><br><span class="line">        <span class="string">&quot;--log-to-stderr&quot;</span>,       <span class="comment"># 日志输出到标准错误</span></span><br><span class="line">    ],</span><br><span class="line">    stdin=subprocess.PIPE,      <span class="comment"># 标准输入管道（用于发送请求）</span></span><br><span class="line">    stdout=subprocess.PIPE,     <span class="comment"># 标准输出管道（用于接收响应）</span></span><br><span class="line">    stderr=subprocess.PIPE,     <span class="comment"># 标准错误管道（用于日志/错误）</span></span><br><span class="line">    text=<span class="literal">True</span>,                  <span class="comment"># 以文本模式处理输入输出</span></span><br><span class="line">    bufsize=<span class="number">1</span>,                  <span class="comment"># 行缓冲模式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>启动读取线程：创建一个守护线程来持续读取服务器的标准输出，处理 JSON-RPC 响应。同时还有读取标准错误输出，防止缓冲区阻塞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.reader_thread = threading.Thread(</span><br><span class="line">    target=<span class="variable language_">self</span>._read_loop,  <span class="comment"># 目标函数：读取循环</span></span><br><span class="line">    daemon=<span class="literal">True</span>              <span class="comment"># 守护线程（主程序退出时自动结束）</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.reader_thread.start()   <span class="comment"># 启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.stderr_thread = threading.Thread(</span><br><span class="line">    target=<span class="variable language_">self</span>._stderr_loop,  <span class="comment"># 目标函数：标准错误循环</span></span><br><span class="line">    daemon=<span class="literal">True</span>                <span class="comment"># 守护线程</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.stderr_thread.start()     <span class="comment"># 启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="stderr-loop"><a href="#stderr-loop" class="headerlink" title="_stderr_loop()"></a>_stderr_loop()</h3><p>标准错误处理循环：持续读取 CodeQL服务器的标准错误输出，防止stderr管道堵塞，在 start() 中作为守护线程启动。</p>
<h3 id="read-loop"><a href="#read-loop" class="headerlink" title="_read_loop()"></a>_read_loop()</h3><p>主读取循环：读取并解析服务器响应，处理 JSON-RPC over HTTP 风格的消息格式。</p>
<h3 id="handle-message"><a href="#handle-message" class="headerlink" title="_handle_message()"></a>_handle_message()</h3><p>消息分发器：是核心的消息处理函数，处理三种类型的消息：</p>
<ul>
<li>进度更新消息 ( ql&#x2F;progressUpdated )：处理查询执行进度更新</li>
<li>评估进度消息 ( evaluation&#x2F;progress )：处理评估操作的进度信息</li>
<li>请求响应消息：处理异步请求的响应</li>
</ul>
<h3 id="send"><a href="#send" class="headerlink" title="_send()"></a>_send()</h3><p>发送请求：发送JSON-RPC 请求到服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, payload</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.proc <span class="keyword">or</span> <span class="keyword">not</span> <span class="variable language_">self</span>.proc.stdin:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] Tried to send but process not running.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        data = json.dumps(payload)</span><br><span class="line">        content = <span class="string">f&quot;Content-Length: <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>\r\n\r\n<span class="subst">&#123;data&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n[→] Sending request:\n<span class="subst">&#123;json.dumps(payload, indent=<span class="number">2</span>)&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.proc.stdin.write(content)</span><br><span class="line">        <span class="variable language_">self</span>.proc.stdin.flush()</span><br></pre></td></tr></table></figure>

<h3 id="send-request"><a href="#send-request" class="headerlink" title="send_request()"></a>send_request()</h3><p>高级发送接口：发送异步请求并管理回调，为每个请求生成唯一ID，关联请求 ID 与回调函数，支持进度回调注册和状态跟踪。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h3><p>停止服务器</p>
<h3 id="find-class-identifier-position"><a href="#find-class-identifier-position" class="headerlink" title="find_class_identifier_position()"></a>find_class_identifier_position()</h3><p>在 QL 文件中查找类名标识符的位置，返回基于 1 的行列坐标。CodeQL 快速评估功能的关键组件，通过定位代码中的特定标识符，实现对部分代码的针对性分析。</p>
<h3 id="find-predicate-identifier-position"><a href="#find-predicate-identifier-position" class="headerlink" title="find_predicate_identifier_position()"></a>find_predicate_identifier_position()</h3><p>在 QL 文件中查找谓词（predicate）名称的位置，返回基于 1 的行列坐标。</p>
<p>类名查找和谓词查找可以用于支持CodeQL的快速评估功能，就是只执行查询的一部分，而不是执行全量查询，可以进行快速迭代和调试。</p>
<h3 id="register-databases-deregister-databases"><a href="#register-databases-deregister-databases" class="headerlink" title="register_databases() &amp;&amp; deregister_databases()"></a>register_databases() &amp;&amp; deregister_databases()</h3><p>注册注销数据库：向 CodeQL 查询服务器注册一个或多个数据库，使其可用于查询执行。</p>
<p>这是CodeQL客户端资源管理的核心，确保数据库在查询执行前正确注册，在执行后及时清理，是高效使用 CodeQL 服务器的关键组件。</p>
<h3 id="evaluate-queries"><a href="#evaluate-queries" class="headerlink" title="evaluate_queries()"></a>evaluate_queries()</h3><p>执行完整的 CodeQL 查询 ：在指定的数据库上运行一个 QL 查询文件，并将结果保存到输出文件。</p>
<ul>
<li>query_path ：QL 查询文件路径</li>
<li>db_path ：CodeQL 数据库路径</li>
<li>output_path ：结果输出文件路径（BQRS 格式）</li>
<li>callback ：异步完成回调（可选）</li>
<li>progress_callback ：进度回调（可选）</li>
</ul>
<p>默认完成处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">on_done</span>(<span class="params">result</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[evaluateQueries] done:&quot;</span>, result)</span><br><span class="line">    <span class="keyword">if</span> result.get(<span class="string">&quot;resultType&quot;</span>) != <span class="number">0</span>:  <span class="comment"># 0表示成功</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;result.get(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;Unknown error&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>发送异步请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.send_request(</span><br><span class="line">    <span class="string">&quot;evaluation/runQuery&quot;</span>,      <span class="comment"># JSON-RPC方法</span></span><br><span class="line">    params,                     <span class="comment"># 参数</span></span><br><span class="line">    callback <span class="keyword">or</span> on_done,        <span class="comment"># 使用用户回调或默认回调</span></span><br><span class="line">    progress_callback=progress_callback  <span class="comment"># 进度回调</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>函数会执行整个 QL 文件的所有查询，支持回调和进度跟踪。</p>
<h3 id="evaluate-and-wait"><a href="#evaluate-and-wait" class="headerlink" title="evaluate_and_wait()"></a>evaluate_and_wait()</h3><p>同步执行完整查询的便捷方法，其中包装了 evaluate_queries() 的异步功能，使用 wait_for_progress_done() 等待查询完成，简化了同步使用场景。</p>
<h3 id="quick-evaluate-and-wait"><a href="#quick-evaluate-and-wait" class="headerlink" title="quick_evaluate_and_wait()"></a>quick_evaluate_and_wait()</h3><p>同步执行快速评估，包装了quick_evaluate() 的异步功能，但是需要指定代码位置（行、列）。</p>
<h3 id="quick-evaluate"><a href="#quick-evaluate" class="headerlink" title="quick_evaluate()"></a>quick_evaluate()</h3><p>执行快速评估（Quick Evaluation） ：只执行 QL 查询文件中 特定代码片段 的查询，而不是整个文件。</p>
<ul>
<li>file_path ：QL 查询文件路径</li>
<li>db_path ：CodeQL 数据库路径</li>
<li>output_path ：结果输出文件路径</li>
<li>start_line , start_col ：起始位置（1-based）</li>
<li>end_line , end_col ：结束位置（1-based）</li>
<li>callback ：异步完成回调</li>
<li>progress_callback ：进度回调</li>
</ul>
<h3 id="wait-for-progress-done-wait-for-completion-callback"><a href="#wait-for-progress-done-wait-for-completion-callback" class="headerlink" title="wait_for_progress_done() &amp;&amp; wait_for_completion_callback()"></a>wait_for_progress_done() &amp;&amp; wait_for_completion_callback()</h3><p>功能 ：创建一个进度完成等待器 和 完成回调等待器。这两个函数都是 异步转同步 的工具：</p>
<ul>
<li>将异步回调模式转换为同步等待模式</li>
<li>简化了不需要复杂异步处理的场景</li>
<li>提供了更直观的API使用方式</li>
</ul>
<h2 id="MCP-Server-构建"><a href="#MCP-Server-构建" class="headerlink" title="MCP Server 构建"></a>MCP Server 构建</h2><p>基于 FastMCP 框架构建的 CodeQL 分析服务器，提供了 6 个工具来与 CodeQL 进行交互。</p>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>服务器初始化：使用 FastMCP 创建名为 “CodeQL” 的 MCP 服务器，实例化 CodeQLQueryServer 并启动，用于处理 CodeQL 查询操作。</p>
<h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><ol>
<li>register_database</li>
</ol>
<p>注册 CodeQL 数据库到查询服务器。验证数据库路径和必需的 src.zip 文件是否存在。</p>
<ol start="2">
<li>quick_evaluate</li>
</ol>
<p>快速评估 CodeQL 查询文件中的特定类或谓词，自动定位符号位置并执行评估。</p>
<ol start="3">
<li>decode_bqrs</li>
</ol>
<p>解码 CodeQL 结果文件（.bqrs 格式），支持 CSV（用于问题查询）或 JSON（用于路径问题）格式。</p>
<ol start="4">
<li>evaluate_query</li>
</ol>
<p>在指定数据库上运行完整的 CodeQL 查询文件。</p>
<ol start="5">
<li>find_class_position</li>
</ol>
<p>查找查询文件中类定义的准确位置（行号和列号）。</p>
<ol start="6">
<li>find_predicate_position</li>
</ol>
<p>查找查询文件中谓词定义的准确位置（行号和列号）。</p>
<h3 id="MCP-Server-代码"><a href="#MCP-Server-代码" class="headerlink" title="MCP Server 代码"></a>MCP Server 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mcp = FastMCP(<span class="string">&quot;CodeQL&quot;</span>)</span><br><span class="line">qs = CodeQLQueryServer()</span><br><span class="line">qs.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">register_database</span>(<span class="params">db_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This tool registers a CodeQL database given a path&quot;&quot;&quot;</span></span><br><span class="line">    db_path_resolved = Path(db_path).resolve()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> db_path_resolved.exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Database path does not exist: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    source_zip = db_path_resolved / <span class="string">&quot;src.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> source_zip.exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Missing required src.zip in: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    db_entry = &#123;</span><br><span class="line">        <span class="string">&quot;uri&quot;</span>: Path(db_path).resolve().as_uri(),</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;sourceArchiveZip&quot;</span>: (Path(db_path) / <span class="string">&quot;src.zip&quot;</span>).resolve().as_uri(),</span><br><span class="line">            <span class="string">&quot;dbDir&quot;</span>: Path(db_path).resolve().as_uri(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    callback, done, result_holder = qs.wait_for_completion_callback()</span><br><span class="line">    qs.register_databases(</span><br><span class="line">        [db_path],</span><br><span class="line">        callback=callback,</span><br><span class="line">        progress_callback=<span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">&quot;[progress] register:&quot;</span>, msg),</span><br><span class="line">    )</span><br><span class="line">    done.wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Database registered: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">quick_evaluate</span>(<span class="params"></span></span><br><span class="line"><span class="params">    file: <span class="built_in">str</span>, db: <span class="built_in">str</span>, symbol: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="string">&quot;/tmp/quickeval.bqrs&quot;</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This will allow you to quick_evaluate either a class or a predicate in a codeql query&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start, scol, end, ecol = qs.find_class_identifier_position(file, symbol)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        start, scol, end, ecol = qs.find_predicate_identifier_position(</span><br><span class="line">            file, symbol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qs.quick_evaluate_and_wait(</span><br><span class="line">            file, db, output_path, start, scol, end, ecol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> re:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;re&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">decode_bqrs</span>(<span class="params">bqrs_path: <span class="built_in">str</span>, fmt: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This can be used to decode CodeQL results, format is either csv for problem queries or json for path-problems&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> qs.decode_bqrs(bqrs_path, fmt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">evaluate_query</span>(<span class="params"></span></span><br><span class="line"><span class="params">    query_path: <span class="built_in">str</span>, db_path: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="string">&quot;/tmp/eval.bqrs&quot;</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Runs a CodeQL query on a given database&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qs.evaluate_and_wait(query_path, db_path, output_path)</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> re:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;re&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_class_position</span>(<span class="params">file: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds startline, startcol, endline endcol of a class for quickeval&quot;&quot;&quot;</span></span><br><span class="line">    start, scol, end, ecol = qs.find_class_identifier_position(file, name)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;start_line&quot;</span>: start,</span><br><span class="line">        <span class="string">&quot;start_col&quot;</span>: scol,</span><br><span class="line">        <span class="string">&quot;end_line&quot;</span>: end,</span><br><span class="line">        <span class="string">&quot;end_col&quot;</span>: ecol,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_predicate_position</span>(<span class="params">file: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds startline, startcol, endline endcol of a predicate for quickeval&quot;&quot;&quot;</span></span><br><span class="line">    start, scol, end, ecol = qs.find_predicate_identifier_position(file, name)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;start_line&quot;</span>: start,</span><br><span class="line">        <span class="string">&quot;start_col&quot;</span>: scol,</span><br><span class="line">        <span class="string">&quot;end_line&quot;</span>: end,</span><br><span class="line">        <span class="string">&quot;end_col&quot;</span>: ecol,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting CodeQL MCP server...&quot;</span>)</span><br><span class="line">    mcp.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="MCP-Server-测试"><a href="#MCP-Server-测试" class="headerlink" title="MCP Server 测试"></a>MCP Server 测试</h2><p>以注册数据库为例，进行MCP Server功能测试：</p>
<p>首先启动 MCP Server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(really_mcp) PS D:\Projects\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">[*] Read loop started</span><br><span class="line">INFO:     Started server process [23464]</span><br><span class="line">INFO:     Waiting <span class="keyword">for</span> application startup.</span><br><span class="line">INFO:     Application startup complete.</span><br><span class="line">INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 cursor 的 MCP tools 页面加载对应工具，选择启用状态：</p>
<p><img src="/../uploads/CodeQL_MCP_1.png"></p>
<p>对应配置文件如下：</p>
<p><img src="/../uploads/CodeQL_MCP_2.png"></p>
<p>MCP Server状态与 Tools 调用情况：</p>
<p><img src="/../uploads/CodeQL_MCP_3.png"></p>
<p>以上验证 CodeQL MCP 可成功调用并执行。</p>
<p>与服务器通信的数据包数据：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Accepted</span><br><span class="line">[12/15/25 20:26:54] INFO     Processing request of type CallToolRequest                   server.py:674</span><br><span class="line">[DEBUG] Sending evaluation/registerDatabases with progressId=0</span><br><span class="line"></span><br><span class="line">[→] Sending request:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;method&quot;: &quot;evaluation/registerDatabases&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;body&quot;: &#123;</span><br><span class="line">      &quot;databases&quot;: [</span><br><span class="line">        &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;progressId&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[stdout] Content-Length: 102</span><br><span class="line">[raw response body] &#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:1,&quot;result&quot;:&#123;&quot;registeredDatabases&quot;:[&quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">[←] Received response:</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">    ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INFO:     127.0.0.1:56577 - &quot;POST /messages/?session_id=d8bc9c141a864777b7a094f0a6abc6ad HTTP/1.1&quot; 202 Accepted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO使用记录</title>
    <url>/2025/12/04/HEXO%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Hexo-使用记录"><a href="#Hexo-使用记录" class="headerlink" title="Hexo 使用记录"></a>Hexo 使用记录</h1><p>参考文献： <a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
<p>官方文档：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<h2 id="HEXO-简介"><a href="#HEXO-简介" class="headerlink" title="HEXO 简介"></a>HEXO 简介</h2><p>Hexo 是一个基于 Node.js 的快速、简洁且高效的静态博客框架。它拥有超快的渲染速度、灵活的配置方式，以及丰富的主题与插件生态。借助 Markdown 写作，可以轻松生成优雅的静态网页，并部署到 GitHub Pages、Vercel、Netlify 等任意静态托管平台。无论是想建立个人博客、文档站点，还是打造独特的技术分享空间，Hexo 都能提供流畅而高效的创作体验。</p>
<span id="more"></span>

<h2 id="一、Hexo-安装"><a href="#一、Hexo-安装" class="headerlink" title="一、Hexo 安装"></a>一、Hexo 安装</h2><p>Hexo 是一个快速、简单且功能强大的博客框架，可以使用 Markdown （或其他标记语言）编写文章，Hexo 会在几秒钟内生成带有对应主题的静态文件。</p>
<p>安装 Hexo 需要 Node.js 以及 Git 环境。</p>
<p>Node.js 下载地址 <a href="https://nodejs.org/en/download">Node.js Download</a></p>
<p>Git 下载地址 <a href="https://git-scm.com/install/windows">Git Download</a></p>
<p>所有必需组件安装完毕后，即可使用 npm 安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>初始化 Hexo 站点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexo-site</span><br></pre></td></tr></table></figure>
<p>hexo-site 也可以替换为其他路径名，以 hexo-site 为例，网站根目录被称为 <code>hexo-site</code>。 </p>
<p>初始化完成后，可以到网站根目录下，下载对应主题并进行升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-site</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>运行 npm install 时，对 node_modules 目录下主题所做的任何本地更改都将丢失。如果对主题进行了更改，则应在运行 npm install 之前备份这些更改，然后在安装完成后恢复这些更改。</p>
<p>安装完 Hexo 和 NexT 主题后，可以通过修改配置文件来自定义博客。安装 Hexo 时，配套的配置文件位于网站根目录。博客配置文件名为 _config.yml ；我们称之为 Hexo 配置文件 NexT 主题的配置文件需要您自行创建；请在目录下创建一个 _config.next.yml 文件。 网站根目录我们将其称为 Next 配置文件在以下文本中。</p>
<p>创建空的 _config.next.yml 文件后，可以将主题文件夹中的默认配置选项复制到该文件中，以便进行修改和自定义。根据安装方式，NexT 主题的默认配置文件可能位于 themes&#x2F;next&#x2F;_config.yml 或 node_modules&#x2F;hexo-theme-next&#x2F;_config.yml 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>

<h2 id="二、Hexo-个性化设置"><a href="#二、Hexo-个性化设置" class="headerlink" title="二、Hexo 个性化设置"></a>二、Hexo 个性化设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove unnecessary files after hexo generate.</span></span><br><span class="line">minify: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line">darkmode: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:zyufoye/zyufoye.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、Hexo-新建发布文章"><a href="#三、Hexo-新建发布文章" class="headerlink" title="三、Hexo 新建发布文章"></a>三、Hexo 新建发布文章</h2><p>新建发布文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成并部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp;  hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>同步更新部署到github：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>博客侧边栏添加 menu 菜单，以 tags 和 categories 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>同时在index.md 中设置类别，不然点击跳转后不显示任何内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>: categories</span><br></pre></td></tr></table></figure>

<p>设置文章想要显示的内容时，可以用 more 进行切分， more以上的作为显示内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>以上基本配置和简单使用记录完毕，后续有更多需要再持续更新记录。  </p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL入门（二）</title>
    <url>/2025/12/17/CodeQL%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="CodeQL-查询语句编写"><a href="#CodeQL-查询语句编写" class="headerlink" title="CodeQL 查询语句编写"></a>CodeQL 查询语句编写</h2><p>以python为例，编写一个简单的hello world codeql查询。首先需要使用 codeql 创建一个数据库，这样才能为其编写查询语句，使用如下命令创建数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql database create test_db --language=python</span><br></pre></td></tr></table></figure>

<p>此时文件中会多出一个文件夹 test_db 即为当前项目的 codeql 数据库。接下来需要编写查询语句，一个标准的 codeql 查询语句格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Query metadata</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import <span class="comment">/* ... CodeQL libraries or modules ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... Optional, define CodeQL classes and predicates ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="comment">/* ... variable declarations ... */</span></span><br><span class="line"><span class="keyword">where</span> <span class="comment">/* ... logical formula ... */</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/* ... expressions ... */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>语句可以简单理解为：<strong>通过 <code>import</code> 导入哪些库，然后<code>from</code>从哪些数据中，查找 <code>select</code>满足哪些条件<code>where</code>的结果。</strong></p>
</blockquote>
<p>为hello world简单编写一个查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;hello,world&quot;</span><br></pre></td></tr></table></figure>

<p>使用 query run 子命令指定 test_db 数据库执行 helloworld.ql 查询语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db/ helloworld.ql</span><br></pre></td></tr></table></figure>

<p>执行成功，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db/ helloworld.ql</span><br><span class="line"></span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/helloworld.ql.</span><br><span class="line">[1/1 comp 745ms] Compiled /home/zyu/projects/python_codeql_demo/helloworld.ql.</span><br><span class="line">helloworld.ql: Evaluation completed (45ms).</span><br><span class="line">|    col0     |</span><br><span class="line">+-------------+</span><br><span class="line">| hello,world |</span><br><span class="line">Shutting down query evaluator.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了这种 cli 的运行方式，codeql 还提供了另外两种运行方式，分别是 VScode插件和 CI&#x2F;CD 方式：</p>
<ul>
<li><p>CodeQL_cli：适合对项目源码进行批量的规则扫描和检测，使用命令行进行操作；</p>
</li>
<li><p>VSCode插件：适合使用 CodeQL 辅助进行代码审计，使用 VSCode 进行操作；</p>
</li>
<li><p>CI&#x2F;CD：结合规则库将 CodeQL 添加进 CI&#x2F;CD 流程进行持续化的项目安全管理，在 CI&#x2F;CD 流程中自动执行；</p>
</li>
</ul>
<span id="more"></span>

<h2 id="官方-CodeQL-tutorials"><a href="#官方-CodeQL-tutorials" class="headerlink" title="官方 CodeQL tutorials"></a>官方 CodeQL tutorials</h2><p>CodeQL 官方提供了 QL 教程(<a href="https://codeql.github.com/docs/writing-codeql-queries/ql-tutorials/)%E4%BB%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B8%AE%E5%8A%A9%E7%94%A8%E6%88%B7%E5%85%A5%E9%97%A8">https://codeql.github.com/docs/writing-codeql-queries/ql-tutorials/)以游戏的方式帮助用户入门</a> QL 并理解基础的语法规则。</p>
<h3 id="CodeQL-baseline"><a href="#CodeQL-baseline" class="headerlink" title="CodeQL baseline"></a>CodeQL baseline</h3><p>官方文档中介绍，更加复杂的通用查询看起来像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="comment">/* ... variable declarations ... */</span></span><br><span class="line"><span class="keyword">where</span> <span class="comment">/* ... logical formulas ... */</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/* ... expressions ... */</span></span><br></pre></td></tr></table></figure>

<p>示例1-以下面的这个为例，查询结果是数字 42：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="type">int</span> x, <span class="type">int</span> y</span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">6</span> <span class="keyword">and</span> y <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">select</span> x <span class="operator">*</span> y</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db demo1.ql</span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo1.ql.</span><br><span class="line">[1/1 comp 805ms] Compiled /home/zyu/projects/python_codeql_demo/demo1.ql.</span><br><span class="line">demo1.ql: Evaluation completed (48ms).</span><br><span class="line">| col0 |</span><br><span class="line">+------+</span><br><span class="line">|   42 |</span><br><span class="line">Shutting down query evaluator.</span><br></pre></td></tr></table></figure>

<p>示例2-多结果查询示例：查询计算 1 到 10 之间的所有勾股数，通过编写类的方式简化ql代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class <span class="type">SmallInt</span> extends <span class="type">int</span> &#123;</span><br><span class="line">  <span class="type">SmallInt</span>() &#123; this <span class="keyword">in</span> [<span class="number">1.</span><span class="number">.10</span>] &#125;</span><br><span class="line">  <span class="type">int</span> square() &#123; <span class="keyword">result</span> <span class="operator">=</span> this<span class="operator">*</span>this &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="type">SmallInt</span> x, <span class="type">SmallInt</span> y, <span class="type">SmallInt</span> z</span><br><span class="line"><span class="keyword">where</span> x.square() <span class="operator">+</span> y.square() <span class="operator">=</span> z.square()</span><br><span class="line"><span class="keyword">select</span> x, y, z</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db demo2.ql</span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo2.ql.</span><br><span class="line">[1/1 comp 900ms] Compiled /home/zyu/projects/python_codeql_demo/demo2.ql.</span><br><span class="line">demo2.ql: Evaluation completed (55ms).</span><br><span class="line">| x | y | z  |</span><br><span class="line">+---+---+----+</span><br><span class="line">| 3 | 4 | 5  |</span><br><span class="line">| 4 | 3 | 5  |</span><br><span class="line">| 6 | 8 | 10 |</span><br><span class="line">| 8 | 6 | 10 |</span><br><span class="line">Shutting down query evaluator.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例3-查询python中超过 7 个参数的函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import python</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Function</span> f</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">count</span>(f.getAnArg()) <span class="operator">&gt;</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">select</span> f</span><br></pre></td></tr></table></figure>

<p>要导入特定编程语言的 CodeQL 库，在查询开始处输入 <code>import language</code> 。from 子句定义了一个变量 f ，代表一个 Python 函数。 where 部分将函数 f 限制为那些具有超过 7 个参数的函数。最后， select 子句列出了这些函数。</p>
<p>在运行这个查询时遇到了一些错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d argdb demo3.ql</span><br><span class="line"></span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo3.ql.</span><br><span class="line">ERROR: could not resolve module python (/home/zyu/projects/python_codeql_demo/demo3.ql:1,8-14)</span><br><span class="line">ERROR: could not resolve <span class="built_in">type</span> Function (/home/zyu/projects/python_codeql_demo/demo3.ql:3,6-14)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析原因，错误信息 <code>could not resolve module python</code> 和 <code>could not resolve type Function</code> 表明 CodeQL 编译器无法找到 Python 标准查询库（Standard QL Libraries）。</p>
<p>缺少 qlpack.yml 文件：CodeQL 现在强烈依赖 “CodeQL Packs” 系统。如果你直接运行一个裸露的 .ql 文件，而该文件所在目录没有声明它依赖 codeql&#x2F;python-all，编译器就不知道 import python 到底是指向哪里的库。</p>
<p>创建 qlpack.yml 文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">my-custom-queries</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">codeql/python-all:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后执行 codeql pack install 出现如下提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARNING: Pack <span class="string">&#x27;codeql/xml&#x27;</span> was found via <span class="string">&#x27;--additional-packs&#x27;</span>. If the generated <span class="string">&#x27;codeql-pack.lock.yml&#x27;</span> file is committed to <span class="built_in">source</span> control, other <span class="built_in">users</span> will also have to use <span class="string">&#x27;--additional-packs&#x27;</span> when compiling or running queries.  (/home/zyu/codeql/qlpacks/codeql/xml/1.0.38/qlpack.yml:1,1-1)</span><br><span class="line">......</span><br><span class="line">WARNING: Pack <span class="string">&#x27;codeql/yaml&#x27;</span> was found via <span class="string">&#x27;--additional-packs&#x27;</span>. If the generated <span class="string">&#x27;codeql-pack.lock.yml&#x27;</span> file is committed to <span class="built_in">source</span> control, other <span class="built_in">users</span> will also have to use <span class="string">&#x27;--additional-packs&#x27;</span> when compiling or running queries.  (/home/zyu/codeql/qlpacks/codeql/yaml/1.0.38/qlpack.yml:1,1-1)</span><br><span class="line">WARNING: To avoid these warnings <span class="keyword">in</span> the future, use the <span class="string">&#x27;--no-strict-mode&#x27;</span> option. (/home/zyu/projects/python_codeql_demo/qlpack.yml:1,1-1)</span><br><span class="line"></span><br><span class="line">Dependencies resolved. Installing packages...</span><br><span class="line">Install location: /home/zyu/.codeql/packages</span><br><span class="line">Nothing to install.</span><br><span class="line">Package install location: /home/zyu/.codeql/packages</span><br><span class="line">Nothing downloaded.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>警告部分大致的意思是：我知道你需要 python-all，我也找到了它。但是 python-all 内部还依赖 dataflow。虽然我现在能找到它们，但因为你没有一个全局的 codeql-workspace.yml 文件来统一管理这些路径，我担心等到你真正运行查询的时候，我可能会找不到这些底层依赖。</p>
<p><strong>但在使用 CodeQL Bundle（下载的那个大压缩包）时，通常 CLI 会自动处理这些路径，所以这些警告往往可以忽略。</strong></p>
<p>返回结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d argdb demo3.ql</span><br><span class="line"></span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo3.ql.</span><br><span class="line">[1/1 comp 12s] Compiled /home/zyu/projects/python_codeql_demo/demo3.ql.</span><br><span class="line">demo3.ql: Evaluation completed (113ms).</span><br><span class="line">|           f            |</span><br><span class="line">+------------------------+</span><br><span class="line">| Function test_function |</span><br><span class="line">Shutting down query evaluator.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="官方示例-Find-the-thief"><a href="#官方示例-Find-the-thief" class="headerlink" title="官方示例 Find the thief"></a>官方示例 Find the thief</h3><p>把以下内容转换为 ql 查询：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小偷身高超过 150 厘米吗？</td>
<td>是</td>
</tr>
<tr>
<td>2</td>
<td>小偷有金发吗？</td>
<td>不</td>
</tr>
<tr>
<td>3</td>
<td>小偷秃头吗？</td>
<td>不</td>
</tr>
<tr>
<td>4</td>
<td>小偷是否小于 30 岁？</td>
<td>不</td>
</tr>
<tr>
<td>5</td>
<td>小偷是否住在城堡的东边？</td>
<td>是</td>
</tr>
<tr>
<td>6</td>
<td>小偷有黑色或棕色头发吗？</td>
<td>是</td>
</tr>
<tr>
<td>7</td>
<td>小偷身高是否超过 180 厘米且低于 190 厘米？</td>
<td>不</td>
</tr>
<tr>
<td>8</td>
<td>小偷是村里年纪最大的人吗？</td>
<td>不</td>
</tr>
<tr>
<td>9</td>
<td>小偷是村里最高的人吗？</td>
<td>不</td>
</tr>
<tr>
<td>10</td>
<td>小偷比村民的平均身高矮吗？</td>
<td>是</td>
</tr>
<tr>
<td>11</td>
<td>小偷是村东部最年长的人吗？</td>
<td>是</td>
</tr>
</tbody></table>
<p>查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import tutorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Person t</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  <span class="comment">/* 1 */</span> t.getHeight() <span class="operator">&gt;</span> <span class="number">150</span> <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 2 */</span> <span class="keyword">not</span> t.getHairColor() <span class="operator">=</span> &quot;blond&quot; <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 3 */</span> <span class="keyword">exists</span> (string c <span class="operator">|</span> t.getHairColor() <span class="operator">=</span> c) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 4 */</span> <span class="keyword">not</span> t.getAge() <span class="operator">&lt;</span> <span class="number">30</span> <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 5 */</span> t.getLocation() <span class="operator">=</span> &quot;east&quot; <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 6 */</span> (t.getHairColor() <span class="operator">=</span> &quot;black&quot; <span class="keyword">or</span> t.getHairColor() <span class="operator">=</span> &quot;brown&quot;) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 7 */</span> <span class="keyword">not</span> (t.getHeight() <span class="operator">&gt;</span> <span class="number">180</span> <span class="keyword">and</span> t.getHeight() <span class="operator">&lt;</span> <span class="number">190</span>) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 8 */</span> <span class="keyword">exists</span>(Person p <span class="operator">|</span> p.getAge() <span class="operator">&gt;</span> t.getAge()) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 9 */</span> <span class="keyword">not</span> t <span class="operator">=</span> <span class="built_in">max</span>(Person p <span class="operator">|</span> <span class="operator">|</span> p <span class="keyword">order</span> <span class="keyword">by</span> p.getHeight()) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 10 */</span> t.getHeight() <span class="operator">&lt;</span> <span class="built_in">avg</span>(<span class="type">float</span> i <span class="operator">|</span> <span class="keyword">exists</span>(Person p <span class="operator">|</span> p.getHeight() <span class="operator">=</span> i) <span class="operator">|</span> i) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 11 */</span> t <span class="operator">=</span> <span class="built_in">max</span>(Person p <span class="operator">|</span> p.getLocation() <span class="operator">=</span> &quot;east&quot; <span class="operator">|</span> p <span class="keyword">order</span> <span class="keyword">by</span> p.getAge())</span><br><span class="line"><span class="keyword">select</span> &quot;The thief is &quot; <span class="operator">+</span> t <span class="operator">+</span> &quot;!&quot;</span><br></pre></td></tr></table></figure>

<h3 id="官方示例-Catch-the-fire-starter"><a href="#官方示例-Catch-the-fire-starter" class="headerlink" title="官方示例 Catch the fire starter"></a>官方示例 Catch the fire starter</h3><p>本节主要介绍了 codeql 的谓词和类。因为对<strong>谓词</strong>的理解不是很明白，所以这里多一点背景介绍。</p>
<p>学习 QL 谓词和类，作为 QL 侦探解决你的第二个谜团。就像你成功找到小偷并将金冠归还城堡一样，另一场可怕的犯罪发生了。清晨，几个人在村庄北面的田野里纵火，烧毁了所有的庄稼！你现在以 QL 侦探专家的声誉而闻名，因此再次被要求找出罪魁祸首。这次，你有一些额外信息。村庄的南北两侧存在激烈竞争，而且你知道罪犯住在南边。通过以下示例学习如何在 QL 中定义谓词和类。这将使你的查询逻辑更易于理解，并有助于简化你的侦探工作。</p>
<p>这次你只需要考虑一个特定的村民群体，即住在村庄南边的人。你不必在所有查询中都写 <code>getLocation() = &quot;south&quot; </code>，可以定义一个新的谓词 <code>isSouthern </code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">predicate isSouthern(Person p) &#123;</span><br><span class="line">  p.getLocation() <span class="operator">=</span> &quot;south&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谓词 <code>isSouthern(p)</code> 接受一个参数 <code>p</code> 并检查 <code>p</code> 是否满足属性 <code>p.getLocation() = &quot;south&quot;</code> 。</p>
<p>谓词的名称总是以小写字母开头。</p>
<p>王冠被盗后开始实施旅行限制。最初，村民们可以在村庄内自由旅行，没有限制。因此，谓词 isAllowedIn(string region) 对任何人和任何地区都成立。以下查询列出了所有村民，因为他们都可以去北方：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Person p</span><br><span class="line"><span class="keyword">where</span> p.isAllowedIn(&quot;north&quot;)</span><br><span class="line"><span class="keyword">select</span> p</span><br></pre></td></tr></table></figure>

<p>然而，在最近的盗窃事件后，村民们对村周围潜伏的罪犯变得更加担忧，他们不再允许 10 岁以下的儿童离开他们的居住区域。这意味着 <code>isAllowedIn(string region)</code> 不再对所有人和所有地区成立，因此如果 p 是一个孩子，应该暂时覆盖原始谓词。</p>
<p>首先定义一个包含所有 10 岁以下村民的类 <code>Child</code> 。然后你可以将 <code>isAllowedIn(string region)</code> 重新定义为 <code>Child</code> 的成员谓词，以允许儿童只在自己的区域内移动。这由 <code>region = this.getLocation()</code> 表示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Child extends Person &#123;</span><br><span class="line">  <span class="comment">/* the characteristic predicate */</span></span><br><span class="line">  Child() &#123; this.getAge() <span class="operator">&lt;</span> <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a member predicate */</span></span><br><span class="line">  override predicate isAllowedIn(string region) &#123;</span><br><span class="line">    region <span class="operator">=</span> this.getLocation()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在尝试将 <code>isAllowedIn(string region)</code> 应用于一个人 <code>p</code> 。如果 <code>p</code> 不是孩子，则使用原始定义，但如果 <code>p</code> 是孩子，则新的谓词定义会覆盖原始定义。</p>
<p>知道火种者住在南方，而且他们必须能够前往北方。写一个查询来找出可能的嫌疑人。也可以扩展 select 子句来列出嫌疑人的年龄。这样就能清楚地看到所有孩子都被排除在名单之外。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import tutorial</span><br><span class="line"></span><br><span class="line">predicate isSouthern(Person p) &#123; p.getLocation() <span class="operator">=</span> &quot;south&quot; &#125;</span><br><span class="line"></span><br><span class="line">class Southerner extends Person &#123;</span><br><span class="line">  <span class="comment">/* the characteristic predicate */</span></span><br><span class="line">  Southerner() &#123; isSouthern(this) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Person &#123;</span><br><span class="line">  <span class="comment">/* the characteristic predicate */</span></span><br><span class="line">  Child() &#123; this.getAge() <span class="operator">&lt;</span> <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a member predicate */</span></span><br><span class="line">  override predicate isAllowedIn(string region) &#123; region <span class="operator">=</span> this.getLocation() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Southerner s</span><br><span class="line"><span class="keyword">where</span> s.isAllowedIn(&quot;north&quot;)</span><br><span class="line"><span class="keyword">select</span> s, s.getAge()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SAST</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Function Call和MCP的区别</title>
    <url>/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）"><a href="#Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）" class="headerlink" title="Function Call和MCP的核心区别梳理（由GPT 5.1 生成）"></a>Function Call和MCP的核心区别梳理（由GPT 5.1 生成）</h2><h2 id="🧩核心区别总结"><a href="#🧩核心区别总结" class="headerlink" title="🧩核心区别总结"></a>🧩核心区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Function Call</th>
<th>MCP（Model Context Protocol）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>让模型按照开发者定义的结构化方式返回“调用某函数所需的参数”。</td>
<td>让模型与外部工具、服务、数据源通过统一协议进行双向通信。</td>
</tr>
<tr>
<td><strong>角色</strong></td>
<td>模型只“产生命令”（函数+参数），不执行。执行由外部应用完成。</td>
<td>除生成调用外，还可以<strong>发现、注册、调度、执行</strong>外部资源。</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单、轻量级、多数场景够用。</td>
<td>更底层、更通用，可连接复杂系统。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>调用某个特定函数、处理结构化任务。</td>
<td>接入多个工具、多数据源、插件系统、企业级工作流。</td>
</tr>
</tbody></table>
<hr>
<span id="more"></span>

<h2 id="🧠Function-Call-是什么？"><a href="#🧠Function-Call-是什么？" class="headerlink" title="🧠Function Call 是什么？"></a>🧠Function Call 是什么？</h2><p><strong>Function Call</strong> 是模型输出的一种结构化格式，模型输出它想调用什么函数并且要传什么参数。模型只负责<strong>输出结构化 JSON</strong>，实际执行由相关程序完成。</p>
<p><strong>Function Call</strong>提供的是 API 层的能力，由开发者定义可调用函数列表，模型产出：函数名 + 参数，适用于简单逻辑。</p>
<h3 id="✔-Function-Call-示例"><a href="#✔-Function-Call-示例" class="headerlink" title="✔ Function Call 示例"></a>✔ Function Call 示例</h3><p>假设开发者定义了一个函数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取城市天气&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;city&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用户问：</p>
<blockquote>
<p>“明天北京天气如何？”</p>
</blockquote>
<p>模型可能返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后 <strong>相关程序</strong> 执行 get_weather(“北京”) 并把结果再返回给模型或用户。</p>
<p>📌 <strong>关键点：模型不会执行，只会返回结构体。</strong></p>
<h2 id="🧠MCP（Model-Context-Protocol）是什么？"><a href="#🧠MCP（Model-Context-Protocol）是什么？" class="headerlink" title="🧠MCP（Model Context Protocol）是什么？"></a>🧠MCP（Model Context Protocol）是什么？</h2><p>MCP 是一个<strong>通用协议</strong>，用于管理工具（tools），连接外部数据源（database、文件系统等），让模型能够发现并调用这些资源，同时统一不同工具的接口格式。</p>
<p>可以把 MCP 理解为：</p>
<blockquote>
<p><strong>模型与外部世界的“操作系统抽象层”</strong><br>它让模型能直接访问文件、数据库、网络等工具。</p>
</blockquote>
<p>它的“能力”比 Function Call 强得多，因为：</p>
<p>👉 <strong>Function Call 只能调用开发人员手工写死的函数</strong><br>👉 <strong>MCP 可以动态加载工具包、文件系统服务、环境服务，让模型像操作系统用户一样访问资源</strong></p>
<hr>
<h3 id="✔-MCP-示例"><a href="#✔-MCP-示例" class="headerlink" title="✔ MCP 示例"></a>✔ MCP 示例</h3><p>假设 MCP 提供一个工具 <code>fs.read_file</code>。</p>
<p>用户问：</p>
<blockquote>
<p>“打开 &#x2F;docs&#x2F;intro.md 读给我听”</p>
</blockquote>
<p>模型实际会产生这样的消息（非 Function Call 风格，而是 MCP 消息协议）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.read_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/intro.md&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>服务端会执行 <strong>read_file</strong> 并返回文件内容。</p>
<p>模型可以继续请求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.write_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/notes.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里是我总结的内容...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里体现 MCP 的本质：</p>
<ul>
<li>模型知道有哪些工具可用</li>
<li>模型直接“操控”这些工具</li>
<li>具有类似“文件读写”等复杂能力</li>
<li>不需要开发者提前硬编码所有函数</li>
</ul>
<h2 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>Function Call</th>
<th>MCP</th>
</tr>
</thead>
<tbody><tr>
<td>工具发现</td>
<td>手工定义</td>
<td>自动注册，模型可自动学习工具能力</td>
</tr>
<tr>
<td>调用方式</td>
<td>结构化 JSON</td>
<td>双向协议、消息通信</td>
</tr>
<tr>
<td>扩展性</td>
<td>每加一个功能都要新增函数定义</td>
<td>新增 MCP 服务即可扩展工具能力</td>
</tr>
<tr>
<td>模型能力</td>
<td>被动</td>
<td>主动、可规划调用流程</td>
</tr>
<tr>
<td>场景</td>
<td>简单 API 调用、数据结构化</td>
<td>IDE、数据库集成、文件系统、GitHub 操作、企业自动化</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器系统资源查看</title>
    <url>/2025/12/17/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<h2 id="Linux服务器系统资源查看"><a href="#Linux服务器系统资源查看" class="headerlink" title="Linux服务器系统资源查看"></a>Linux服务器系统资源查看</h2><p>系统性地查看 Linux 服务器资源，也就是看CPU、内存、磁盘、网络、负载、系统等这几个层面，就能了解服务器性能以及运行情况。</p>
<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>查看系统负载和运行时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br><span class="line"></span><br><span class="line">10:35:15 up  1:34, 13 <span class="built_in">users</span>,  load average: 0.41, 0.30, 0.25</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>10:35:15</code> 表示当前系统时间是 10 点 35 分 15 秒，<code>up 1:34</code> 表示系统已经连续运行了 1 小时 34 分钟，<code>13 users</code>表示当前有 13 个用户会话登录到系统中，<code>load average: 0.41, 0.30, 0.25</code> 表示系统负载均值（Load Average），表示正在运行 + 等待运行的进程数量的平均值，三个数字分别表示最近1&#x2F;5&#x2F;15 分钟的平均负载。</p>
<blockquote>
<p><strong>Load Average &#x3D; 在某段时间内，处于「可运行状态」和「不可中断睡眠状态」进程数量的指数加权移动平均（EWMA），统计的是想用 CPU 的进程有多少。</strong></p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line"></span><br><span class="line">top - 10:52:33 up  1:52, 11 <span class="built_in">users</span>,  load average: 1.14, 0.57, 0.32</span><br><span class="line">Tasks: 2645 total,   2 running, 2643 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.8 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem : 10 total, 8 free,  6 used,  4 buff/cache</span><br><span class="line">MiB Swap:  3 total, 2 free,  1 used.  2 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  77552 xrdp      20   0   50360  20344   6856 R  18.0   0.0   0:30.70 xrdp</span><br><span class="line">  77960 mark      20   0 9361988 422920 185124 S  14.1   0.1   0:59.67 gnome-shell</span><br><span class="line">  77569 mark      20   0  382544 138588  80324 S   5.6   0.0   0:11.17 Xorg</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详解 top 输出命令内容：</p>
<p>第一行表示时间、运行时长、登录用户、平均负载；</p>
<p>第二行展示了任务数和进程状态，包含进程&#x2F;线程统计总数、正在 CPU 上运行的（或准备运行的）任务数、睡眠、进程和僵尸进程数量；</p>
<p>第三行展示了 CPU 使用构成，us用户态、sy内核态、ni被nice调整过优先级的用户态进程、id (idle) CPU空闲率、wa CPU在等 IO（磁盘&#x2F;网络存储）导致空转等待率，hi硬中断消耗，si软中断消耗；</p>
<p>第四行展示了内存：total总内存、free完全空闲内存、used真正被进程使用的内存、buff&#x2F;cache文件缓存块设备缓存；</p>
<p>第五行展示了 Swap 交换分区，Swap（交换分区&#x2F;交换文件）是内存不足时的“备用空间”，当 物理内存（RAM）不够用 时，Linux 会把暂时不用的内存页交换到磁盘上的 swap 中，从而防止系统因内存耗尽而直接崩溃（OOM），让系统还能继续运行；</p>
<p>下面展示了系统进程的详细信息：</p>
<p>表头：</p>
<p><code>PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</code></p>
<p>PID：进程号</p>
<p>USER：所属用户</p>
<p>PR：动态优先级（数值越小优先级越高；20 常见）</p>
<p>NI：nice 值（-20 到 19，越小越“抢”CPU；0 默认）</p>
<p>VIRT：虚拟内存占用（进程可见的地址空间总量，包含映射文件、共享库、未实际用到的保留空间等）</p>
<p>RES：常驻内存（实际占用物理内存，最值得关注）</p>
<p>SHR：共享内存部分（共享库等）</p>
<p>S：状态</p>
<p>R&#x3D;运行，S&#x3D;睡眠，D&#x3D;不可中断睡眠(常见 IO 卡住)，Z&#x3D;僵尸</p>
<p>%CPU：CPU 占比（注意：多核时可能 &gt;100%）</p>
<p>%MEM：内存占比</p>
<p>TIME+：累计消耗 CPU 时间</p>
<p>COMMAND：命令名</p>
<h3 id="lscpu"><a href="#lscpu" class="headerlink" title="lscpu"></a>lscpu</h3><p>查看 cpu 架构，重点关注 CPU 型号、数量、解构等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Architecture: x86_64</span><br><span class="line"></span><br><span class="line">Model name: AMD</span><br><span class="line"></span><br><span class="line">CPU(s):                2</span><br><span class="line">Thread(s) per core:    2</span><br><span class="line">Core(s) per socket:    1</span><br><span class="line">Socket(s):             1</span><br></pre></td></tr></table></figure>

<h3 id="free-h"><a href="#free-h" class="headerlink" title="free -h"></a>free -h</h3><p>查看内存资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br><span class="line">             total       used      free      shared  buff/cache   available</span><br><span class="line">Mem:           5Gi        1Gi       4Gi        87Mi         1Gi         3Gi</span><br><span class="line">Swap:          1Gi         0B       1Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="df-h"><a href="#df-h" class="headerlink" title="df -h"></a>df -h</h3><p>查看磁盘资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line">Filesystem      Size  Used Avail  Use%  Mounted on</span><br><span class="line">tmpfs             2G  3.9M    1G   50%  /run</span><br><span class="line">/dev/nvme        10G    5G    5G   50%  /</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ip-s-link"><a href="#ip-s-link" class="headerlink" title="ip -s link"></a>ip -s link</h3><p>查看网络资源，这个要视情况而定，还有ss、netstat等命令。</p>
<h3 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h3><p>查看系统及内核版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/os-release</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p>查看系统中安装的所有PCI设备。</p>
<h3 id="nvidia-smi"><a href="#nvidia-smi" class="headerlink" title="nvidia-smi"></a>nvidia-smi</h3><p>查看显卡型号。</p>
<h2 id="服务器使用规范"><a href="#服务器使用规范" class="headerlink" title="服务器使用规范"></a>服务器使用规范</h2><p>w 或 who 查看当前在线登录的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查看当前系统下的所有用户</span></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建用户</span></span><br><span class="line"><span class="built_in">sudo</span> useradd name</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> useradd -m -s /bin/bash name</span><br><span class="line"></span><br><span class="line"><span class="comment"># -m 自动创建家目录，-s指定shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为新用户指定密码</span></span><br><span class="line"><span class="built_in">sudo</span> passwd name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给新用户追加到 sudo 组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化版，添加用户时即指定其加入sudo组</span></span><br><span class="line"><span class="built_in">sudo</span> useradd -m -s /bin/bash -G <span class="built_in">sudo</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户环境 - 表示加载用户环境</span></span><br><span class="line">su - name </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP stdio与sse模式的区别</title>
    <url>/2025/12/15/MCP-stdio%E4%B8%8Esse%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="SSE-和-stdio-模式对比"><a href="#SSE-和-stdio-模式对比" class="headerlink" title="SSE 和 stdio 模式对比"></a>SSE 和 stdio 模式对比</h2><h3 id="架构差异"><a href="#架构差异" class="headerlink" title="架构差异"></a>架构差异</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">stdio 模式：</span><br><span class="line">Cursor/Claude Desktop</span><br><span class="line">    └─ 启动子进程：python server.py</span><br><span class="line">        └─ stdin/stdout 通信</span><br><span class="line">        └─ 服务器生命周期由客户端管理</span><br><span class="line"></span><br><span class="line">SSE 模式：</span><br><span class="line">独立运行：python server.py (后台持续运行)</span><br><span class="line">    ↑</span><br><span class="line">    └─ HTTP SSE 连接</span><br><span class="line">    ↑</span><br><span class="line">Cursor/Claude Desktop (通过 HTTP 连接)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>stdio 模式</th>
<th>SSE 模式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>启动方式</strong></td>
<td>客户端自动启动</td>
<td>手动启动（独立进程）</td>
</tr>
<tr>
<td><strong>通信协议</strong></td>
<td>stdin&#x2F;stdout 管道</td>
<td>HTTP + Server-Sent Events</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>单一客户端</td>
<td>多客户端支持</td>
</tr>
<tr>
<td><strong>调试难度</strong></td>
<td>难（日志混在一起）</td>
<td>易（可直接查看终端）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>生产环境</td>
<td>开发调试</td>
</tr>
<tr>
<td><strong>进程管理</strong></td>
<td>自动（随客户端）</td>
<td>手动（需要单独管理）</td>
</tr>
<tr>
<td><strong>网络要求</strong></td>
<td>无</td>
<td>需要监听端口</td>
</tr>
<tr>
<td><strong>日志可见性</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="测试时为什么选择-SSE？"><a href="#测试时为什么选择-SSE？" class="headerlink" title="测试时为什么选择 SSE？"></a>测试时为什么选择 SSE？</h3><ul>
<li><p>✅ 开发调试更方便：可以直接在终端看到所有日志，手动重启服务器，用浏览器测试连接；</p>
</li>
<li><p>✅ 多客户端支持：多个 IDE 可以同时连接，可以同时在 Cursor 和 Claude Desktop 中使用；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java漏洞靶场搭建学习(一)：环境搭建与Springboot架构</title>
    <url>/2025/12/09/Java%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8ESpringboot%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Java漏洞靶场搭建学习"><a href="#Java漏洞靶场搭建学习" class="headerlink" title="Java漏洞靶场搭建学习"></a>Java漏洞靶场搭建学习</h1><p>在学习 Java Web 安全的过程中，目前状态是只能理解相关的漏洞原理，根据 PoC 做题或者复现漏洞，但是这些对于 <strong>代码审计、漏洞挖掘、SDL</strong> 等都没有实质性帮助，想要在学习或工作过程中提升相关能力，计划实现以下目标：</p>
<ul>
<li>理解漏洞产生的真实上下文；</li>
<li>搭建一个可控、可扩展的实验环境；</li>
<li>训练从代码层面定位与修复问题的能力；</li>
</ul>
<p>这篇博客记录了学习搭建 Java 漏洞靶场的过程，作为一个学习记录，为后续能够快速搭建测试环境，验证代码审计工具能力奠定基础。</p>
<span id="more"></span>

<h2 id="项目选用"><a href="#项目选用" class="headerlink" title="项目选用"></a>项目选用</h2><p>本文以 <a href="https://github.com/l4yn3/micro_service_seclab">micro_service_seclab</a> 为基础进行练习。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/l4yn3/micro_service_seclab.git</span><br></pre></td></tr></table></figure>

<p>拿到java项目，导入IDEA，对于有pom.xml的项目，可以直接使用mvn进行构建。</p>
<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--链接数据库</span></span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE micro_service_seclab</span><br><span class="line">  <span class="keyword">CHARACTER SET</span> utf8mb4</span><br><span class="line">  <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用数据库</span></span><br><span class="line">USE micro_service_seclab;</span><br></pre></td></tr></table></figure>

<p>执行sql文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> \d D:\Code\micro_service_seclab</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line">mysql -u root -p micro_service_seclab &lt; micro_service_seclab.sql</span><br></pre></td></tr></table></figure>

<p>需要找到 application.properties  文件，修改对应的数据库用户名和密码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/micro_service_seclab</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=1234</span></span><br></pre></td></tr></table></figure>

<p>在pom.xml的路径下，执行mvn命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure>

<p>启动后访问 <a href="http://127.0.0.1:8080/sqlinjection/one?username=yueshen">http://127.0.0.1:8080/sqlinjection/one?username=yueshen</a> 即可看到返回以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;username&quot;</span>:<span class="string">&quot;yueshen&quot;</span>,<span class="string">&quot;sex&quot;</span>:1,<span class="string">&quot;age&quot;</span>:33&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h2><h3 id="Spring-Boot-三层架构"><a href="#Spring-Boot-三层架构" class="headerlink" title="Spring-Boot 三层架构"></a>Spring-Boot 三层架构</h3><p>该项目核心是一个 Spring Boot Web 应用，通过不同的 Controller 暴露漏洞演示接口；底层再通过 Logic&#x2F;DAO&#x2F;DB&#x2F;MyBatis 访问数据库或触发危险点。</p>
<p>调用链（一次请求的完整路径）：</p>
<blockquote>
<p>HTTP 请求 → controller（漏洞入口） → logic（业务&#x2F;场景封装） → dao&#x2F;mapper（数据访问&#x2F;危险实现） → db&#x2F;mysql</p>
</blockquote>
<p>用通俗的话来记录，就是：</p>
<p>Controller 提供靶场入口，Logic 做业务组织，DAO&#x2F;Mapper 负责数据库或危险 API 调用，data 是实体&#x2F;数据模型，db 是数据库初始化&#x2F;连接辅助。</p>
<ul>
<li><code>Controller</code>：漏洞入口层，对外提供 HTTP API，用户通过 HTTP 打开，它负责把请求带入对应的漏洞场景；</li>
<li><code>Logic</code>：业务场景封装层，存放 Service 的一些东西，把 Controller 参数变成底层可执行的动作；</li>
<li><code>Dao</code>：数据访问层，做数据持久化，方法针对数据库操作；</li>
<li><code>Mapper</code>：MyBatis Mapper 接口层，存放 MyBatis 的接口定义；</li>
<li><code>data</code>：数据模型 实体层 对应数据库表或接口数据结构；</li>
</ul>
<h3 id="部署搭建记录"><a href="#部署搭建记录" class="headerlink" title="部署搭建记录"></a>部署搭建记录</h3><p>首先选择新建项目：</p>
<p><img src="/../uploads/java_range1.png"></p>
<p>通过Springboot Initializr初始化项目:</p>
<p><img src="/../uploads/java_range2.png"></p>
<p>选择相关依赖：</p>
<p><img src="/../uploads/java_range3.png"></p>
<p>初始化项目结构如下：</p>
<p><img src="/../uploads/java_range4.png"></p>
<p>依赖还是存在一些问题，因为靶场对应的是Java1.8版本，但是IDEA创建project时只有17、21和25可选项（这个应该有办法解决，后续再搞），不过目前已经清楚了Springboot的架构是什么样子。</p>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="db-IndexDb-java"><a href="#db-IndexDb-java" class="headerlink" title="db&#x2F;IndexDb.java"></a>db&#x2F;IndexDb.java</h3><p><code>IndexDb.java</code> 是一个基于 <code>JdbcTemplate</code> 的数据库访问类，负责从 students 和 teachers 表中查询数据，同时为了漏洞靶场演示，刻意使用字符串拼接 SQL，存在明显的 SQL 注入风险。</p>
<p>详细解读：</p>
<ul>
<li><p>被标记为 @Repository，供其他层（如 IndexLogic &#x2F; Controller）注入使用。</p>
</li>
<li><p>内部定义了两个 RowMapper，把查询结果映射成 Student 和 Teacher 对象。</p>
</li>
<li><p>提供多种查询方法：</p>
<ol>
<li><p>按用户名模糊查询学生：getStudent &#x2F; getStudentWithOptional</p>
</li>
<li><p>按 id 查询学生：getStudentById</p>
</li>
<li><p>按 id 查询教师：getTeacherById</p>
</li>
<li><p>使用 IN 条件批量用户名查询学生：getStudentWithIn &#x2F; getStudentWithInLong</p>
</li>
</ol>
</li>
</ul>
<p>所有 SQL 都是直接拼接字符串（包括 Optional、List 的拼接）作为靶场中演示 SQL 注入的重要部分。截取部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexDb</span></span><br><span class="line"><span class="comment"> * 使用 Spring 的 JdbcTemplate 直接操作数据库的仓库类。</span></span><br><span class="line"><span class="comment"> * 主要提供针对 students / teachers 表的查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：本类为了配合“Java 漏洞靶场”，大量使用字符串拼接构造 SQL，</span></span><br><span class="line"><span class="comment"> *       实际上存在典型的 SQL 注入风险，用于安全演示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexDb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring 注入 JdbcTemplate，用于执行 SQL 语句</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Student 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Student&gt; ROW_MAPPER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        student.setSex(rs.getInt(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        student.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Teacher 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Teacher&gt; ROW_MAPPER_TEACHER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        teacher.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        teacher.setSex(rs.getBoolean(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        teacher.setName(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生信息。</span></span><br><span class="line"><span class="comment">     * 漏洞点：直接拼接 username 到 SQL 中，存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 安全写法示例（被注释掉）：使用占位符并绑定参数</span></span><br><span class="line">        <span class="comment">// String sql = &quot;select * from students where username like ?&quot;;</span></span><br><span class="line">        <span class="comment">// return jdbcTemplate.query(sql, new Object[]&#123;&quot;%&quot; + username + &quot;%&quot;&#125;, ROW_MAPPER);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名进行模糊查询。</span></span><br><span class="line"><span class="comment">     * 实际上仍然是字符串拼接，同样存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithOptional</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username.get() + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 id 精确查询学生。</span></span><br><span class="line"><span class="comment">     * 漏洞点：将 id 转成字符串再拼接到 SQL 中，存在注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithInt</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where id = &#x27;&quot;</span> + String.valueOf(id) + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithInt, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="logic-IndexLogic-java"><a href="#logic-IndexLogic-java" class="headerlink" title="logic&#x2F;IndexLogic.java"></a>logic&#x2F;IndexLogic.java</h3><p><code>IndexLogic.java</code> 本质上是<strong>Service 层的一个浅封装</strong>：</p>
<ul>
<li>用 <code>@Service</code> 标记，表示这是业务逻辑层的 Bean；</li>
<li>通过 <code>@Autowired</code> 注入 <code>IndexDb</code>（4.1节对应的那个数据库访问类）；</li>
<li>对外提供一组方法：<code>getStudent</code> &#x2F; <code>getStudentById</code> &#x2F; <code>getStudentWithOptional</code> &#x2F; <code>getStudentWithIn</code> &#x2F; <code>getStudentWithInLong</code> &#x2F; <code>getTeacherById</code>；</li>
<li>每个方法都<strong>直接把参数原样转发给 <code>IndexDb</code>，不做额外处理</strong>，相当于“转发层”；</li>
<li>因为 <code>IndexDb</code> 里面的 SQL 是拼接的，所以这些 Service 方法也就“顺带”暴露出 SQL 注入漏洞场景，方便 Controller 调用。</li>
</ul>
<p>可以理解为：<br><strong>Controller -&gt; IndexLogic -&gt; IndexDb -&gt; Databases</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexLogic</span></span><br><span class="line"><span class="comment"> * 业务逻辑层（Service），对外提供学生 / 老师相关的查询接口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当前实现非常薄，只是简单地把调用转发给 IndexDb，</span></span><br><span class="line"><span class="comment"> * 主要起到：Controller 与 DB 操作之间的“中间层”作用，</span></span><br><span class="line"><span class="comment"> * 方便保持三层架构的结构清晰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于底层 IndexDb 使用字符串拼接 SQL，</span></span><br><span class="line"><span class="comment"> * 这些方法实际也用于配合漏洞靶场演示 SQL 注入场景。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexLogic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入数据库访问类 IndexDb</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IndexDb indexDb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudent(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithOptional(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（字符串列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithIn</span><span class="params">(List&lt;String&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithIn(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（Long 列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithInLong</span><span class="params">(List&lt;Long&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithInLong(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据“id/userName”查询老师</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getTeacherById</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getTeacherById(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IndexLogic 是 Controller 和 IndexDb 之间的桥梁，把各种查询操作组织成业务接口，方便暴露为 HTTP 靶场接口。</strong></p>
<hr>
<h3 id="mapper-IStudentMapper-java"><a href="#mapper-IStudentMapper-java" class="headerlink" title="mapper&#x2F;IStudentMapper.java"></a>mapper&#x2F;IStudentMapper.java</h3><p>IStudentMapper 是 students 表的 MyBatis 接口，其中 <code>queryAllByAnnotations</code> 用注解 + <code>$&#123;&#125;</code> 拼串，专门用来检测注解式 SQL 注入漏洞。</p>
<p>Mapper <strong>≈</strong> 映射器，他的作用是把 “Java 方法调用” 映射成 “SQL 语句执行”，再把结果映射回 Java 对象。也可以称为“MyBatis 帮忙自动实现的 DAO 接口”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IStudentMapper</span></span><br><span class="line"><span class="comment"> * MyBatis 的 Mapper 接口，对 students 表提供查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个接口有两个目的：</span></span><br><span class="line"><span class="comment"> * 1）正常的查询方法（queryAll），SQL 通常写在 XML 中；</span></span><br><span class="line"><span class="comment"> * 2）使用注解 + $&#123;&#125; 拼接参数的方式，故意制造 SQL 注入漏洞，</span></span><br><span class="line"><span class="comment"> *    用于测试代码扫描工具是否能识别注解里的注入问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一：常规查询方法</span></span><br><span class="line"><span class="comment">     * SQL 写在 resources/mappers/IStudentMapper.xml 中，</span></span><br><span class="line"><span class="comment">     * 一般会使用 #&#123;name&#125; 这种占位符，属于参数绑定写法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAll</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式二：注解式 SQL，故意使用 $&#123;&#125; 直接拼接参数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里的 SQL：</span></span><br><span class="line"><span class="comment">     *   select * from students where username =&#x27;$&#123;name&#125;&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * $&#123;name&#125; 会被原样替换到 SQL 中，存在明显的 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     * 这是靶场中专门用来测试“静态扫描工具能否发现注解里的 SQL 注入”的例子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from students where username =&#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAllByAnnotations</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="data-Person-java"><a href="#data-Person-java" class="headerlink" title="data&#x2F;Person.java"></a>data&#x2F;Person.java</h3><p>data 文件夹下专门存放了“数据模型”，可以保存数据库和业务里的“实体对象”。同时作为各个层次之间传递数据的载体：</p>
<ul>
<li><p>db&#x2F;IndexDb 查出来的是 List<Student>、List<Teacher></p>
</li>
<li><p>logic&#x2F;IndexLogic 接收&#x2F;返回的也是这些对象</p>
</li>
<li><p>Controller 对外返回的 JSON，其实就是把这些 data 类序列化出去</p>
</li>
</ul>
<p>👉 这样 Controller、Service、DAO 都围绕同一套“数据结构”在交流。</p>
<p>Person 是用 JPA+Hibernate 映射出来的人员表实体，用 UUID 当主键，并强制 username 和 nickname 的唯一性与非空约束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person 实体类：</span></span><br><span class="line"><span class="comment"> * 映射数据库中的 person 表（默认表名），</span></span><br><span class="line"><span class="comment"> * 使用 UUID 作为主键，包含唯一且必填的 username / nickname 字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主键 ID，使用自定义的 UUID 生成策略</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(generator = &quot;idGenerator&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 昵称列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;nickname&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dao-PersonRepository-java"><a href="#dao-PersonRepository-java" class="headerlink" title="dao&#x2F;PersonRepository.java"></a>dao&#x2F;PersonRepository.java</h3><p><code>PersonRepository</code> 是一个基于 Spring Data JPA 的 DAO 接口，负责对 Person 实体做数据库查询：根据 username 和 nickname 查人，供 Controller 或 Service 调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersonRepository</span></span><br><span class="line"><span class="comment"> * 基于 Spring Data JPA 的 DAO 接口，</span></span><br><span class="line"><span class="comment"> * 用于对 Person 实体进行数据库访问操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过继承 JpaRepository，可以直接使用通用的增删改查方法，</span></span><br><span class="line"><span class="comment"> * 同时也可以定义派生查询方法或自定义 <span class="doctag">@Query</span> 查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Person, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Spring Data JPA 的“方法名派生查询”功能，</span></span><br><span class="line"><span class="comment">     * 根据 username 字段查询 Person 列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 等价于：SELECT p FROM Person p WHERE p.username = ?1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 <span class="doctag">@Query</span> 手写 JPQL 查询，根据 nickname 查询。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT nickname FROM Person WHERE nickname = &#x27;?1&#x27;&quot;)</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByNickname</span><span class="params">(String nickname)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="controller-VulnerabilitiesController-java"><a href="#controller-VulnerabilitiesController-java" class="headerlink" title="controller&#x2F;VulnerabilitiesController.java"></a>controller&#x2F;VulnerabilitiesController.java</h3><p><code>controller</code> 文件夹用来存放项目里的控制器类，也就是对外暴露 HTTP 接口的那一层。在 Spring Boot 里，Controller 负责接收浏览器或工具（如 Postman、burp）的请求，解析参数，把请求转交给逻辑层（logic&#x2F;service），再把返回结果封装成 JSON 或页面响应。</p>
]]></content>
      <categories>
        <category>Java Security</category>
      </categories>
      <tags>
        <tag>Java Security</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（一）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-概念"><a href="#MCP-概念" class="headerlink" title="MCP 概念"></a>MCP 概念</h2><p>MCP 编程快速入门，MCP 全称 Model Context Protocol 模型上下文协议，其定义了 LLMs 与外部世界的互动方式，MCP 提供了一种标准化方法，使任意 LLMs 能够轻松连接各种数据源和工具，实现信息的高效交互和处理。</p>
<p>目前的 AI 朝着两个方向发展：<strong>掌握更多信息</strong> 或 <strong>控制更多工具</strong>，在没有联网搜索之前，LLM 的数据来源只有训练时和推理时我们提供的数据。</p>
<p>在MCP出现之前，如果LLM要访问外部数据，通常使用<code>Function Call</code>的方式，<code>Function Call</code>通过给模型预设函数描述（包括函数名、参数说明、返回值格式等），让模型在合适的时候返回一个符合结构的 JSON 格式，外部系统再解析这个 JSON，调用实际的后端函数。关于 <code>Function Call</code> 和<code>MCP</code> 的具体区别在 <a href="/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Function Call和MCP的区别">Function Call和MCP的区别</a></p>
<p>但 <code>Function Call</code> 的方式没有一个统一的开发规范，你开发的函数我不能用，我开发的函数你不能用，而且开发起来很麻烦，为了解决这个问题，MCP 出现了。MCP作为LLMs的标准化工具箱，可以通过MCP调用外界的AI工具，而AI工具在开发的时候也需要遵循MCP协议。MCP 允许应用以标准化的方式向 LLM 提供上下文，并将<strong>提供上下文的逻辑</strong>与<strong>实际的LLM交互逻辑”</strong>解耦。</p>
<p>在没有 MCP 之前，如果我们希望让模型使用本地数据，通常需要把这些数据直接复制到对话框中，让模型从文本中获取信息。而有了 MCP 之后，我们可以为特定能力编写一个 MCP Server，例如数据库读取、GitHub 操作、文件系统访问或获取当前时间等。模型通过 MCP 与这些 Server 通信，就能在无需手动粘贴数据的情况下，实时访问这些外部资源。</p>
<p><img src="/../uploads/MCP_1.png"></p>
<p>MCP 服务器可以提供三种主要类型的功能:</p>
<ol>
<li>资源访问：客户端读取文件等数据；</li>
<li>工具调用：由LLM调用的函数；</li>
<li>Prompt模板：预先编写的帮助客户完成特定任务的Prompt；</li>
</ol>
<span id="more"></span>

<h2 id="MCP-Deno-开发"><a href="#MCP-Deno-开发" class="headerlink" title="MCP Deno 开发"></a>MCP Deno 开发</h2><p>使用python的SDK，简单实现下面功能，用来加深理解：</p>
<ol>
<li>构建可连接到任何 MCP Server 的 MCP Client</li>
<li>创建公开资源、提示和工具的 MCP Server</li>
<li>使用 stdio 和 SSE 等标准传输</li>
<li>处理所有 MCP 协议消息和生命周期事件</li>
</ol>
<p>一般关于MCP的项目，开发者们都喜欢用uv来管理，不晓得为什么，但是跟着用一下，相关安装使用方法参照 <a href="/2025/12/10/uv%E4%BD%BF%E7%94%A8/" title="uv使用">uv使用</a> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的项目</span></span><br><span class="line">uv init mcp-demo</span><br><span class="line"><span class="built_in">cd</span> mcp-demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">uv venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">uv add <span class="string">&quot;mcp[cli]&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这样一个uv管理的python MCP 项目就初始化完成了。</p>
<p>接下来编写第一个简单Demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 FastMCP 实例</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例工具</span></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例资源</span></span><br><span class="line"><span class="meta">@mcp.resource(<span class="params"><span class="string">&quot;greeting://&#123;name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;FastMCP Demo Server is running ......&quot;</span>)</span><br><span class="line">    mcp.run()</span><br></pre></td></tr></table></figure>

<p>示例代码中，使用了FastMCP来初始化一个MCP Server实例，分别创建了三个函数：</p>
<ul>
<li>echo：字符串输出；</li>
<li>add：两个数字相加；</li>
<li>greet：输入字符串，拼接后返回字符串；</li>
</ul>
<p>通过两个注解，赋予了函数不同的能力：</p>
<ul>
<li>@tool()：函数可以直接被AI调用；</li>
<li>@resource()：像API接口一样被调用，其中的参数 greeting:&#x2F;&#x2F;{name} 是一个自定义的 URI， 可以拆解为两个部分。greeting 是随便起的前缀，name是动态参数的名称，在访问的时候需要传入。</li>
</ul>
<p>测试命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mcp dev server.py</span><br></pre></td></tr></table></figure>

<p><code>mcp dev</code>是开发调试模式，输入这条命令后，会打开一个 MCP Inspector ，可以直观地检查和测试 MCP Server（server.py）是否正常工作。</p>
<p><img src="/../uploads/MCP_2.png"></p>
<p>点击 Connect ，选择 Tools，List Tools，即可列出 MCP 中定义的工具，可以输入测试内容进行 run tools测试:</p>
<p><img src="/../uploads/MCP_3.png"></p>
<p>在 Resources 标签页下，可以看到定义的资源函数 greet:</p>
<p><img src="/../uploads/MCP_4.png"></p>
<p>传入动态参数，mcp server 就会返回 json 格式的响应，并将我们输入的 api 拼接后返回。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>博客记录了对于 MCP 的理解，以及一个简单的Demo，后续在这个基础上继续完善。</p>
<p>对 MCP Server 的开发是 MCP应用的重点，作者提到 MCP Server 其实就是定义一些函数，让智能体调用。在函数中可以实现简单逻辑、接口调用和各种操作，并通过注解赋予函数不同的能力。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>什么是MCP？本地如何开发MCP Server：<a href="https://cloud.tencent.com/developer/article/2511642">https://cloud.tencent.com/developer/article/2511642</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（二）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="模型如何确定工具选用？"><a href="#模型如何确定工具选用？" class="headerlink" title="模型如何确定工具选用？"></a>模型如何确定工具选用？</h2><p>Anthropic 详细解释了这个问题：模型在什么时候确定使用哪些工具。</p>
<p>当用户提出一个问题时：</p>
<ol>
<li>客户端（Claude Desktop &#x2F; Cursor）将问题发送给 Claude；</li>
<li>Claude 分析可用的工具，并决定使用哪一个（或多个）；</li>
<li>客户端通过 MCP Server 执行所选的工具；</li>
<li>工具的执行结果被送回给 Claude；</li>
<li>Claude 结合执行结果构造最终的 prompt 并生成自然语言的回应；</li>
<li>回应最终展示给用户！</li>
</ol>
<p>MCP Server 是由 Claude 主动选择并调用的，这个主动选择的过程可以分为两步：</p>
<ol>
<li>由 LLM（Claude）确定使用哪些 MCP Server；</li>
<li>执行对应的 MCP Server 并对执行结果进行重新处理；</li>
</ol>
<p>MCP 流程图如下：</p>
<p><img src="/../uploads/MCP_11.jpg"></p>
<p>流程图展示了 LLM 在接收到用户输入后，根据系统提示中提供的指令与工具描述，决定是否需要调用外部工具（包括 MCP Server 提供的工具）。<br>首先，用户输入与系统 prompt（包含工具的结构化描述）一同交给模型生成 Message1。如果模型判断某个任务需要借助工具完成（Case 1），它会生成一段结构化的 Tool call JSON，并由外部执行环境或 MCP Server 负责实际执行工具逻辑。执行结果再返回给模型，模型基于这份结果生成最终回答；<br>如果模型判断不需要工具（Case 2），则直接生成最终输出。<br>整个流程体现了：LLM 负责“决定用什么工具及如何调用”，而 MCP Servers 等外部系统负责“实际执行任务并返回数据”，从而实现模型与外部能力的协作。</p>
<span id="more"></span>

<h2 id="模型如何智能选择工具？"><a href="#模型如何智能选择工具？" class="headerlink" title="模型如何智能选择工具？"></a>模型如何智能选择工具？</h2><p>模型如何确定该使用哪些工具，MCP 官方提供的 client example 示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="comment"># 初始化所有的 mcp server</span></span><br><span class="line">     <span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable language_">self</span>.servers:</span><br><span class="line">         <span class="keyword">await</span> server.initialize()</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 获取所有的 tools 命名为 all_tools</span></span><br><span class="line">     all_tools = []</span><br><span class="line">     <span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable language_">self</span>.servers:</span><br><span class="line">         tools = <span class="keyword">await</span> server.list_tools()</span><br><span class="line">         all_tools.extend(tools)</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 将所有的 tools 的功能描述格式化成字符串供 LLM 使用</span></span><br><span class="line">     <span class="comment"># tool.format_for_llm() 我放到了这段代码最后，方便阅读。</span></span><br><span class="line">     <span class="comment"># 为 LLM 生成工具说明文档，告诉模型：有哪些工具、各自干啥、要什么参数。</span></span><br><span class="line">     tools_description = <span class="string">&quot;\n&quot;</span>.join(</span><br><span class="line">         [tool.format_for_llm() <span class="keyword">for</span> tool <span class="keyword">in</span> all_tools]</span><br><span class="line">     )</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 这里就不简化了，以供参考，实际上就是基于 prompt 和当前所有工具的信息</span></span><br><span class="line">     <span class="comment"># 询问 LLM（Claude） 应该使用哪些工具。</span></span><br><span class="line">     system_message = (</span><br><span class="line">         <span class="string">&quot;You are a helpful assistant with access to these tools:\n\n&quot;</span></span><br><span class="line">         <span class="string">f&quot;<span class="subst">&#123;tools_description&#125;</span>\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span></span><br><span class="line">         <span class="string">&quot;If no tool is needed, reply directly.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span></span><br><span class="line">         <span class="string">&quot;the exact JSON object format below, nothing else:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">         <span class="string">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\n&#x27;</span></span><br><span class="line">         <span class="string">&#x27;    &quot;arguments&quot;: &#123;\n&#x27;</span></span><br><span class="line">         <span class="string">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\n&#x27;</span></span><br><span class="line">         <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;&#125;\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;After receiving a tool&#x27;s response:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;1. Transform the raw data into a natural, conversational response\n&quot;</span></span><br><span class="line">         <span class="string">&quot;2. Keep responses concise but informative\n&quot;</span></span><br><span class="line">         <span class="string">&quot;3. Focus on the most relevant information\n&quot;</span></span><br><span class="line">         <span class="string">&quot;4. Use appropriate context from the user&#x27;s question\n&quot;</span></span><br><span class="line">         <span class="string">&quot;5. Avoid simply repeating the raw data\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Please use only the tools that are explicitly defined above.&quot;</span></span><br><span class="line">     )</span><br><span class="line">     messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_message&#125;]</span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="comment"># Final... 假设这里已经处理了用户消息输入.</span></span><br><span class="line">         messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 将 system_message 和用户消息输入一起发送给 LLM</span></span><br><span class="line">         llm_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line"> ​</span><br><span class="line">     ... <span class="comment"># 后面和确定使用哪些工具无关</span></span><br><span class="line">     </span><br><span class="line"> ​</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Represents a tool with its properties and formatting.&quot;&quot;&quot;</span></span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">         self, name: <span class="built_in">str</span>, description: <span class="built_in">str</span>, input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span></span><br><span class="line"><span class="params">     </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">         <span class="variable language_">self</span>.name: <span class="built_in">str</span> = name</span><br><span class="line">         <span class="variable language_">self</span>.description: <span class="built_in">str</span> = description</span><br><span class="line">         <span class="variable language_">self</span>.input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = input_schema</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 把工具的名字 / 工具的用途（description）和工具所需要的参数（args_desc）转化为文本</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">format_for_llm</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">         <span class="string">&quot;&quot;&quot;Format tool information for LLM.</span></span><br><span class="line"><span class="string"> ​</span></span><br><span class="line"><span class="string">         Returns:</span></span><br><span class="line"><span class="string">             A formatted string describing the tool.</span></span><br><span class="line"><span class="string">         &quot;&quot;&quot;</span></span><br><span class="line">         args_desc = []</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&quot;properties&quot;</span> <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema:</span><br><span class="line">             <span class="keyword">for</span> param_name, param_info <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema[<span class="string">&quot;properties&quot;</span>].items():</span><br><span class="line">                 arg_desc = (</span><br><span class="line">                     <span class="string">f&quot;- <span class="subst">&#123;param_name&#125;</span>: <span class="subst">&#123;param_info.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;No description&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line">                 )</span><br><span class="line">                 <span class="keyword">if</span> param_name <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema.get(<span class="string">&quot;required&quot;</span>, []):</span><br><span class="line">                     arg_desc += <span class="string">&quot; (required)&quot;</span></span><br><span class="line">                 args_desc.append(arg_desc)</span><br><span class="line"> ​</span><br><span class="line">         <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> Tool: <span class="subst">&#123;self.name&#125;</span></span></span><br><span class="line"><span class="string"> Description: <span class="subst">&#123;self.description&#125;</span></span></span><br><span class="line"><span class="string"> Arguments:</span></span><br><span class="line"><span class="string"> <span class="subst">&#123;<span class="built_in">chr</span>(<span class="number">10</span>).join(args_desc)&#125;</span></span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>模型会通过 Prompt 来确定当前有哪些工具，通过将工具的具体使用描述以文本的形式传递给模型，供模型了解有哪些工具以及结合实时情况进行选择。</p>
<blockquote>
<p><strong>从所有 MCP Server 中“收集工具 → 转成给 LLM 看得懂的文字说明 → 拼到 system prompt 里 → 让 LLM 根据这些工具描述来决定要不要调用工具、调用哪个工具。</strong></p>
</blockquote>
<p>在整个 MCP 的大图景里，这段代码扮演的是<strong>中间协调者 &#x2F; 适配层</strong>：</p>
<ol>
<li>对下游（MCP Servers）</li>
</ol>
<ul>
<li><p>负责初始化所有 MCP Server</p>
</li>
<li><p>通过 list_tools() 探测每个 server 暴露的工具</p>
</li>
<li><p>把工具的 JSON Schema 等结构化信息，抽象成 Tool 对象</p>
</li>
</ul>
<ol start="2">
<li>对上游（LLM）</li>
</ol>
<ul>
<li><p>把所有工具信息整合并转成人类语言说明（format_for_llm）</p>
</li>
<li><p>把说明塞进 system prompt，告诉 LLM 它有哪些能力可以用</p>
</li>
<li><p>通过严格的 JSON 格式约束，让 LLM 以稳定可解析的方式返回“我要用哪个工具+参数”</p>
</li>
</ul>
<ol start="3">
<li>对中间逻辑（Router &#x2F; Orchestrator）</li>
</ol>
<ul>
<li><p>后续根据 LLM 的工具选择 JSON 再去调用相应 MCP server 的 tool</p>
</li>
<li><p>把结果反馈给 LLM，让它生成自然语言答复</p>
</li>
</ul>
<blockquote>
<p><strong>它让“多 MCP Server 的工具”对 LLM 看起来像一组统一、清晰、可选择的工具菜单。</strong></p>
</blockquote>
<h2 id="工具执行和结果反馈机制"><a href="#工具执行和结果反馈机制" class="headerlink" title="工具执行和结果反馈机制"></a>工具执行和结果反馈机制</h2><p>工具的执行就是把 system prompt 指令和工具调用描述，还有用户消息一起发送给模型，然后接收模型的回复。当模型分析用户请求后，它会决定是否需要调用工具。如果回复中包含结构化 json 格式的工具调用请求，则客户端会根据这个 json 代码执行对应的工具。</p>
<p>如果模型执行了 tool call，则工具执行的结果 result 会和 system prompt 和用户消息一起重新发送给模型，请求模型生成最终回复。同时，如果 tool call 的 json 代码存在问题或者模型产生了幻觉，那么系统会 skip 掉无效的调用请求。</p>
<p>工具执行的相关代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">     ... <span class="comment"># 上面已经介绍过了，模型如何选择工具</span></span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="comment"># 假设这里已经处理了用户消息输入.</span></span><br><span class="line">         messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 获取 LLM 的输出</span></span><br><span class="line">         llm_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 处理 LLM 的输出（如果有 tool call 则执行对应的工具）</span></span><br><span class="line">         result = <span class="keyword">await</span> <span class="variable language_">self</span>.process_llm_response(llm_response)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 如果 result 与 llm_response 不同，说明执行了 tool call （有额外信息了）</span></span><br><span class="line">         <span class="comment"># 则将 tool call 的结果重新发送给 LLM 进行处理。</span></span><br><span class="line">         <span class="keyword">if</span> result != llm_response:</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: result&#125;)</span><br><span class="line"> ​</span><br><span class="line">             final_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line">             logging.info(<span class="string">&quot;\nFinal response: %s&quot;</span>, final_response)</span><br><span class="line">             messages.append(</span><br><span class="line">                 &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: final_response&#125;</span><br><span class="line">             )</span><br><span class="line">         <span class="comment"># 否则代表没有执行 tool call，则直接将 LLM 的输出返回给用户。</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: llm_response&#125;) </span><br></pre></td></tr></table></figure>

<p>两个要点：</p>
<ol>
<li>工具对应的文档很重要： 模型通过工具描述文本来理解和选择工具，因此精心编写工具的名称、docstring 和参数说明至关重要；</li>
<li>由于 MCP 的选择是基于 prompt 的，所以任何模型其实都适配 MCP，只要能提供对应的工具描述。但是当你使用非 Claude 模型时，MCP 使用的效果和体验难以保证（没有做专门的训练，这个不太确定，后续需要测试一下）。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><strong>MCP 的本质</strong>：它是一个统一的协议标准，使 AI 模型能够以一致的方式连接各种数据源和工具，类似于 AI 世界的”USB-C”接口。</li>
<li><strong>MCP 的价值</strong>：它解决了传统 function call 的平台依赖问题，提供了更统一、开放、安全、灵活的工具调用机制，让用户和开发者都能从中受益。</li>
<li>使用与开发：对于普通用户，MCP 提供了丰富的现成工具，用户可以在不了解任何技术细节的情况下使用；对于开发者，MCP 提供了清晰的架构和 SDK，使工具开发变得相对简单。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>MCP(Model Context Protocol)一篇就够了：<a href="https://zhuanlan.zhihu.com/p/29001189476">https://zhuanlan.zhihu.com/p/29001189476</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（三）</title>
    <url>/2025/12/12/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-Server-开发实践"><a href="#MCP-Server-开发实践" class="headerlink" title="MCP Server 开发实践"></a>MCP Server 开发实践</h2><p>对于大部分 AI 开发者来说，MCP 只需要关心 Server 的实现，通过一个简单示例学习如何实现一个 MCP Server。</p>
<p>MCP Server 可以提供三种主要类型的功能：</p>
<ul>
<li>Resources（资源）：类似文件的数据，可以被客户端读取；</li>
<li>Tools（工具）：可以被LLM调用的函数；</li>
<li>Prompt（提示）：预先编写的模版，帮助用户完成特定任务；</li>
</ul>
<p>任务：使用Python实现一个MCP Server，用来统计当前桌面上的 txt 文件数量和获取对应文件的名字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MCP Server</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;桌面 TXT 文件统计器&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_desktop_txt_files</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Count the number of .txt files on the desktop.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Get the desktop path</span></span><br><span class="line">    username = os.getenv(<span class="string">&quot;USER&quot;</span>) <span class="keyword">or</span> os.getenv(<span class="string">&quot;USERNAME&quot;</span>)</span><br><span class="line">    desktop_path = Path(<span class="string">f&quot;C:\\Users\\<span class="subst">&#123;username&#125;</span>\\Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Count .txt files</span></span><br><span class="line">    txt_files = <span class="built_in">list</span>(desktop_path.glob(<span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(txt_files)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_desktop_txt_files</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get a list of all .txt filenames on the desktop.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Get the desktop path</span></span><br><span class="line">    username = os.getenv(<span class="string">&quot;USER&quot;</span>) <span class="keyword">or</span> os.getenv(<span class="string">&quot;USERNAME&quot;</span>)</span><br><span class="line">    desktop_path = Path(<span class="string">f&quot;C:\\Users\\<span class="subst">&#123;username&#125;</span>\\Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get all .txt files</span></span><br><span class="line">    txt_files = <span class="built_in">list</span>(desktop_path.glob(<span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the filenames</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> txt_files:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No .txt files found on desktop.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Format the list of filenames</span></span><br><span class="line">    file_list = <span class="string">&quot;\n&quot;</span>.join([<span class="string">f&quot;- <span class="subst">&#123;file.name&#125;</span>&quot;</span> <span class="keyword">for</span> file <span class="keyword">in</span> txt_files])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(txt_files)&#125;</span> .txt files on desktop:\n<span class="subst">&#123;file_list&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Initialize and run the server</span></span><br><span class="line">    mcp.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MCP-Server-测试"><a href="#MCP-Server-测试" class="headerlink" title="MCP Server 测试"></a>MCP Server 测试</h3><p>测试 MCP Server， <code>mcp dev server.py</code> ，进行服务测试。</p>
<p><img src="/../uploads/MCP_12.png"></p>
<p>如图所示，成功生成了对应的 Tool Result ，即为测试成功。</p>
<h3 id="接入-Claude-Desktop"><a href="#接入-Claude-Desktop" class="headerlink" title="接入 Claude Desktop"></a>接入 Claude Desktop</h3><p>这里 Claude Desktop 注册时需要手机号绑定，目前没有外国手机号，所以找了个平替的平台 Trae。</p>
<p>配置文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server_txt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\77319\\.local\\bin\\uv.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--directory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;D:\\Code\\mcp-demo&quot;</span><span class="punctuation">,</span> <span class="comment">// 你的项目路径（这里是我的）</span></span><br><span class="line">        <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;server_txt.py&quot;</span> <span class="comment">// 你的 MCP Server 文件名</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>手动添加 MCP 配置：</p>
<p><img src="/../uploads/MCP_13.png"></p>
<p>选择 MCP ：</p>
<p><img src="/../uploads/MCP_14.png"></p>
<p>提出问题：帮我分析桌面txt文件的含义</p>
<p>思考过程：</p>
<p>用户让我推测桌面txt文件名的含义，之前已经通过MCP工具获取到桌面上有3个txt文件：</p>
<ul>
<li>3.多模态信息融合.txt</li>
<li>API Key.txt</li>
<li>密码本.txt<br>我需要基于文件名来推测它们的含义，不需要查看文件内容。让我分析每个文件名：</li>
</ul>
<ol>
<li><p>“3.多模态信息融合.txt”：</p>
<ul>
<li>“3.” 可能表示这是一系列文件中的第3个</li>
<li>“多模态信息融合” 是一个专业术语，通常指将不同类型的数据（如文本、图像、音频等）结合起来进行分析和处理</li>
<li>这个文件可能包含关于多模态信息融合技术的笔记、研究或资料</li>
</ul>
</li>
<li><p>“API Key.txt”：</p>
<ul>
<li>“API Key” 是应用程序接口密钥的缩写，用于身份验证和授权</li>
<li>这个文件可能包含各种服务或平台的API密钥</li>
</ul>
</li>
<li><p>“密码本.txt”：</p>
<ul>
<li>“密码本” 通常指存储密码的文档</li>
<li>这个文件可能包含各种账户的用户名和密码信息</li>
</ul>
</li>
</ol>
<p>我需要将这些分析整理成一个清晰的回应。</p>
<p>回复内容：</p>
<p>基于之前获取的桌面上的txt文件名，我可以推测它们的含义。让我分析每个文件名并提供合理的解释。基于桌面txt文件名，我可以做出以下推测：</p>
<ol>
<li><p><strong>3.多模态信息融合.txt</strong></p>
<ul>
<li>“3.” 可能表示这是一系列相关文件中的第3个</li>
<li>“多模态信息融合” 是人工智能领域的专业术语，指将不同类型的数据（如文本、图像、音频、视频等）结合起来进行分析和处理的技术</li>
<li>这个文件很可能包含关于多模态信息融合技术的研究资料、学习笔记或项目文档</li>
</ul>
</li>
<li><p><strong>API Key.txt</strong></p>
<ul>
<li>“API Key”（应用程序接口密钥）是用于身份验证和授权的安全凭证</li>
<li>这个文件可能存储了各种在线服务、开发平台或应用程序的API密钥，方便用户在开发或使用相关服务时快速获取</li>
</ul>
</li>
<li><p><strong>密码本.txt</strong></p>
<ul>
<li>“密码本” 是一个常见的术语，指专门用于记录密码的文档</li>
<li>这个文件很可能包含了用户在各种网站、应用程序或服务上的账户名称和对应的密码信息，用于集中管理和记忆</li>
</ul>
</li>
</ol>
<p>这些文件都与数字信息管理和技术相关，可能是用户在学习、工作或日常使用计算机时创建的重要参考文档。</p>
<p>上述结果表明 MCP Server 已经可以正常工作。</p>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>OSCP学习心得</title>
    <url>/2025/12/12/OSCP%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>在 OSCP 的学习和练习以及打靶场或者渗透测试过程中，我认为本质上不是掌握了多少工具，而是在规定时间内，能不能把渗透的全流程跑完，关键步骤上思维能否发散，能否有较为全面的思考和枚举，所以重心还是在思路上，渗透的思路和应对关键点时的经验，所以记录一些自己的思考。</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>重点在于覆盖面和可用性：</p>
<ul>
<li>覆盖面：全端口（服务）扫描，不要漏掉服务，不然可能会找不到正确的入口点；</li>
<li>可用性：不同服务、版本都有什么漏洞，是否具备利用条件，无法利用的话是不是加了什么限制，是需要绕过限制还是需要转变路径，这些属于能否实现利用的范畴；</li>
</ul>
<blockquote>
<p><strong>信息收集要得出一个结论：我到底能打哪些入口？哪些入口最可能实现边界突破？</strong></p>
</blockquote>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞利用阶段不要盲目跑exp，最好是先验证控制程度，再拿shell。</p>
<p>先确定漏洞是否真实存在，漏洞可控点在哪里，输入如何影响输出，然后再确认控制深度（能否读写文件&#x2F;命令执行&#x2F;鉴权绕过），最后在拿稳定shell。</p>
<blockquote>
<p><strong>先看能不能验证清楚，在考虑能否一步到位。</strong></p>
</blockquote>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>提权并没有深入学习太多，但是感觉应该在于找到“权限边界被破坏”的证据，可以根据历史经验寻找线索，找到稳定可复现的思路。</p>
<h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><blockquote>
<p><strong>信任关系+凭证流向</strong>: 从以控制主机把影响力扩到更有价值的主机&#x2F;账号&#x2F;网段等。</p>
</blockquote>
<hr>
<p>⭐<strong>持续更新 To be continued……</strong></p>
]]></content>
      <categories>
        <category>OSCP</category>
      </categories>
      <tags>
        <tag>OSCP</tag>
        <tag>Penetration Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu通过Ollama部署LLM</title>
    <url>/2025/12/18/Ubuntu%E9%80%9A%E8%BF%87Ollama%E9%83%A8%E7%BD%B2LLM/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Ubuntu 24.04<br>python 3.12.3<br>ollama 0.13.4<br>git 2.43.0</p>
<p>换源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/apt/sources.list.d/ubuntu.sources</span><br><span class="line"></span><br><span class="line">Types: deb</span><br><span class="line">URIs: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-backports</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line">Types: deb</span><br><span class="line">URIs: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="line">Suites: noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Ollama-安装"><a href="#Ollama-安装" class="headerlink" title="Ollama 安装"></a>Ollama 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"></span><br><span class="line">ollama --version</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl start ollama</span><br><span class="line"></span><br><span class="line">systemctl status ollama</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ollama</span><br></pre></td></tr></table></figure>

<h2 id="Ollama-命令一览表"><a href="#Ollama-命令一览表" class="headerlink" title="Ollama 命令一览表"></a>Ollama 命令一览表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>常见使用场景 &#x2F; 示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ollama serve</code></td>
<td>启动 Ollama 后台服务</td>
<td>作为 daemon 运行（一般系统已自动启动）<br><code>ollama serve</code></td>
</tr>
<tr>
<td><code>ollama create</code></td>
<td>创建自定义模型</td>
<td>基于 Modelfile 定制模型（prompt、参数、adapter）<br><code>ollama create mymodel -f Modelfile</code></td>
</tr>
<tr>
<td><code>ollama show</code></td>
<td>查看模型详细信息</td>
<td>查看模型结构、参数、上下文长度等<br><code>ollama show llama3</code></td>
</tr>
<tr>
<td><code>ollama run</code></td>
<td>运行模型（交互或单次）</td>
<td>最常用命令，拉取并运行模型<br><code>ollama run qwen2.5:7b</code></td>
</tr>
<tr>
<td><code>ollama stop</code></td>
<td>停止正在运行的模型</td>
<td>释放内存 &#x2F; CPU<br><code>ollama stop llama3</code></td>
</tr>
<tr>
<td><code>ollama pull</code></td>
<td>从仓库下载模型</td>
<td>只下载不运行<br><code>ollama pull deepseek-coder:6.7b</code></td>
</tr>
<tr>
<td><code>ollama push</code></td>
<td>推送模型到仓库</td>
<td>分享你自定义的模型（需登录）<br><code>ollama push username/mymodel</code></td>
</tr>
<tr>
<td><code>ollama signin</code></td>
<td>登录 ollama.com</td>
<td>用于 push &#x2F; 私有模型<br><code>ollama signin</code></td>
</tr>
<tr>
<td><code>ollama signout</code></td>
<td>登出 ollama.com</td>
<td>退出当前账号<br><code>ollama signout</code></td>
</tr>
<tr>
<td><code>ollama list</code></td>
<td>列出本地已有模型</td>
<td>查看你已下载的模型<br><code>ollama list</code></td>
</tr>
<tr>
<td><code>ollama ps</code></td>
<td>查看正在运行的模型</td>
<td>类似 <code>docker ps</code><br><code>ollama ps</code></td>
</tr>
<tr>
<td><code>ollama cp</code></td>
<td>复制模型</td>
<td>基于现有模型创建新模型<br><code>ollama cp llama3 my-llama3</code></td>
</tr>
<tr>
<td><code>ollama rm</code></td>
<td>删除本地模型</td>
<td>释放磁盘空间<br><code>ollama rm mistral</code></td>
</tr>
<tr>
<td><code>ollama help</code></td>
<td>查看帮助</td>
<td>查看全局或子命令帮助<br><code>ollama help run</code></td>
</tr>
</tbody></table>
<h2 id="Ollama-模型支持"><a href="#Ollama-模型支持" class="headerlink" title="Ollama 模型支持"></a>Ollama 模型支持</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地模型列表</span></span><br><span class="line">ollama list</span><br></pre></td></tr></table></figure>

<p>查看 ollama 中能下载哪些模型：<a href="https://ollama.com/library">https://ollama.com/library</a></p>
<p>开源模型按照综合排序简单列出 10 个</p>
<table>
<thead>
<tr>
<th><strong>Model</strong></th>
<th><strong>description</strong></th>
<th><strong>Tags</strong></th>
<th><strong>Update</strong></th>
</tr>
</thead>
<tbody><tr>
<td>deepseek-r1</td>
<td>DeepSeek-R1 是一系列开放式推理模型，其性能接近领先的模型，例如 O3 和 Gemini 2.5 Pro</td>
<td><code>tools</code> <code>thinking</code> <code>70b</code> <code>671b</code></td>
<td>2025-7</td>
</tr>
<tr>
<td>deepseek-v3.2</td>
<td>DeepSeek-V3.2 是一款兼具高计算效率、卓越推理能力和智能体性能的模型</td>
<td><code>cloud</code></td>
<td>2025-12</td>
</tr>
<tr>
<td>deepseek-coder</td>
<td>DeepSeek Coder 是一个功能强大的编码模型，它经过两万亿个代码和自然语言标记的训练</td>
<td><code>6.7b``33b</code></td>
<td>2024-12</td>
</tr>
<tr>
<td>gemini-3-flash-preview</td>
<td>Gemini 3 Flash 以极低的成本提供专为速度而打造的前沿智能</td>
<td><code>tools</code> <code>thinking</code> <code>cloud</code></td>
<td>2025-12</td>
</tr>
<tr>
<td>gemini-3-pro-preview</td>
<td>谷歌最智能的模型，具备最先进的推理和多模态理解能力，以及强大的智能体和氛围编码能力</td>
<td><code>tools</code> <code>thinking</code> <code>cloud</code></td>
<td>2025-11</td>
</tr>
<tr>
<td>qwen3-coder</td>
<td>阿里巴巴针对智能体和编码任务的高性能长上下文模型</td>
<td><code>tools</code> <code>cloud</code> <code>30b</code> <code>480b</code></td>
<td>2025-10</td>
</tr>
<tr>
<td>qwen3</td>
<td>Qwen3 是 Qwen 系列中最新一代的大型语言模型，提供了一套全面的密集型和混合专家 (MoE) 模型</td>
<td><code>tools</code> <code>thinking</code> <code>32b</code> <code>235b</code></td>
<td>2025-12</td>
</tr>
<tr>
<td>codellama</td>
<td>一个大型语言模型，可以使用文本提示来生成和讨论代码</td>
<td><code>34b</code> <code>70b</code></td>
<td>2023-8</td>
</tr>
<tr>
<td>llama3.1</td>
<td>Llama 3.1 是 Meta 推出的一款全新尖端模型，提供 8B、70B 和 405B 参数大小</td>
<td><code>tools</code> <code>8b</code> <code>70b</code> <code>405b</code></td>
<td>2024-7</td>
</tr>
<tr>
<td>gpt-oss</td>
<td>OpenAI 的开放权重模型专为强大的推理能力、智能体任务和多样化的开发者用例而设计</td>
<td><code>tools</code> <code>thinking</code> <code>cloud</code> <code>20b</code> <code>120b</code></td>
<td>2025-10</td>
</tr>
</tbody></table>
<h2 id="模型下载部署"><a href="#模型下载部署" class="headerlink" title="模型下载部署"></a>模型下载部署</h2><p>以 deepseek-r1:latest 为例，记录部署流程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载模型</span></span><br><span class="line">ollama pull deepseek-r1:latest</span><br><span class="line"></span><br><span class="line">ollama run deepseek-r1:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Web 用户界面中运行 DeepSeek</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line"><span class="built_in">sudo</span> apt install python3-venv</span><br><span class="line">python3 -m venv ~/open-webui-venv</span><br><span class="line"><span class="built_in">source</span> ~/open-webui-venv/bin/activate</span><br><span class="line"></span><br><span class="line">pip install open-webui -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">open-webui serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 http://localhost:8080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl status open-webui</span><br></pre></td></tr></table></figure>

<p>注意在初次启动时，我们本地只有“大脑”（DeepSeek），Open WebUI 还会试图下载一个“图书管理员”（Embedding 模型）。虽然已经成功部署了 DeepSeek，但 Open WebUI 是一个功能完整的界面系统，它默认开启了<strong>RAG（检索增强生成）</strong>功能（即知识库&#x2F;文档上传功能）。</p>
<p>所以默认还会下载一个 all-MiniLM-L6-v2 模型，它不负责对话。它的唯一作用是将你上传的文档、文字转换成计算机能理解的“向量（数字列表）”。当你问 DeepSeek 关于你上传文档的问题时，Open WebUI 先用这个小模型去搜索文档中的相关段落，然后把段落喂给 DeepSeek。它是“图书管理员”。</p>
<p>如果他发现本地没有默认的 Embedding 模型（all-MiniLM-L6-v2），就会自动去 Hugging Face 下载。也就是说会卡在这里，需要配置国内的镜像源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HF_ENDPOINT=https://hf-mirror.com</span><br></pre></td></tr></table></figure>

<p>成功运行如下图所示：</p>
<p><img src="/../uploads/ollama_1.png"></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulnhalla QuickStart</title>
    <url>/2025/12/16/Vulnhalla-QuickStart/</url>
    <content><![CDATA[<h2 id="Vulnhalla"><a href="#Vulnhalla" class="headerlink" title="Vulnhalla"></a>Vulnhalla</h2><p>Vulnhalla 可以自动化执行完整的安全分析流程 (<a href="https://github.com/cyberark/Vulnhalla">https://github.com/cyberark/Vulnhalla</a>)</p>
<ol>
<li>从 GitHub 获取指定编程语言的代码库</li>
<li>下载其对应的 CodeQL 数据库（如果可用）</li>
<li>在数据库上运行 CodeQL 查询以检测安全或代码质量问题</li>
<li>使用 LLM（ChatGPT、Gemini 等）对结果进行后续处理，以分类和过滤问题</li>
</ol>
<p>项目提供了直接从 Github fetch repositories 的能力，但是需要本地配置 GitHub API token，为了简化实验流程，就直接把要分析的 Program git clone 到本地，然后本地生成 CodeQL Database 再进行后续的结果处理，<strong>这个 Project 的重点就是在于结果处理</strong>。</p>
<h2 id="🚀-QuickStart"><a href="#🚀-QuickStart" class="headerlink" title="🚀 QuickStart"></a>🚀 QuickStart</h2><p>环境要求：</p>
<ul>
<li>python 3.11</li>
<li>CodeQL CLI</li>
<li>LLM API Key</li>
</ul>
<p>虚拟环境配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n vulnhalla python=3.11</span><br><span class="line"></span><br><span class="line">conda activate vulnhalla</span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>miniconda 下载可参考这篇文章：<a href="/2025/12/07/Miniconda%E5%AE%89%E8%A3%85/" title="Miniconda安装">Miniconda安装</a>。</p>
<p>配置文件修改 project 中以 OpenAI gpt-4o为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODEQL_PATH=codeql</span><br><span class="line">GITHUB_TOKEN=ghp_your_token_here</span><br><span class="line">PROVIDER=openai</span><br><span class="line">MODEL=gpt-4o</span><br><span class="line">OPENAI_API_KEY=your-api-key-here</span><br><span class="line">LLM_TEMPERATURE=0.2</span><br><span class="line">LLM_TOP_P=0.2</span><br><span class="line"></span><br><span class="line"># Optional: Logging Configuration</span><br><span class="line">LOG_LEVEL=INFO                  # DEBUG, INFO, WARNING, ERROR</span><br><span class="line">LOG_FILE=                       # Optional: path to log file (e.g., logs/vulnhalla.log)</span><br><span class="line">LOG_FORMAT=default              # default or json</span><br><span class="line"># LOG_VERBOSE_CONSOLE=false     # If true, WARNING/ERROR use full format (timestamp - logger - level - message)</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>CODEQL_PATH：指定 CodeQL 可执行文件的路径或命令名，用于运行代码安全分析（如漏洞扫描）。如果已加入系统 PATH，直接写 codeql 即可；</li>
<li>GITHUB_TOKEN：GitHub 访问令牌，用于访问私有仓库、拉取代码、调用 GitHub API（如获取 PR、Issue、仓库信息等）；</li>
<li>PROVIDER&#x2F;MODEL&#x2F;OPENAI_API_KEY：大模型相关配置，可替换为对应厂商；</li>
<li>LLM_TEMPERATURE：控制模型输出的随机性，值越低输出越稳定、保守，适合分析、审计、代码检查等场景；</li>
<li>LLM_TOP_P：控制采样范围（nucleus sampling），限制模型在高概率词汇中选择，进一步提升结果一致性和可控性；</li>
<li>LOG_LEVEL&#x3D;INFO：日志级别，控制输出信息的详细程度，DEBUG是最详细的；</li>
<li>LOG_FILE：日志文件输出路径，留空表示仅输出到控制台；</li>
<li>LOG_FORMAT&#x2F;LOG_VERBOSE_CONSOLE：日志格式和日志记录格式；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> .env.example .<span class="built_in">env</span></span><br><span class="line"></span><br><span class="line">python setup.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化CodeQL套件</span></span><br><span class="line"><span class="built_in">cd</span> data/queries/cpp/tools</span><br><span class="line">codeql pack install</span><br><span class="line"><span class="built_in">cd</span> ../issues</span><br><span class="line">codeql pack install</span><br><span class="line"><span class="built_in">cd</span> ../../../..</span><br></pre></td></tr></table></figure>

<p>使用单个命令运行完整的 pipeline：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Analyze a specific repository</span></span><br><span class="line">python src/pipeline.py redis/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Analyze top 100 repositories</span></span><br><span class="line">python src/pipeline.py</span><br></pre></td></tr></table></figure>

<p>这个 pipeline 会自动执行：获取CodeQL数据库，在所有下载的数据库上运行 CodeQL 查询，使用 LLM 分析结果并保存到 output&#x2F;results&#x2F;，打开 UI 浏览结果。</p>
<p>Project 还提供了一个示例脚本，运行一个端到端示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python examples/example.py</span><br></pre></td></tr></table></figure>

<p>这个 example 会获取 videolan&#x2F;vlc 和 redis&#x2F;redis 的 CodeQL 数据库，在所有下载的数据库上运行 CodeQL 查询，使用 LLM 分析结果并保存到 output&#x2F;results&#x2F;。</p>
<p>Vulnhalla 包含一个功能齐全的用户界面，用于浏览和探索分析结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python src/ui/ui_app.py</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">python examples/ui_example.py</span><br></pre></td></tr></table></figure>

<p>至此，Vulnhalla 环境配置完成，可运行一个完整 pipeline。</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>LLM</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda安装</title>
    <url>/2025/12/07/Miniconda%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Miniconda 是 Conda 的精简发行版，只包含最核心的包管理系统与 Python，可以快速搭建独立的 Python 环境。在进行数据分析、机器学习或科研开发时，相比于 Anaconda 更轻量、更灵活。</p>
<h2 id="一、Miniconda-安装"><a href="#一、Miniconda-安装" class="headerlink" title="一、Miniconda 安装"></a>一、Miniconda 安装</h2><p>Windows 命令行安装方式，可以快速且安静地下载最新的 64 位 Windows 安装程序，将其重命名为较短的文件名，执行静默安装，然后删除安装程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o .\miniconda.exe</span><br><span class="line">start /wait &quot;&quot; .\miniconda.exe /S</span><br><span class="line">del .\miniconda.exe</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>Windows Powershell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> <span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe&quot;</span> <span class="literal">-outfile</span> <span class="string">&quot;.\miniconda.exe&quot;</span></span><br><span class="line"><span class="built_in">Start-Process</span> <span class="literal">-FilePath</span> <span class="string">&quot;.\miniconda.exe&quot;</span> <span class="literal">-ArgumentList</span> <span class="string">&quot;/S&quot;</span> <span class="literal">-Wait</span></span><br><span class="line"><span class="built_in">del</span> .\miniconda.exe</span><br></pre></td></tr></table></figure>

<p>Linux 64位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="built_in">rm</span> ~/miniconda3/miniconda.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/miniconda3/bin/activate</span><br><span class="line"></span><br><span class="line">conda init --all</span><br></pre></td></tr></table></figure>

<h2 id="二、快速使用"><a href="#二、快速使用" class="headerlink" title="二、快速使用"></a>二、快速使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n environment python=3.12</span><br><span class="line"></span><br><span class="line">conda activate environment</span><br><span class="line"></span><br><span class="line">conda deactivate environment</span><br></pre></td></tr></table></figure>

<p>参考文献：<a href="https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt">https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO链接站内文章方法</title>
    <url>/2025/12/11/HEXO%E9%93%BE%E6%8E%A5%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Hexo链接站内文章方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link markdown-learning-by-maxiang 点击这里查看这篇文章 %&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>markdown-learning-by-maxiang</code> 为文章名称，我测试了同目录下修改为自己文章名称可以成功，注意不要加路径，如果文章名称有空格就用双引号引起来。<code>点击这里查看这篇文章</code> 是显示的内容，如果不写的话就默认是文章名称。</p>
<p>参考链接：<a href="https://github.com/iissnan/hexo-theme-next/issues/978">https://github.com/iissnan/hexo-theme-next/issues/978</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11 Java环境变量配置</title>
    <url>/2025/12/04/Win11-Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>找到JDK的路径，在系统环境变量中新建变量名和变量值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_202</span><br></pre></td></tr></table></figure>

<p>然后在系统变量path中，新建两条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br><span class="line">%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>验证配置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_202&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;javac -version</span><br><span class="line">javac 1.8.0_202</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SARIF文件架构解读</title>
    <url>/2025/12/10/SARIF%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="SARIF-文件架构架构解读"><a href="#SARIF-文件架构架构解读" class="headerlink" title="SARIF 文件架构架构解读"></a>SARIF 文件架构架构解读</h2><p>SARIF（Static Analysis Results Interchange Format）本质是一个 JSON 日志规范，用于统一表达静态分析（SAST、Lint、CodeQL、依赖扫描等）的扫描结果，方便不同工具之间共享、聚合、展示与追踪。</p>
<p>SARIF 简单文件结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;https://json.schemastore.org/sarif-2.1.0.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runs&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;tool&#x27;<span class="punctuation">,</span> &#x27;invocations&#x27;<span class="punctuation">,</span> &#x27;artifacts&#x27;<span class="punctuation">,</span> &#x27;results&#x27;<span class="punctuation">,</span> &#x27;columnKind&#x27;<span class="punctuation">,</span>&#x27;properties&#x27;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SARIF &#x3D; 多次运行 runs 的集合，每次运行包含：工具信息 + 运行元数据 + 被分析对象（artifacts）+ 分析结果（results）</p>
</blockquote>
<p>对各部分内容介绍如下：</p>
<ol>
<li>tool 工具信息：检查员身份信息和检查手册，记录了用哪个工具进行了扫描，版本号是多少，包含了 driver 驱动程序信息 和 rules 检查规则清单；</li>
<li>invocations 调用信息：检查员的工作日志，记录了这次检查是在什么环境下进行的，以及是否顺利完成，executionSuccessful: true&#x2F;false；</li>
<li>artifacts 被扫描的文件：检查了哪些地点，列出了所有被 CodeQL 扫描过的源文件（Source Code），包含文件的路径（location），有时也包含文件的具体内容或哈希值，方便后续定位；</li>
<li><strong>results 结果</strong> ：这是问题清单，这是整份报告里最重要的部分，列出了扫描出来的所有 Bug和漏洞信息，关键单：ruleId 记录违反了哪条规则（对应 tool 里的规则），message 记录问题的具体描述，locations 记录了问题在哪个文件的第几行、第几列；</li>
<li>columnKind 列的计算方式：用于告诉 IDE（如 VS Code）如何正确高亮代码；</li>
<li>properties 附加属性：记录了杂项信息，存放标准字段里放不下的、或者工具特有的自定义数据，可能会包含构建时的标签（Build Tags）、项目的元数据（Project Metadata）和一些给特定显示面板用的统计数据；</li>
</ol>
<p>通俗的讲，就是这一次扫描 (run)，是由名为 CodeQL 的 (tool) 进行的。它在一个特定的时间以特定的参数运行 (invocations)，按照特定的刻度标准 (columnKind)，扫描了这一堆文件 (artifacts)，最后发现了这些漏洞 (results)，并在最后贴了一些标签 (properties)。</p>
<span id="more"></span>

<h2 id="关键信息提取"><a href="#关键信息提取" class="headerlink" title="关键信息提取"></a>关键信息提取</h2><p>要在 CodeQL 生成的 SARIF 报告中提取<strong>漏洞点（Sink）</strong>、<strong>漏洞位置</strong>、<strong>数据流（Source 到 Sink）以及控制流</strong>信息，需要研究 <code>runs</code> -&gt; <code>results</code> 数组中的对象。</p>
<p>SARIF 将这些复杂的逻辑封装在了一个层级分明的结构中。以下是提取这些关键信息所对应的具体字段和解析逻辑：</p>
<hr>
<h3 id="提取核心模块：results-数组"><a href="#提取核心模块：results-数组" class="headerlink" title="提取核心模块：results 数组"></a>提取核心模块：<code>results</code> 数组</h3><p>所有的漏洞信息都在 <code>runs[0].results</code> 列表里，需要遍历这个列表，列表中的每一个对象代表一个具体的漏洞实例。</p>
<h3 id="详细提取指南"><a href="#详细提取指南" class="headerlink" title="详细提取指南"></a>详细提取指南</h3><p>需要关注 <code>results</code> 对象下的以下字段：</p>
<h4 id="A-漏洞的基本信息"><a href="#A-漏洞的基本信息" class="headerlink" title="A. 漏洞的基本信息"></a>A. 漏洞的基本信息</h4><ul>
<li><strong>漏洞名称&#x2F;类型</strong>：<code>ruleId</code><ul>
<li>例如：<code>java/sql-injection</code></li>
</ul>
</li>
<li><strong>漏洞简要描述</strong>：<code>message.text</code><ul>
<li>例如：”This query depends on a user-provided value.”</li>
</ul>
</li>
</ul>
<h4 id="B-漏洞位置-爆发点-Sink"><a href="#B-漏洞位置-爆发点-Sink" class="headerlink" title="B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink"></a>B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink</h4><p>这是 CodeQL 认为漏洞最终发生的地方（例如执行 SQL 查询的那一行）。</p>
<ul>
<li><strong>提取字段</strong>：<code>locations</code> 数组</li>
<li><strong>关键逻辑</strong>：通常取 <code>locations[0]</code>（数组的第一个元素）作为主要位置。</li>
<li><strong>具体内容</strong>：<ul>
<li><strong>文件路径</strong>：<code>locations[0].physicalLocation.artifactLocation.uri</code></li>
<li><strong>起始行号</strong>：<code>locations[0].physicalLocation.region.startLine</code></li>
<li><strong>代码片段</strong>（如果有）：<code>locations[0].physicalLocation.region.snippet.text</code></li>
</ul>
</li>
</ul>
<h4 id="C-数据流与控制流"><a href="#C-数据流与控制流" class="headerlink" title="C. 数据流与控制流"></a>C. 数据流与控制流</h4><p>这是最复杂也是最有价值的部分，描述了污点数据（Taint Data）是如何从<strong>输入源（Source）</strong>一步步流向<strong>爆发点（Sink）</strong>的。</p>
<p>CodeQL 将数据流和控制流统一放在 <code>codeFlows</code> 字段中。</p>
<ul>
<li><strong>提取字段</strong>：<code>codeFlows</code> 数组</li>
<li><strong>结构逻辑</strong>：<ol>
<li><code>codeFlows</code> 下通常包含一个或多个 <code>threadFlows</code>（CodeQL 通常只给出一个最具代表性的路径）。</li>
<li><code>threadFlows</code> 下是一个 <code>locations</code> 列表，这是一个<strong>有序数组</strong>，代表了代码执行的步骤。</li>
</ol>
</li>
</ul>
<p><strong>如何解析这个路径链条：</strong></p>
<ul>
<li><strong>Source（污点源头&#x2F;用户输入）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>第一个元素</strong>。</li>
<li>提取：<code>...locations[0].location.physicalLocation</code> (文件和行号)</li>
<li>含义：例如 <code>request.getParameter(&quot;id&quot;)</code>，这是数据进入系统的位置。</li>
</ul>
</li>
<li><strong>Flow Path（传播路径&#x2F;控制流）</strong>：<ul>
<li>是 <code>threadFlows[0].locations</code> 数组的<strong>中间元素</strong>。</li>
<li>这些步骤展示了数据经过了哪些函数调用、赋值操作或判断逻辑。</li>
<li><strong>关键提取</strong>：<code>location.message.text</code> —— 这里通常会说明“数据被传递给参数 x”或“数据通过函数返回值传播”。</li>
</ul>
</li>
<li><strong>Sink（爆发点&#x2F;最终位置）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>最后一个元素</strong>。</li>
<li>这应该与上面提到的 <strong>B. 漏洞位置</strong> 重合。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：需要提取的-JSON-路径映射表"><a href="#总结：需要提取的-JSON-路径映射表" class="headerlink" title="总结：需要提取的 JSON 路径映射表"></a>总结：需要提取的 JSON 路径映射表</h3><p>为了方便编写脚本（如 Python）提取，这是一个速查表：</p>
<table>
<thead>
<tr>
<th align="left">信息类型</th>
<th align="left">SARIF JSON 路径 (假设当前在 results[i] 对象下)</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>漏洞类型</strong></td>
<td align="left"><code>ruleId</code></td>
<td align="left">漏洞的 ID，如 SQL 注入</td>
</tr>
<tr>
<td align="left"><strong>漏洞描述</strong></td>
<td align="left"><code>message.text</code></td>
<td align="left">人类可读的解释</td>
</tr>
<tr>
<td align="left"><strong>漏洞文件</strong></td>
<td align="left"><code>locations[0].physicalLocation.artifactLocation.uri</code></td>
<td align="left">发生漏洞的文件名</td>
</tr>
<tr>
<td align="left"><strong>漏洞行号</strong></td>
<td align="left"><code>locations[0].physicalLocation.region.startLine</code></td>
<td align="left">发生漏洞的行号</td>
</tr>
<tr>
<td align="left"><strong>数据流路径</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations</code></td>
<td align="left">这是一个列表，包含完整路径</td>
</tr>
<tr>
<td align="left"><strong>数据源 (Source)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[0]</code></td>
<td align="left">路径的第一步</td>
</tr>
<tr>
<td align="left"><strong>传播过程</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[1:-1]</code></td>
<td align="left">路径的中间步骤</td>
</tr>
<tr>
<td align="left"><strong>爆发点 (Sink)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[-1]</code></td>
<td align="left">路径的最后一步</td>
</tr>
</tbody></table>
<h3 id="4-举例说明"><a href="#4-举例说明" class="headerlink" title="4. 举例说明"></a>4. 举例说明</h3><p>假设这是一个 SQL 注入的 <code>result</code> 片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ruleId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java/sql-injection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Query depends on user input.&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// ---&gt; 这里是 B: 漏洞最终爆发的位置 (Sink)</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;artifactLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;codeFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// ---&gt; 这里是 C: 完整的数据流/控制流路径</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;threadFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="comment">// 步骤 1: Source (数据源)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Controller.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">15</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User input source...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 2: 中间传播</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Service.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data passed to function...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 3: Sink (通常与 locations[0] 一致)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data used in SQL query...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><strong>判空处理</strong>：不是所有的 <code>results</code> 都有 <code>codeFlows</code>。简单的代码质量检查（比如“变量未使用”）通常只有 <code>locations</code>，没有数据流路径。只有安全类漏洞（如注入、XSS）通常会有 <code>codeFlows</code>。</li>
<li><strong>路径简繁</strong>：CodeQL 生成的 <code>codeFlows</code> 有时非常详细，如果只关注关键跳板，关注 <code>location.message</code> 比较有帮助。</li>
<li><strong>关联位置</strong>：有时还会看到 <code>relatedLocations</code> 字段，这通常用于辅助说明（例如：指出变量定义的位置），如果不需要极高精度，可以暂时忽略。</li>
</ol>
]]></content>
      <categories>
        <category>CodeQL</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
        <tag>SARIF</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulnhalla文章阅读</title>
    <url>/2025/12/18/Vulnhalla%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="Vulnhalla-Picking-the-true-vulnerabilities-from-the-CodeQL-haystack"><a href="#Vulnhalla-Picking-the-true-vulnerabilities-from-the-CodeQL-haystack" class="headerlink" title="Vulnhalla: Picking the true vulnerabilities from the CodeQL haystack"></a>Vulnhalla: Picking the true vulnerabilities from the CodeQL haystack</h2><p>从 CodeQL 海量结果中找到真正的漏洞。</p>
<p>这篇文章主要介绍了一种结合 LLM 推理和静态分析来发现漏洞的方法。通过在 CodeQL 之上叠加 LLM，可以显著减少困扰安全团队的大量误报。最终，开发人员和安全研究人员能够专注于真正具有潜在利用价值的漏洞，从而优化工作流程。</p>
<h2 id="使用-LLM-进行漏洞挖掘目前的挑战"><a href="#使用-LLM-进行漏洞挖掘目前的挑战" class="headerlink" title="使用 LLM 进行漏洞挖掘目前的挑战"></a>使用 LLM 进行漏洞挖掘目前的挑战</h2><p>过去，使用大型语言模型（LLM）进行漏洞检测的主要挑战在于大型代码库的上下文窗口有限。然而，如今这种情况正在改变；一些模型现在可以处理多达一百万个 token 。</p>
<p>就如今的 <strong>大模型漏洞挖掘</strong>而言，主要问题可以归结为两个：</p>
<ul>
<li>WHERE</li>
<li>WHAT</li>
</ul>
<p>WHERE 问题在于 LLM 无法确定代码的哪一部分值得关注。在大型代码库中，可能的关注点数量庞大，这意味着模型很容易分心，把注意力放在错误的地方。</p>
<p>问题在于，即使模型检查到了正确的位置，它仍然需要猜测应该查找哪种类型的错误，例如内存问题、竞态条件或 API 误用。如果没有指导，它可能会完全选择错误的类别，从而无法检测到真正的错误。</p>
<p>Google 和 OpenAI 采取了不同的解决方案。Google 的 Deep Sleep 试图通过分析与已知 CVE 关联的代码更改（例如 git diff 或提交补丁）来解决这些问题，并验证修复程序或附近的代码是否包含类似的问题。OpenAI 采取了不同的策略 ，专注于新的代码提交。他们声称大约 1.2% 的提交引入了已知的安全问题，他们的目标是识别并解决这些问题。这有助于通过将关注点缩小到潜在危险的提交来解决“查找位置”问题，但它并没有完全解决“查找内容”问题，因为该模型仍然需要决定在每种情况下要查找哪种类型的错误。</p>
<span id="more"></span>

<h2 id="SAST-with-LLM"><a href="#SAST-with-LLM" class="headerlink" title="SAST with LLM"></a>SAST with LLM</h2><p>本文提出了一种可以解决 WHERE 和 WHAT 的方法：<strong>把静态分析工具和 LLM 结合。</strong></p>
<p>静态分析是指在不执行源代码的情况下，静态地解析源代码以识别安全漏洞的过程。它通过提取变量、结构体和代码关系来实现这一点。这些提取结果会被保存到数据库中，并构建代码流图和数据流图。然后，可以根据预定义的规则或查询来检查这些图。</p>
<p>例如，某条规则可能会标记任何源大小未被目标大小正确限定的 memcpy 调用，这种情况可能导致内存损坏不安全的数据流以及其他关键问题。</p>
<p>CodeQL 分析基于查询，这些查询分为稳定集和实验集。稳定集的误报率较低。</p>
<p>但是 CodeQL存在一个问题，就是<strong>结果数量过多</strong>，潜在的安全漏洞数量过多，导致专家无法进行手动复查，并且忽略这些警报可能会在代码库中留下真正的漏洞，等待耐心的攻击者去发现。</p>
<p><strong>假阳性</strong>是指：</p>
<blockquote>
<p>检测结果显示为“阳性”，但实际上被检测对象并不具备该情况或疾病。说白了就是 “测出来有，但是实际上没有” 。</p>
</blockquote>
<p>关于静态分析工具的研究表明，其中大约 80% 的检测结果是误报，只有 20% 的结果能够得到有效解决。</p>
<p>静态分析虽然稳健，但信噪比可能非常低。正因如此， <strong>单独使用静态分析在大规模应用中会面临挑战 ，所以和 LLM 的结合显得必要。</strong></p>
<h3 id="关键流程"><a href="#关键流程" class="headerlink" title="关键流程"></a>关键流程</h3><p>安全研究人员获取源代码，生成一个 CodeQL 数据库，对数据库运行 CodeQL 查询，然后将结果中的每个警报传递给 LLM，以确定每个警报是真正的问题还是误报。</p>
<p><img src="/../uploads/paper_vuln_1.png"></p>
<h3 id="关键上下文信息提取"><a href="#关键上下文信息提取" class="headerlink" title="关键上下文信息提取"></a>关键上下文信息提取</h3><p>CodeQL 会产出一个漏洞警告，但是也仅仅是一条信息，仅有这个漏洞告警信息是远远不够的，还需要结合源代码来进行深入分析判断，但是要发送多少源代码给 LLM 才能让 LLM 进行精准判断，这是一个要思考的问题，发送内容过多会使 LLM 注意力分散，降低识别到准确漏洞的概率；发送内容过少，会缺少关键信息导致 LLM 误判，文章对这个关键点进行了讨论分析。</p>
<p>为 chatgpt 定制 Custom Instructions 如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">You are a security static-analysis assistant.</span><br><span class="line">You are given:</span><br><span class="line">- Metadata about a CodeQL alert.</span><br><span class="line">- A snippet of C source code that may contain the reported problem.</span><br><span class="line">Your job:</span><br><span class="line">- Decide whether the alert is likely a real bug, given ONLY the code shown.</span><br><span class="line">- Respond VERY BRIEFLY (at most 2 sentences).</span><br><span class="line">Rules:</span><br><span class="line">- If you can determine it IS a real bug, start with: &quot;Bug:&quot; and give a short reason.</span><br><span class="line">- If you can determine it is NOT a real bug, start with: &quot;Not a bug:&quot; and give a short reason.</span><br><span class="line">- If you CANNOT TELL from the snippet and you need more code, start with: &quot;Unknown:&quot; and state EXACTLY what additional code or context you would need.</span><br><span class="line">Do not speculate beyond the shown code.</span><br><span class="line">Do NOT call something a bug unless the code shown is clearly unsafe.</span><br><span class="line">Always list concrete missing pieces when you answer &quot;Unknown:&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只发送出现问题的代码行，chatgpt 会回复无法进行判断，需要更多信息。此时就遇到了一个很有趣的问题：<strong>还需要多少？多少才算足够？</strong></p>
<p>文章又测试了发送漏洞代码行的前四行和后四行代码作为辅助判断的上下文，但是这仍然不足以让 LLM 做出任何可靠的判断。文章讨论了如何判断 LLM 何时拥有足够的上下文信息？是否需要整个文件吗？多个文件？还是只需要完整的函数？所有这些问题都很有意义，这促使促使研究人员从另一个角度思考问题。</p>
<h3 id="Letting-the-LLM-ask-for-its-own-context"><a href="#Letting-the-LLM-ask-for-its-own-context" class="headerlink" title="Letting the LLM ask for its own context"></a>Letting the LLM ask for its own context</h3><p>让 LLM 自行寻找其需要的关键上下文信息，按需上下文索引过程如下图所示：</p>
<p><img src="/../uploads/paper_vuln_2.png"></p>
<p>理论上听起来很棒，但在验证这个理论之前，也就是说只有代码行号时，我们能否提取出函数？事实证明，这并非易事，尤其是在 C 语言中（文章是以 C 语言为基础，但是我想在 Java 上对该框架进行测试）。</p>
<p>文章讨论了使用正则表达式和代码索引器来进行函数抽取，但是正则在 C 语言上不起作用，并且使用代码索引器构建索引库太过漫长，无法将其扩展到大型项目。</p>
<p>然后作者意识到，如果代码索引器基本上执行的是静态分析相同的工作，而我们已经在使用静态分析（CodeQL），为什么不直接使用 CodeQL 数据库来按需提取所有必要的上下文信息呢？</p>
<p>于是，就有了<strong>关键想法</strong>：</p>
<ul>
<li>运行一条 CodeQL 查询，获取起始行小于问题行且结束行大于问题行的函数；</li>
<li>如果 LLM 需要更多上下文，则运行另一个查询并提取必要的上下文，<strong>达成关键信息提取循环</strong>。</li>
</ul>
<p><img src="/../uploads/paper_vuln_3.png"></p>
<p>理论上方法是有效的：</p>
<ul>
<li>它们包括所有第三方代码</li>
<li>它们已经可以通过 GitHub API (CI&#x2F;CD) 获取</li>
<li>无需克隆仓库</li>
<li>查询它们可以获得精确的、编译器级别的结构</li>
</ul>
<p>但是这个想法在执行是遇到了性能瓶颈：为了给 LLM 提供“按需的精确上下文”，他们不得不频繁运行“动态 CodeQL 查询”，而这在性能上几乎不可接受。</p>
<h3 id="解决方案：Pre-Extracting-functions-into-a-CSV"><a href="#解决方案：Pre-Extracting-functions-into-a-CSV" class="headerlink" title="解决方案：Pre-Extracting functions into a CSV"></a>解决方案：Pre-Extracting functions into a CSV</h3><p>与其每次 LLM 请求时都运行每个查询，不如采用更简洁的方法：编写一个 CodeQL 查询，选择数据库中的每个函数（包括调用函数），并将其导出到 CSV 文件中。也许 CSV 文件可能非常大，但我们受限的是时间，而不是空间。</p>
<p>工作流：</p>
<ol>
<li>将所有函数信息提取到 CSV 文件</li>
<li>对代码运行 CodeQL 并保存所有问题</li>
<li>获取每个问题发生的具体位置</li>
<li>扫描 CSV 文件以查找函数：<code>函数起始行 &lt;= 问题行 &lt;= 函数结束行</code></li>
<li>使用 CSV 文件中的信息，直接从代码中提取该函数</li>
<li>如果 LLM 需要调用函数，只需在同一上下文中查找其 ID，并将更新后的上下文发送给 LLM 即可</li>
</ol>
<p>更棒的是，我们还可以节省更多时间，因为每个 CodeQL 数据库都包含一个 src.zip 文件，其中包含用于构建数据库的所有源代码。无需克隆存储库；只需从 GitHub API 下载一次数据库即可。</p>
<p>使用 CSV 文件按需传输上下文：</p>
<p><img src="/../uploads/paper_vuln_4.png"></p>
<h3 id="Guiding-the-LLM-with-high-level-questions"><a href="#Guiding-the-LLM-with-high-level-questions" class="headerlink" title="Guiding the LLM with high-level questions"></a>Guiding the LLM with high-level questions</h3><p>与其直接向 LLM 提供问题，作者提出可以在 LLM 做出判断之前向其提出“ 引导性问题” ，以增强其推理过程。例如：</p>
<p>源缓冲区在哪里声明？它的尺寸是多少？这个尺寸会改变吗？目标缓冲区在哪里声明？这些缓冲区是从其他地方分配的吗？哪些条件或操作会影响它们？</p>
<p>通过引导性问题增加模型思考起作用了，由于 LLM 模型的输出基于之前的文本，这种格式鼓励它逐步推理。通过回答关于变量和流程的针对性问题，该模型模拟了资深研究人员的推理过程，最终决策是在掌握所有正确且与上下文相关的最新信息的情况下做出的。</p>
<p>由于 LLM 现在可以“讲解”变量、大小、赋值和路径，因此它自然而然地避免了以前犯的错误，不需要任何特殊情况的指示，就像一位资深研究员一样。</p>
<p>但需要注意的是，<strong>不同类型的问题需要不同的引导性问题</strong>。对于某些漏洞，LLM 需要分析控制流；对于其他漏洞，它必须分析变量类型；在某些情况下，它还必须关注特殊条件或极端情况。</p>
<h2 id="Running-the-method-in-the-real-world"><a href="#Running-the-method-in-the-real-world" class="headerlink" title="Running the method in the real world"></a>Running the method in the real world</h2><p>在实际环境中运行这个方法：</p>
<ul>
<li><p>静态分析中“位WHERE和“WHAT”问题的实用解答</p>
</li>
<li><p>一个人工智能代理，可以直接从 CodeQL CSV 输出中提取所有必要的上下文信息</p>
</li>
<li><p>一种可靠的方法，可以引导 LLM 评估实际脆弱性，而不是匹配表面模式。</p>
</li>
</ul>
<p>作者使用这种方法对 100 个大型开源 GitHub 存储库（按 C 语言的 star 数选择）运行了该工具，并扫描了多种不同的问题类型。</p>
<p>针对每个问题类别，项目设计了具体的引导性问题，以使 LLM 专注于准确判断可利用性所需的确切语义和上下文。</p>
<p>利用这种方法，项目构建了一个名为 Vulnhalla 的开源工具。它允许用户直接从 GitHub 下载 CodeQL 数据库，对其运行查询，并将结果导入 LLM 模型。对于每个发现，该工具会自动检索相关的代码上下文，并应用针对特定问题的引导性问题。这使得模型能够更准确地推断底层逻辑，过滤掉误报，并仅显示真正具有潜在价值的发现。</p>
<p>Vulnhalla 通过将 CodeQL 与 LLM 支持的推理相结合，解决了大规模静态分析中持续存在的信噪比瓶颈问题，从而实现精确且可扩展的漏洞发现。</p>
<p>该工具目前支持 C 和 C++ 的完整代码导航，并包含多个引导式问题的示例模板。</p>
<p>我们诚邀社区贡献力量，扩展对更多编程语言的支持。这包括编写 CodeQL 查询，根据语言语义将相关数据提取为 CSV 格式，以及创建针对每种问题类型和语言量身定制的引导式问题模板。</p>
<h2 id="Key-Takeaways-and-Next-Steps-for-CodeQL-and-LLM-Vulnerability-Hunting"><a href="#Key-Takeaways-and-Next-Steps-for-CodeQL-and-LLM-Vulnerability-Hunting" class="headerlink" title="Key Takeaways and Next Steps for CodeQL and LLM Vulnerability Hunting"></a>Key Takeaways and Next Steps for CodeQL and LLM Vulnerability Hunting</h2><p>项目贡献点：</p>
<ul>
<li>误报率降低高达 96%</li>
<li>性能优化</li>
<li>增强逻辑推理能力</li>
<li>漏洞挖掘</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.利用大语言模型优化 CodeQL 漏洞挖掘 <a href="https://mp.weixin.qq.com/s/REEcsXvUh4WPHaNC3Qo-jw">https://mp.weixin.qq.com/s/REEcsXvUh4WPHaNC3Qo-jw</a></p>
<p>2.Vulnhalla: Picking the true vulnerabilities from the CodeQL haystack <a href="https://www.cyberark.com/resources/threat-research-blog/vulnhalla-picking-the-true-vulnerabilities-from-the-codeql-haystack">https://www.cyberark.com/resources/threat-research-blog/vulnhalla-picking-the-true-vulnerabilities-from-the-codeql-haystack</a></p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>LLM</tag>
        <tag>Papers</tag>
      </tags>
  </entry>
  <entry>
    <title>大型开源项目学习经验</title>
    <url>/2025/12/23/%E5%A4%A7%E5%9E%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>最近在学习一些体量较大的开源项目时，明显感受到和阅读中小型项目完全不同的困难：代码量庞大、模块之间耦合复杂、很难快速抓住主线流程。</p>
<p>如果一开始就陷入细节，很容易在函数和类之间迷失方向。因此，我尝试整理了一套从“跑起来”到“抓主线”，再到“逐模块理解”的学习思路，希望能帮助自己，也给后来者提供一个参考的学习框架。</p>
<h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><p>这一部分回答三个问题：这个项目是什么？解决什么问题？你为什么要学它？</p>
<ul>
<li>项目背景：目前存在什么问题？</li>
<li>项目核心目标：该项目解决了什么问题？</li>
<li>个人学习目标：我需要用这个项目实现什么？</li>
</ul>
<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>这一部分回答：项目如何跑起来？最简单的运行方式和运行路径是什么？</p>
<ul>
<li>环境依赖配置</li>
<li>最小可运行实例</li>
<li>运行结果分析</li>
</ul>
<h2 id="核心流程（系统主线）"><a href="#核心流程（系统主线）" class="headerlink" title="核心流程（系统主线）"></a>核心流程（系统主线）</h2><p>程序从启动到结束经历了什么？需要描述出一条清晰的执行链路。</p>
<ul>
<li>输出 &amp;&amp; 输出</li>
<li>核心功能一执行链路</li>
<li>核心功能二执行链路</li>
<li>等等</li>
</ul>
<h2 id="调通模块"><a href="#调通模块" class="headerlink" title="调通模块"></a>调通模块</h2><ol>
<li>XX模块<ul>
<li>模块功能</li>
<li>输出 &amp;&amp; 输出</li>
</ul>
</li>
</ol>
<h2 id="未调通模块"><a href="#未调通模块" class="headerlink" title="未调通模块"></a>未调通模块</h2><ol>
<li>XX模块<ul>
<li>价值分析</li>
</ul>
</li>
</ol>
<h2 id="项目学习架构-Demo"><a href="#项目学习架构-Demo" class="headerlink" title="项目学习架构 Demo"></a>项目学习架构 Demo</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">## 项目目标</span><br><span class="line"></span><br><span class="line">## 运行方式</span><br><span class="line"></span><br><span class="line">## 核心流程（系统主线）</span><br><span class="line"></span><br><span class="line">- 输出 &amp;&amp; 输出</span><br><span class="line">- 核心功能一执行链路</span><br><span class="line">- 核心功能二执行链路</span><br><span class="line"></span><br><span class="line">## 调通模块</span><br><span class="line"></span><br><span class="line">## 未调通模块</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>常见CWE类型</title>
    <url>/2025/12/20/%E5%B8%B8%E8%A7%81CWE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>CWE（Common Weakness Enumeration，<strong>通用弱点枚举</strong>）可以理解为一份<strong>软件常见安全问题清单</strong>。</p>
<p>它不是具体的漏洞编号（CVE），而是把各种程序和系统中<strong>容易犯的安全错误</strong>进行分类和编号，比如输入校验不严、权限控制错误、配置不当等。</p>
<p>通过使用 CWE，开发人员可以在写代码和配置系统时提前避免这些常见问题，安全人员也可以用它来分析漏洞成因、指导加固和考试答题。在软考中，CWE 更多是用来<strong>说明漏洞属于哪一类错误和为什么会产生</strong>。</p>
<table>
<thead>
<tr>
<th><strong>CWE编号</strong></th>
<th><strong>漏洞类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CWE-16</td>
<td>配置错误（常见）</td>
<td>所有由于系统、软件、服务配置不当导致的安全问题</td>
</tr>
<tr>
<td>CWE-20</td>
<td>输入验证不当</td>
<td>由于输入校验不足，导致不可信数据被系统错误处理，从而引发多种安全漏洞的根本原因</td>
</tr>
<tr>
<td>CWE-22</td>
<td>路径&#x2F;目录遍历</td>
<td>攻击者通过构造包含特殊路径的输入，绕过目录限制，访问或读取本不应访问的文件</td>
</tr>
<tr>
<td>CWE-78</td>
<td>命令注入</td>
<td>用户输入被直接用于构造操作系统命令，CWE-77 也属于命令注入</td>
</tr>
<tr>
<td>CWE-79</td>
<td>跨站脚本（XSS）</td>
<td>未对用户输入进行充分过滤，导致恶意脚本被执行</td>
</tr>
<tr>
<td>CWE-89</td>
<td>SQL 注入</td>
<td>构造 SQL 查询时未对用户输入进行有效处理，导致攻击者可注入恶意 SQL 语句，实现未授权的数据访问或操作</td>
</tr>
<tr>
<td>CWE-119</td>
<td>缓冲区溢出</td>
<td>写入数据超出缓冲区边界，同样 CWE-120 也属于缓冲区溢出</td>
</tr>
<tr>
<td>CWE-200</td>
<td>信息泄露</td>
<td>信息泄露的总类，常见的还有 CWE-215（开启 debug 模式、返回变量、配置等信息）</td>
</tr>
<tr>
<td>CWE-284</td>
<td>访问控制不当</td>
<td>权限校验缺失或校验逻辑错误</td>
</tr>
<tr>
<td>CWE-287</td>
<td>身份认证不当</td>
<td>认证逻辑存在缺陷</td>
</tr>
<tr>
<td>CWE-552</td>
<td>任意文件读取</td>
<td>由于文件或目录权限、访问策略配置不当，导致未授权用户可以直接访问或读取系统敏感文件或目录</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>软考</tag>
        <tag>CWE</tag>
      </tags>
  </entry>
  <entry>
    <title>解决VScode和Trae等无法加载conda虚拟环境的问题</title>
    <url>/2025/12/02/%E8%A7%A3%E5%86%B3VScode%E5%92%8CTrae%E7%AD%89%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>使用 conda 或 miniconda 配置虚拟环境时，当启动虚拟环境时，遇到如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是，运行 <code>conda init</code> 后还是不起作用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ conda init</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda.exe</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda-env.exe</span><br><span class="line">......</span><br><span class="line">no change     C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</span><br><span class="line">modified      HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun</span><br></pre></td></tr></table></figure>

<h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>我是 win11 操作系统，需要以 <strong>管理员身份</strong> 打开powershell窗口，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>重新加载即可生效。</p>
<span id="more"></span>

<h1 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h1><p>简单说，这个问题本质上是：<strong>Conda 的初始化脚本被 PowerShell 的安全策略拦住了，所以每次新开终端时，Conda 都没真正“接管”当前 Shell。</strong></p>
<h2 id="1-conda-init-实际在做什么？"><a href="#1-conda-init-实际在做什么？" class="headerlink" title="1. conda init 实际在做什么？"></a>1. <code>conda init</code> 实际在做什么？</h2><p>在 Windows + PowerShell 下，Conda 并不是简单地靠 <code>conda.exe</code> 来完成环境激活的，而是通过一套 <strong>Shell Hook 脚本</strong> 来接管当前会话：</p>
<p><code>conda init</code> 会在 <code>C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</code> 里写入一段初始化代码，这些脚本会去调用 <code>miniconda3\shell\condabin\conda-hook.ps1</code> 等文件，往当前 PowerShell 里注入 <code>conda</code> &#x2F; <code>conda activate</code> 等函数，并设置好 PATH、环境变量等。</p>
<p><strong>只有这些 Hook 每次打开 PowerShell 时能顺利执行，当前终端才真正“支持” <code>conda activate</code>。</strong></p>
<p>所以当你看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实意思是：<strong>当前这个 PowerShell 会话里没有被注入 Conda 的 Hook 脚本</strong>，所以它感觉自己还没 init。</p>
<h2 id="2-PowerShell-执行策略的限制"><a href="#2-PowerShell-执行策略的限制" class="headerlink" title="2. PowerShell 执行策略的限制"></a>2. PowerShell 执行策略的限制</h2><p>PowerShell 为了安全，有一个 <strong>执行策略（Execution Policy）</strong>，决定哪些脚本可以被执行：</p>
<p>常见几种：</p>
<ul>
<li><code>Restricted</code>：完全禁止执行脚本；</li>
<li><code>AllSigned</code>：所有脚本都必须是签名的；</li>
<li><code>RemoteSigned</code>：本地脚本可以执行，从互联网下载的脚本必须签名。</li>
</ul>
<p>在我机器上的情况是：</p>
<ul>
<li><p>Conda 的这些 hook &#x2F; profile 脚本属于 <strong>本地脚本</strong>；</p>
</li>
<li><p>但默认配置策略过于严格，导致：</p>
<ul>
<li>打开 PowerShell 时，<code>profile.ps1</code> &#x2F; <code>conda-hook.ps1</code> 没有被执行；</li>
<li>于是 <code>conda</code> 函数、自动激活逻辑统统都没加载进当前会话；</li>
<li>终端自然就会提示你先 <code>conda init</code>。</li>
</ul>
</li>
</ul>
<p>也就是说：<code>conda init</code> 写入的配置已经在那儿了，但每次启动 PowerShell 时都被策略挡在门外。 当以管理员身份执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>等于允许系统执行本地脚本，只对来源不明的远程脚本做限制。</p>
<p>这样一来，再次打开 PowerShell &#x2F; VSCode 内置终端时，<code>profile.ps1</code> 会被正常加载，里面调用的 <code>conda-hook.ps1</code> 等本地脚本可以顺利执行， VSCode &#x2F; Trae 里就可以正常加载和激活 Conda 虚拟环境，不再报 Run ‘conda init’ before ‘conda activate’错误。</p>
]]></content>
      <categories>
        <category>Trouble shooting</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Trouble shooting</tag>
      </tags>
  </entry>
  <entry>
    <title>软考信息安全工程师2024真题选择</title>
    <url>/2025/12/23/%E8%BD%AF%E8%80%83%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%882024%E7%9C%9F%E9%A2%98%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="1-CWE-89-编号代表的漏洞类型是（-）"><a href="#1-CWE-89-编号代表的漏洞类型是（-）" class="headerlink" title="1. CWE-89 编号代表的漏洞类型是（ ）"></a>1. CWE-89 编号代表的漏洞类型是（ ）</h2><p>A. <strong>SQL 注入</strong>  B. 命令注入  C. 配置错误  D. 信息泄露</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. SQL 注入（正确）</strong><br>CWE-89 专指 SQL 注入漏洞，即用户输入未正确过滤，被拼接进 SQL 语句执行。</p>
</li>
<li><p>B. 命令注入<br>命令注入对应的常见编号是 <strong>CWE-78</strong>，属于操作系统命令层面的漏洞。</p>
</li>
<li><p>C. 配置错误<br>配置错误是一个宽泛类别，没有唯一的 CWE 编号，常见如 CWE-16、CWE-732。</p>
</li>
<li><p>D. 信息泄露<br>同样是大类概念，常见 CWE 包括 CWE-200、CWE-215 等。</p>
</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>SQL 注入的核心问题是<strong>未使用参数化查询</strong></li>
<li><strong>CWE 编号与漏洞类型的一一对应关系</strong> 参考 <a href="/2025/12/20/%E5%B8%B8%E8%A7%81CWE%E7%B1%BB%E5%9E%8B/" title="常见CWE类型">常见CWE类型</a></li>
</ul>
<h2 id="2-Linux-系统的内核日志是通过哪个组件管理？（-）"><a href="#2-Linux-系统的内核日志是通过哪个组件管理？（-）" class="headerlink" title="2. Linux 系统的内核日志是通过哪个组件管理？（ ）"></a>2. Linux 系统的内核日志是通过哪个组件管理？（ ）</h2><p>A. rsyslog  B. syslogd  C. <strong>klogd</strong>  D. syslog</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. klogd（正确）</strong><br>klogd 专门负责读取内核通过 <code>printk</code> 输出的日志信息。</p>
</li>
<li><p>A. rsyslog<br>主要用于用户态日志或内核态日志的收集和转发，不直接管理内核缓冲区。</p>
</li>
<li><p>B. syslogd<br>是传统日志守护进程，处理系统日志，但内核日志需由 klogd 提供。</p>
</li>
<li><p>D. syslog<br>是日志机制或协议的统称，不是具体组件。</p>
</li>
</ul>
<h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p>Linux 日志分两类：内核日志和用户态日志。</p>
<p>内核日志（Kernel Log）由内核态（kernel）输出，如 printk()，典型内容包括驱动加载、硬件识别、内核错误、OOM、panic、网络栈信息等，存储在ring buffer（环形缓冲区）中，可以使用命令 <code>dmesg</code> 查看。</p>
<p>用户态日志的来源是用户空间程序&#x2F;服务，如 sshd、nginx、应用程序、cron 等，包含访问日志、错误日志、认证日志、系统服务日志等，一般落地到 &#x2F;var&#x2F;log&#x2F; 目录下各种文件。</p>
<p>内核日志输出链路：内核通过 printk() 输出日志，写入 kernel ring buffer（环形缓冲区），klogd 从 ring buffer 把日志读出来，然后交给 syslogd&#x2F;rsyslogd，syslogd&#x2F;rsyslogd 按配置写入 &#x2F;var&#x2F;log&#x2F;messages 等文件。在传统体系下可以理解为：<code>klogd负责读取/接收内核日志</code>。</p>
<p>rsyslog&#x2F;syslogd 的主要职责：它们的主要工作是处理来自用户空间应用程序（通过 syslog() API 调用）以及来自 klogd 转发过来的内核消息的系统日志。它们本身不直接读取内核环形缓冲区。</p>
<p>但现代 Linux 多数使用 systemd，systemd-journald 扮演了 klogd + syslogd 的部分角色。</p>
<h2 id="3-MySQL-中撤销用户权限的命令是（-）"><a href="#3-MySQL-中撤销用户权限的命令是（-）" class="headerlink" title="3. MySQL 中撤销用户权限的命令是（ ）"></a>3. MySQL 中撤销用户权限的命令是（ ）</h2><p>A. REMOVE  B. DELETE  C. <strong>REVOKE</strong>  D. DENY</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. REVOKE（正确）</strong><br>标准 SQL 命令，用于撤销已经授予的权限。</p>
</li>
<li><p>A. REMOVE<br>非 SQL 标准命令。</p>
</li>
<li><p>B. DELETE<br>用于删除表中的数据记录，与权限管理无关。</p>
</li>
<li><p>D. DENY<br>常见于 SQL Server，在 MySQL 中不支持。</p>
</li>
</ul>
<h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><p>增 Create 删 Delete 改 Update 查 Select 插 Insert 看 Show 选 Use 设置 Set<br>看结构 DESC 备份 mysqldump 赋予用户权限 GRANT 撤销用户权限 REVOKE</p>
<h2 id="4-使用-25-端口传播的木马是（-）"><a href="#4-使用-25-端口传播的木马是（-）" class="headerlink" title="4. 使用 25 端口传播的木马是（ ）"></a>4. 使用 25 端口传播的木马是（ ）</h2><p>A. <strong>Doly Trojan</strong>  B. WinCrash  C. WinPC  D. FTP Trojan</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. Doly Trojan（正确）</strong><br>Doly Trojan（多利木马）通常是早期中文安全资料或部分病毒库中出现过的一类“木马”名称，属于 Trojan（木马程序） 的范畴。Doly Trojan 是一个比较古老的 Windows 特洛伊木马，它的主要传播机制就是利用受害者的计算机，通过其 25 端口（SMTP）向外大量发送携带自身副本的垃圾邮件。它将自己伪装成看似无害的文件（如游戏、破解工具等），诱骗用户运行。一旦激活，它会尝试通过电子邮件附件传播给受害者通讯录中的地址或随机生成的邮件地址。</p>
</li>
<li><p>B. WinCrash<br>WinCrash从名字看更像是“导致 Windows 崩溃&#x2F;死机”的程序名或病毒名，可能是某类恶意程序&#x2F;病毒的名称，或者一个破坏性工具（让系统崩溃、蓝屏、拒绝服务）。</p>
</li>
<li><p>C. WinPC<br>WinPC这个词本身是一个泛称，字面意思就是 Windows Personal Computer（Windows 个人电脑）</p>
</li>
<li><p>D. FTP Trojan<br>FTP Trojan通常指“通过 FTP 相关方式传播或利用 FTP 服务的木马”，常见含义有两种：（1）通过 FTP 传播&#x2F;上传下载恶意代码的木马；（2）针对 FTP 服务的后门&#x2F;木马 注意FTP端口号是21，而25是SMTP邮件端口号。</p>
</li>
</ul>
<h3 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>端口与攻击方式是<strong>固定考点</strong>，如果不知道 trojan 类型，可以根据协议和端口进行分析</li>
<li>25 端口几乎必然与 <strong>邮件攻击 &#x2F; 蠕虫传播</strong> 关联</li>
</ul>
<h2 id="5-路由器配置中用于加密特权模式口令的命令是（-）"><a href="#5-路由器配置中用于加密特权模式口令的命令是（-）" class="headerlink" title="5. 路由器配置中用于加密特权模式口令的命令是（ ）"></a>5. 路由器配置中用于加密特权模式口令的命令是（ ）</h2><p>A. <strong>enable secret</strong>  B. secpwd  C. encryption  D. password-encrypt</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. enable secret（正确）</strong><br>该命令用于设置进入路由器特权执行模式的密码。它使用强加密算法（如 MD5 或 SHA-256）将密码存储为不可逆的密文在配置文件中。</p>
</li>
<li><p>B. secpwd<br>这不是思科 IOS 或主流路由器操作系统中的有效命令。</p>
</li>
<li><p>C. encryption<br>这不是一个独立命令。与密码加密相关的常见命令是 service password-encryption。<br>它的作用是：<br>对配置文件中其他类型的明文口令（如控制台密码 line con 0 下的 password，VTY 线路密码 line vty 下的 password，enable 密码（如果使用较弱 的 enable password 命令设置））进行较弱的、可逆的加密（通常是 Vigenère 加密）。</p>
</li>
<li><p>D. password-encrypt<br>命令错误，正确的是 <code>service password-encryption</code>。</p>
</li>
</ul>
<h3 id="扩展-4"><a href="#扩展-4" class="headerlink" title="扩展"></a>扩展</h3><p>思科路由器常见操作命令：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">show running-config        查看当前运行配置</span><br><span class="line">show startup-config        查看启动配置</span><br><span class="line">show ip interface brief    查看接口 IP 与状态汇总</span><br><span class="line">show version               查看 IOS 版本、设备型号、运行时间</span><br><span class="line">show interfaces            查看接口详细信息</span><br><span class="line">show arp                   查看 ARP 表</span><br><span class="line">show ip route              查看路由表</span><br><span class="line"></span><br><span class="line">enable                     进入特权执行模式</span><br><span class="line">configure terminal         进入全局配置模式</span><br><span class="line">exit                       退出当前模式</span><br><span class="line">end                        直接返回特权执行模式</span><br><span class="line">disable                    从特权模式退回用户模式</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0   进入接口配置模式</span><br><span class="line">ip address 192.168.1.1 255.255.255.0   配置接口 IP 地址</span><br><span class="line">no shutdown                启用接口</span><br><span class="line">shutdown                   关闭接口</span><br><span class="line">description LAN Interface  配置接口描述</span><br><span class="line"></span><br><span class="line">enable secret cisco123         设置特权模式加密密码</span><br><span class="line">line console 0                 进入控制台线路配置</span><br><span class="line">password cisco                 设置控制台密码</span><br><span class="line">login                          启用登录验证</span><br><span class="line">line vty 0 4                   配置远程登录线路</span><br><span class="line">transport input telnet ssh     指定远程登录方式</span><br><span class="line">service password-encryption    对明文口令进行简单加密</span><br><span class="line"></span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.1.254   配置默认静态路由</span><br><span class="line">router rip                  启用 RIP 路由协议</span><br><span class="line">router ospf 1                启用 OSPF，进程号为 1</span><br><span class="line">network 192.168.1.0 0.0.0.255 area 0   宣告网络</span><br><span class="line"></span><br><span class="line">copy running-config startup-config   保存配置</span><br><span class="line">write memory                          保存配置（简写）</span><br><span class="line">reload                                重启路由器</span><br><span class="line"></span><br><span class="line">ping 8.8.8.8              测试网络连通性</span><br><span class="line">traceroute 8.8.8.8        路由路径跟踪</span><br><span class="line">debug ip routing          调试路由（慎用）</span><br><span class="line">undebug all               关闭所有调试</span><br></pre></td></tr></table></figure>


<h2 id="6-WAF-通常无法防御哪种攻击？（-）"><a href="#6-WAF-通常无法防御哪种攻击？（-）" class="headerlink" title="6. WAF 通常无法防御哪种攻击？（ ）"></a>6. WAF 通常无法防御哪种攻击？（ ）</h2><p>A. <strong>HTTP 隧道</strong>  B. WebShell  C. SQL 注入  D. CSRF</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. HTTP 隧道（正确）</strong><br>HTTP 隧道的原理是攻击者将恶意流量（如 C2 通信、数据窃取、端口扫描）封装在合法的 HTTP&#x2F;HTTPS 请求中，伪装成正常 Web 流量（例如通过图片上传、评论字段、Cookie 等传输加密数据）。</p>
<p>WAF 的盲点：WAF 主要分析 HTTP&#x2F;HTTPS 协议层的语法和语义如参数格式、SQL 关键字、XSS 脚本特征，但无法理解封装在其中的应用层私有协议。如果隧道流量符合 HTTP 规范且不包含已知攻击特征（如 SQL 注入语句），WAF 会将其视为正常流量放行。</p>
<p>WAF 难以区分加密混淆后的隧道数据与真实业务数据。</p>
</li>
<li><p>B. WebShell<br>WAF 可以有效防御常见的 WebShell 上传行为。它能检测文件上传请求中的恶意特征（如 <?php system($_GET['cmd']); ?>），可疑路径（如 &#x2F;uploads&#x2F;backdoor.php）或异常 HTTP 方法（如 PUT 上传）</p>
</li>
<li><p>C. SQL 注入<br>这是 WAF 的核心防护场景之一，可基于关键字、语法特征进行检测。</p>
</li>
<li><p>D. CSRF<br>WAF 可通过 Referer 校验、Token 检测、异常跨域请求识别部分防御 CSRF。</p>
</li>
</ul>
<h3 id="扩展-5"><a href="#扩展-5" class="headerlink" title="扩展"></a>扩展</h3><p>  HTTP 隧道就像把“坏东西”装进“正常快递盒子”里，WAF 只检查盒子外观，不会拆开看里面真正干了什么。</p>
<p>  👉 HTTP 隧道把恶意行为藏在合法的 HTTP 请求里，WAF 只检查语法像不像攻击，看不懂真实内容（内容上没有明显的攻击特征，甚至还是加密的），所以容易被绕过，在 WAF 眼中这就是一个正常的请求。</p>
<h2 id="7-Windows-通过什么子系统向内核请求服务？（-）"><a href="#7-Windows-通过什么子系统向内核请求服务？（-）" class="headerlink" title="7. Windows 通过什么子系统向内核请求服务？（ ）"></a>7. Windows 通过什么子系统向内核请求服务？（ ）</h2><p>A. <strong>Win32</strong>  B. POSIX  C. OS&#x2F;2  D. Linux</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. Win32（正确）</strong><br>Win32 子系统是 Windows 操作系统的核心子系统，也是唯一强制要求运行的子系统。所有 Windows 原生应用程序（无论是基于图形界面 GUI 还是命令行 CLI）都依赖 Win32 子系统运行。<br>当用户模式下的应用程序（例如记事本、浏览器等）需要访问操作系统核心功能（如文件操作、进程管理、内存分配、硬件访问等），会调用 Win32 API。因此，<strong>Win32 子系统是应用程序与 Windows 内核交互的主要和标准通道</strong>。</p>
</li>
<li><p>B. POSIX<br>Windows 历史上提供过 POSIX 子系统，用于运行符合 POSIX 标准的应用程序。它允许这些应用程序通过 POSIX API 调用内核服务。但是，POSIX 子系统是可选的，并非 Windows 核心架构的必需部分。</p>
</li>
<li><p>C. OS&#x2F;2<br>Windows NT 早期为了兼容性曾提供过 OS&#x2F;2 子系统，允许运行 OS&#x2F;2 1.x 字符模式应用程序。该子系统早已被废弃多年，在现代 Windows 中完全不存在。</p>
</li>
<li><p>D. Linux<br>属于不同操作系统内核，与 Windows 无关。</p>
</li>
</ul>
<h3 id="扩展-6"><a href="#扩展-6" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>Win32 API 是 Windows 应用访问文件、进程、内存等资源的主要接口</li>
<li>POSIX 是定义操作系统 API、命令行工具和行为规范的可移植操作系统接口标准，用于提高程序在不同系统间的可移植性。</li>
</ul>
<h2 id="8-数字证书中不属于主体（Subject）信息的是？（-）"><a href="#8-数字证书中不属于主体（Subject）信息的是？（-）" class="headerlink" title="8. 数字证书中不属于主体（Subject）信息的是？（ ）"></a>8. 数字证书中不属于主体（Subject）信息的是？（ ）</h2><p>A. 组织名  B. 机构名  C. 用户名  D. <strong>签发机构</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 签发机构（正确）</strong><br>签发机构属于 <strong>Issuer</strong> 字段，而非 Subject。</p>
</li>
<li><p>A. 组织名</p>
</li>
<li><p>B. 机构名</p>
</li>
<li><p>C. 用户名</p>
</li>
</ul>
<h3 id="扩展-7"><a href="#扩展-7" class="headerlink" title="扩展"></a>扩展</h3><table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>版本号（version）</td>
<td></td>
</tr>
<tr>
<td>证书序列号（serialNumber）</td>
<td></td>
</tr>
<tr>
<td>签名算法标识符（signature）</td>
<td></td>
</tr>
<tr>
<td>颁发者名称（issuer）</td>
<td></td>
</tr>
<tr>
<td>有效期（validity）</td>
<td>起始有效期 <br> 终止有效期</td>
</tr>
<tr>
<td>主体名称（subject）</td>
<td>countryName（国家）<br>  stateOrProvinceName（省份） <br> localityName（城市）<br>  organizationName（组织名称） <br> organizationalUnitName（机构名称）<br> commonName（用户名称）</td>
</tr>
<tr>
<td>主体公钥信息（subjectPublicKeyInfo）</td>
<td></td>
</tr>
<tr>
<td>颁发机构的密钥标识符（authorityKeyIdentifier）</td>
<td></td>
</tr>
<tr>
<td>主体密钥标识符（subjectKeyIdentifier）</td>
<td></td>
</tr>
<tr>
<td>CRL 分发点（CRLDistributionPoints）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="9-var-log-wtmp-文件记录的内容是？（-）"><a href="#9-var-log-wtmp-文件记录的内容是？（-）" class="headerlink" title="9. /var/log/wtmp 文件记录的内容是？（ ）"></a>9. <code>/var/log/wtmp</code> 文件记录的内容是？（ ）</h2><p>A. 当前用户登录信息<br>B. <strong>用户登录和注销历史</strong><br>C. 系统启动日志<br>D. 内核错误日志</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 用户登录和注销历史（正确）</strong><br><code>wtmp</code> 记录历史登录事件，可通过 <code>last</code> 命令查看。</p>
</li>
<li><p>A. 当前登录信息<br>当前登录信息记录在 <code>/var/run/utmp</code>。</p>
</li>
<li><p>C. 系统启动日志<br>通常记录在 <code>/var/log/boot.log</code> 或 journal 中。</p>
</li>
<li><p>D. 内核错误日志<br>内核日志在 <code>/var/log/kern.log</code> 或通过 <code>dmesg</code> 查看。</p>
</li>
</ul>
<h3 id="扩展-8"><a href="#扩展-8" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><code>utmp</code>：当前登录</li>
<li><code>wtmp</code>：历史登录</li>
<li><code>btmp</code>：失败登录（安全重点）</li>
</ul>
<h2 id="10-CNCERT-的全称是？（-）"><a href="#10-CNCERT-的全称是？（-）" class="headerlink" title="10. CNCERT 的全称是？（ ）"></a>10. CNCERT 的全称是？（ ）</h2><p>A. 国家应急相应中心<br>B. 国家网络安全中心<br>C. <strong>中国互联网应急中心</strong><br>D. 国家信息安全中心</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p>A. 国家应急相应中心<br>“应急响应中心”可以指很多领域（灾害、公共事件、网络、政务等），不具备 CNCERT 的“互联网&#x2F;网络应急”指向性。</p>
</li>
<li><p>B. 国家网络安全中心<br>通常指代国家计算机网络与信息安全管理中心（NCNIPC），而非 CNCERT</p>
</li>
<li><p><strong>C. 中国互联网应急中心（正确）</strong><br>CNCERT在国内更常见、也更规范的中文对应叫法是：国家互联网应急中心（常用名）其机构全称常见表述为：国家计算机网络应急技术处理协调中心（CNCERT&#x2F;CC）<br>在很多教材&#x2F;考试题里，会把 CNCERT 直接对应到“中国（国家）互联网应急中心”这一类说法，所以在给定四个选项里，C 是最准确的匹配。</p>
</li>
<li><p>D. 国家信息安全中心<br>非标准名称，易与中国信息安全测评中心（CNITSEC）混淆</p>
</li>
</ul>
<span id="more"></span>

<h2 id="11-Linux-中比较两个原始文件差异并输出具体差异内容的命令是？（-）"><a href="#11-Linux-中比较两个原始文件差异并输出具体差异内容的命令是？（-）" class="headerlink" title="11. Linux 中比较两个原始文件差异并输出具体差异内容的命令是？（ ）"></a>11. Linux 中比较两个原始文件差异并输出具体差异内容的命令是？（ ）</h2><p>A. cmp  B. scp  C. <strong>diff</strong>  D. comm</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. diff（正确）</strong><br>逐行比较两个文件（文本或二进制），并输出具体的差异内容（如添加、删除、修改的行）。</p>
</li>
<li><p>A. cmp<br>仅检查两个文件是否完全相同，若不同则报告第一个差异的字节位置（例如 file1 file2 differ: byte 10, line 2）。不显示具体差异内容，适用于快速校验文件一致性（如二进制文件），但不符合“比较差异”的需求</p>
</li>
<li><p>B. scp<br>用于跨主机安全复制文件（如 scp user@host:&#x2F;path&#x2F;file .），与文件比较无关</p>
</li>
<li><p>D. comm<br>比较两个已排序的文件，输出三列结果：仅第一个文件独有的行、仅第二个文件独有的行、两个文件共有的行。局限性：要求输入文件必须预先排序（否则结果错误），且不显示行内容变化细节（如修改），仅适合集合比较。</p>
</li>
</ul>
<h3 id="扩展-9"><a href="#扩展-9" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><code>diff</code> 是源码审计、配置审计中的常用工具</li>
<li><code>cmp</code> 更偏向“是否一致”的快速判断</li>
</ul>
<h2 id="12-SSL-VPN-密钥协商的工作模式是？（-）"><a href="#12-SSL-VPN-密钥协商的工作模式是？（-）" class="headerlink" title="12. SSL VPN 密钥协商的工作模式是？（ ）"></a>12. SSL VPN 密钥协商的工作模式是？（ ）</h2><p>A. ECB  B. <strong>Diffie-Hellman 密钥交换</strong>  C. CFB  D. CTR</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. Diffie-Hellman（正确）</strong><br>SSL&#x2F;TLS 使用 DH 或 ECDH 完成会话密钥协商，DH 密钥交换协议是非对称加密，是SSL&#x2F;TLS的核心密钥交换协议。</p>
</li>
<li><p>A. ECB<br>电子密码本模式，对称加密工作模式，不用于密钥协商。</p>
</li>
<li><p>C. CFB<br>对称加密反馈模式。</p>
</li>
<li><p>D. CTR<br>计数器模式，属于数据加密阶段。</p>
</li>
</ul>
<h3 id="扩展-10"><a href="#扩展-10" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><strong>密钥交换 ≠ 数据加密</strong></li>
<li>TLS 握手阶段完成密钥协商，之后才进行数据加密</li>
</ul>
<h2 id="13-SQL-Server-默认对外服务的端口是？（-）"><a href="#13-SQL-Server-默认对外服务的端口是？（-）" class="headerlink" title="13. SQL Server 默认对外服务的端口是？（ ）"></a>13. SQL Server 默认对外服务的端口是？（ ）</h2><p>A. <strong>TCP 1433</strong>  B. TCP 1521  C. UDP 1434  D. TCP 3306</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. TCP 1433（正确）</strong><br>SQL Server 默认监听端口。</p>
</li>
<li><p>B. TCP 1521<br>Oracle 数据库端口。</p>
</li>
<li><p>C. UDP 1434<br>SQL Server 浏览服务端口，用于实例发现。</p>
</li>
<li><p>D. TCP 3306<br>MySQL &#x2F; MariaDB 默认端口。</p>
</li>
</ul>
<h3 id="扩展-11"><a href="#扩展-11" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>数据库端口是<strong>渗透测试和防火墙策略常考点</strong></li>
</ul>
<h2 id="14-Windows-系统安全监测工具是？（-）"><a href="#14-Windows-系统安全监测工具是？（-）" class="headerlink" title="14. Windows 系统安全监测工具是？（ ）"></a>14. Windows 系统安全监测工具是？（ ）</h2><p>A. WinDump  B. ClamAV  C. OpenSSH  D. <strong>FPort</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. FPort（正确）</strong><br>可列出系统所有 TCP&#x2F;UDP 端口及对应进程 PID，常用于排查后门。</p>
</li>
<li><p>A. WinDump<br>网络抓包工具，偏向流量分析。</p>
</li>
<li><p>B. ClamAV<br>开源杀毒软件，反病毒引擎。</p>
</li>
<li><p>C. OpenSSH<br>提供了SSH远程登录功能，是一个远程管理工具，与安全监测无直接关系。</p>
</li>
</ul>
<h3 id="扩展-12"><a href="#扩展-12" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>FPort 常用于 <strong>端口 → 进程 → 木马定位</strong></li>
</ul>
<h2 id="15-Oracle-的-DV（Database-Vault）机制主要控制？（-）"><a href="#15-Oracle-的-DV（Database-Vault）机制主要控制？（-）" class="headerlink" title="15. Oracle 的 DV（Database Vault）机制主要控制？（ ）"></a>15. Oracle 的 DV（Database Vault）机制主要控制？（ ）</h2><p>A. 安全域和命令规则<br>B. 分级控制和数据库管理员权限<br>C. 数据加密和审计<br>D. 备份与恢复</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-14"><a href="#解析-14" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 分级控制和数据库管理员权限（正确）</strong><br>DV 通过最小权限原则限制 DBA 的越权访问。DV 通过职责分离和最小权限原则，限制 DBA 和其他高权限用户的访问范围，解决超级用户权利过大的安全隐患。</p>
</li>
<li><p>A. 安全域和命令规则<br>属于 DV 的子组件，但不是“主要控制目标”。</p>
</li>
<li><p>C. 数据加密和审计<br>分别属于 TDE 和 Audit Vault。</p>
</li>
<li><p>D. 备份与恢复<br>属于 RMAN 或 Data Guard 范畴，与 DV 无关</p>
</li>
</ul>
<h2 id="16-传输层-VPN-协议包括？（-）"><a href="#16-传输层-VPN-协议包括？（-）" class="headerlink" title="16. 传输层 VPN 协议包括？（ ）"></a>16. 传输层 VPN 协议包括？（ ）</h2><p>A. <strong>SSL VPN</strong>  B. IPSec VPN  C. PPTP VPN  D. L2TP VPN</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-15"><a href="#解析-15" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. SSL VPN（正确）</strong><br>基于传输层（SSL&#x2F;TLS）。</p>
</li>
<li><p>B. IPSec VPN<br>工作在网络层。</p>
</li>
<li><p>C. PPTP VPN<br>工作在数据链路层。</p>
</li>
<li><p>D. L2TP VPN<br>数据链路层协议。</p>
</li>
</ul>
<h3 id="扩展-13"><a href="#扩展-13" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>传输层 VPN &#x3D; SSL &#x2F; TLS</li>
</ul>
<h2 id="17-SSH-服务认证属于哪个子协议？（-）"><a href="#17-SSH-服务认证属于哪个子协议？（-）" class="headerlink" title="17. SSH 服务认证属于哪个子协议？（ ）"></a>17. SSH 服务认证属于哪个子协议？（ ）</h2><p>A. <strong>传输层协议</strong>  B. 用户认证协议  C. 连接协议  D. 密钥交换协议</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-16"><a href="#解析-16" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 传输层协议（正确）</strong><br>SSH 的传输层负责服务器认证、加密、完整性保护。</p>
</li>
<li><p>B. 用户认证协议<br>用于客户端身份认证（密码、公钥）。</p>
</li>
<li><p>C. 连接协议<br>用于多路复用逻辑通道。</p>
</li>
<li><p>D. 密钥交换协议<br>属于传输层内部机制，不是独立层次。</p>
</li>
</ul>
<p>SSH 协议被分为三层，每层职责明确：</p>
<p><strong>传输层协议</strong>：建立安全通道、服务器认证、加密算法协商、数据完整性保护，包括功能：<br>服务器主机认证（基于公钥指纹&#x2F;RSA&#x2F;ECDSA）密钥交换（Diffie-Hellman）协商加密算法（如 AES-GCM）</p>
<p><strong>用户认证协议</strong>：客户端用户身份认证（密码、公钥、键盘交互等）仅处理客户端认证</p>
<p><strong>连接协议</strong>：在安全通道上复用多个逻辑会话（如终端、SFTP、端口转发）与认证无关</p>
<h3 id="扩展-14"><a href="#扩展-14" class="headerlink" title="扩展"></a>扩展</h3><p>这道题考的是 <strong>SSH 服务器认证属于 SSH 的哪一层（子协议）</strong>。</p>
<p><strong>核心结论：选 A（传输层协议）</strong>。</p>
<p><strong>简要解读：</strong></p>
<ul>
<li>SSH 协议分为三层：<strong>传输层、用户认证层、连接层</strong>。</li>
<li><strong>服务器认证</strong>（验证你连的是不是真服务器）发生在<strong>建立安全通道时</strong>，依赖服务器的<strong>主机密钥</strong>（如 RSA&#x2F;ECDSA）。</li>
<li>这一过程属于 <strong>SSH 传输层协议</strong> 的职责。</li>
</ul>
<p><strong>一句话记忆：</strong></p>
<ul>
<li><strong>服务器认证 → 传输层</strong></li>
<li><strong>用户认证（密码&#x2F;公钥）→ 用户认证层</strong></li>
<li><strong>多路会话&#x2F;端口转发 → 连接层</strong></li>
</ul>
<h2 id="18-数据中心耐火等级应不低于？（-）"><a href="#18-数据中心耐火等级应不低于？（-）" class="headerlink" title="18. 数据中心耐火等级应不低于？（ ）"></a>18. 数据中心耐火等级应不低于？（ ）</h2><p>A. 一级  B. <strong>二级</strong>  C. 三级  D. 四级</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-17"><a href="#解析-17" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 二级（正确）</strong><br>符合《数据中心设计规范 GB 50174-2017》。</p>
</li>
<li><p>A &#x2F; C &#x2F; D<br>不符合国家标准要求。</p>
</li>
</ul>
<h3 id="扩展-15"><a href="#扩展-15" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>属于 <strong>工程安全 + 标准规范</strong> 常考点</li>
</ul>
<h2 id="19-响应网络防御中的第四道防线是？（-）"><a href="#19-响应网络防御中的第四道防线是？（-）" class="headerlink" title="19. 响应网络防御中的第四道防线是？（ ）"></a>19. 响应网络防御中的第四道防线是？（ ）</h2><p>A. 第一层  B. 第二层  C. <strong>第三道</strong>  D. 第四道</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-18"><a href="#解析-18" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 第三道（正确）</strong><br>第四道防线强调<strong>应急响应与恢复</strong>，其核心是第三道中的监测与处置。</p>
</li>
<li><p>其他选项<br>与防御纵深模型不匹配。</p>
</li>
</ul>
<h3 id="扩展-16"><a href="#扩展-16" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>防御纵深：预防保护 → 检测 → 响应 → 恢复</li>
<li>四道防线：安全保护是第一道，能够阻止对网络的入侵和危害；安全监测是第二道，可以及时发现入侵和破坏；实时响应是第三道，当攻击发生时维持网络“打不垮”；恢复是第四道，使网络在遭受攻击后能以最快的速度“起死回生”，最大限度地降低安全事件带来的损失。</li>
</ul>
<h2 id="20-通过-Word-文件传播的病毒是？（-）"><a href="#20-通过-Word-文件传播的病毒是？（-）" class="headerlink" title="20. 通过 Word 文件传播的病毒是？（ ）"></a>20. 通过 Word 文件传播的病毒是？（ ）</h2><p>A. 求职信  B. 熊猫烧香  C. <strong>Melissa</strong>  D. ILOVEYOU</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-19"><a href="#解析-19" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. Melissa（正确）</strong><br>通过 Word 宏病毒传播，是早期经典宏病毒。</p>
</li>
<li><p>A. 求职信<br>属于社会工程邮件类型，通过邮件附件形式（exe或scr传播），感染后破坏本地文件，属于可执行文件。</p>
</li>
<li><p>B. 熊猫烧香<br>可执行文件传播，通过局域网共享、U盘传播。</p>
</li>
<li><p>D. ILOVEYOU<br>VBS 脚本病毒，通过邮件附件传播，但非 Word 文档。</p>
</li>
</ul>
<h3 id="扩展-17"><a href="#扩展-17" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><strong>Word + 宏 &#x3D; 高风险组合</strong></li>
</ul>
<h2 id="21-改变文件属主属于哪种匿名化技术？（-）"><a href="#21-改变文件属主属于哪种匿名化技术？（-）" class="headerlink" title="21. 改变文件属主属于哪种匿名化技术？（ ）"></a>21. 改变文件属主属于哪种匿名化技术？（ ）</h2><p>A. <strong>置换</strong>  B. 抑制  C. 泛化  D. 扰动</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-20"><a href="#解析-20" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 置换（正确）</strong><br>改变数据的属主。</p>
</li>
<li><p>B. 抑制<br>直接删除或隐藏敏感字段。</p>
</li>
<li><p>C. 泛化<br>降低数据精度，如将具体年龄改为年龄段。</p>
</li>
<li><p>D. 扰动<br>扰动是通过对数据进行修改、添加噪声或改变属性值来隐藏真实信息。</p>
</li>
</ul>
<h3 id="扩展-18"><a href="#扩展-18" class="headerlink" title="扩展"></a>扩展</h3><p>目前，隐私保护的常见技术措施有抑制、泛化、置换、扰动、裁剪等。</p>
<ul>
<li><strong>抑制</strong>是通过将数据置空的方式限制数据发布；</li>
<li><strong>泛化</strong>是通过降低数据精度来提供匿名的方法；</li>
<li><strong>置换</strong>方法改变数据的属主；</li>
<li><strong>扰动</strong>是在数据发布时添加一定的噪声，包括数据增删、变换等，使攻击者无法区分真实数据和噪声数据，从而对攻击者造成干扰；</li>
<li><strong>裁剪</strong>是将敏感数据分开发布。</li>
</ul>
<h2 id="22-降低缓冲区溢出发生概率的有效措施是？（-）"><a href="#22-降低缓冲区溢出发生概率的有效措施是？（-）" class="headerlink" title="22. 降低缓冲区溢出发生概率的有效措施是？（ ）"></a>22. 降低缓冲区溢出发生概率的有效措施是？（ ）</h2><p>A. ASLR  B. 虚拟补丁  C. SEHOP  D. <strong>DEP</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-21"><a href="#解析-21" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. DEP（正确）</strong><br>DEP 是一种硬件或软件级别的安全机制，将内存区域（如栈和堆）标记为“不可执行”。当缓冲区溢出发生时，攻击者注入的恶意代码无法在这些区域执行，从而直接阻止了缓冲区溢出被成功利用。DEP 通过防止代码在数据区域执行，降低了缓冲区溢出攻击的成功概率，是缓解此类漏洞的核心措施之一。</p>
</li>
<li><p>A. ASLR<br>地址空间布局随机化 ASLR 通过随机化内存地址（如库函数和栈的基地址）增加攻击者预测地址的难度，从而降低缓冲区溢出利用的成功率。但它不直接防止溢出发生或代码执行，而是提高利用门槛，属于辅助措施，效果不如 DEP 直接。</p>
</li>
<li><p>B. 虚拟补丁<br>虚拟补丁是外部防护机制（如 WAF 或入侵检测系统），通过规则拦截已知攻击模式。它可以在不修改代码的情况下临时防御缓冲区溢出攻击，但仅针对已知漏洞，无法降低漏洞发生概率，且不涉及内存保护。</p>
</li>
<li><p>C. SEHOP<br>结构化异常处理程序覆盖保护 SEHOP 是 Windows 特有的机制，用于保护异常处理链（SEH）不被缓冲区溢出篡改。它专门防御基于 SEH 的溢出攻击（如 SEH 覆盖），但适用范围有限（仅 Windows 平台），且不防止其他类型的缓冲区溢出（如堆溢出）</p>
</li>
</ul>
<h2 id="23-将-TCP-报文-6-个标志位全部置空的扫描是？（-）"><a href="#23-将-TCP-报文-6-个标志位全部置空的扫描是？（-）" class="headerlink" title="23. 将 TCP 报文 6 个标志位全部置空的扫描是？（ ）"></a>23. 将 TCP 报文 6 个标志位全部置空的扫描是？（ ）</h2><p>A. <strong>NULL 扫描</strong>  B. FIN 扫描  C. XMAS 扫描  D. SYN 扫描</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-22"><a href="#解析-22" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. NULL 扫描（正确）</strong><br>TCP 标志位全部为 0。</p>
</li>
<li><p>B. FIN 扫描<br>只设置 FIN 位。</p>
</li>
<li><p>C. XMAS 扫描<br>XMAS 扫描是一种通过发送携带 FIN、PSH、URG 标志的异常 TCP 报文，根据目标是否返回 RST 来判断端口状态的隐蔽端口扫描技术。</p>
<p>之所以称为 XMAS（圣诞树）扫描，是因为在发送的 TCP 报文中同时设置了多个 TCP 标志位，看起来就像“挂满灯饰的圣诞树”。也可以理解为标志位全置 1</p>
</li>
<li><p>D. SYN 扫描<br>只设置 SYN 位，最常见。</p>
</li>
</ul>
<h3 id="扩展-19"><a href="#扩展-19" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>NULL &#x2F; FIN &#x2F; XMAS 都属于 <strong>隐蔽扫描</strong></li>
</ul>
<h2 id="24-通过物理特性和旁路信号检测硬件木马的手段是？（-）"><a href="#24-通过物理特性和旁路信号检测硬件木马的手段是？（-）" class="headerlink" title="24. 通过物理特性和旁路信号检测硬件木马的手段是？（ ）"></a>24. 通过物理特性和旁路信号检测硬件木马的手段是？（ ）</h2><p>A. <strong>侧信道分析</strong>  B. 逻辑测试  C. 功能分析  D. 代码审计</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-23"><a href="#解析-23" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 侧信道分析（正确）</strong><br>通过功耗、电磁辐射、时序等物理特征发现异常。</p>
</li>
<li><p>B. 逻辑测试<br>验证逻辑功能正确性，难以发现隐藏木马。</p>
</li>
<li><p>C. 功耗分析法<br>功耗分析法通过对比分析芯片的功耗特征，与纯净芯片进行对比来判断芯片是否被篡改。</p>
</li>
<li><p>D. 代码审计<br>适用于软件，不适用于硬件。</p>
</li>
</ul>
<h3 id="扩展-20"><a href="#扩展-20" class="headerlink" title="扩展"></a>扩展</h3><p>硬件木马检测有反向分析法、功耗分析法、侧信道分析法：</p>
<ul>
<li><p>反向分析法是通过逆向工程方法将封装（或管芯）的芯片电路打开，逐层扫描拍照电路，然后使用图形分析软件和电路提取软件重建电路结构图，将恢复出的设计与原始设计进行对比分析，以检测硬件木马。</p>
</li>
<li><p>功耗分析法通过获取芯片的功耗特征，通过 K.L 扩展分析法生成生成芯片指纹，再将待测试芯片与“纯净芯片”的功耗特征进行对比，以判断芯片是否被篡改。</p>
</li>
<li><p>侧信道分析法是通过对比电路中的物理特性和旁路信息的不同，发现电路的变化，其技术原理是任何硬件电路的改变都会反映在一些电路参数上，如功率、时序、电磁、热等。</p>
</li>
</ul>
<h2 id="25-使用不可信-EDA-软件设计-IC-芯片可能导致？（-）"><a href="#25-使用不可信-EDA-软件设计-IC-芯片可能导致？（-）" class="headerlink" title="25. 使用不可信 EDA 软件设计 IC 芯片可能导致？（ ）"></a>25. 使用不可信 EDA 软件设计 IC 芯片可能导致？（ ）</h2><p>A. <strong>设计阶段植入硬件木马</strong><br>B. 芯片性能下降<br>C. 物理损坏<br>D. 兼容性问题</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-24"><a href="#解析-24" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 设计阶段植入硬件木马（正确）</strong><br>恶意 EDA 工具可能在设计阶段（如 RTL 综合、布局布线）自动插入隐藏的硬件木马电路（如后门、触发器）</p>
</li>
<li><p>B. 芯片性能下降<br>次要风险　不可信工具可能导致低效设计，但非恶意行为核心目标</p>
</li>
<li><p>C. 物理损坏<br>极低　EDA 软件无法直接造成物理损坏（需配合制造缺陷或超频）</p>
</li>
<li><p>D. 兼容性问题<br>可能但非关键　设计错误可能导致接口问题，但安全威胁远低于硬件木马</p>
</li>
</ul>
<h3 id="扩展-21"><a href="#扩展-21" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>芯片安全强调 <strong>供应链可信</strong></li>
</ul>
<h2 id="26-不属于-APT-攻击阶段的是？（-）"><a href="#26-不属于-APT-攻击阶段的是？（-）" class="headerlink" title="26. 不属于 APT 攻击阶段的是？（ ）"></a>26. 不属于 APT 攻击阶段的是？（ ）</h2><p>A. 水坑攻击  B. 僵尸网络  C. 鱼叉邮件  D. <strong>网络流量劫持</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-25"><a href="#解析-25" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 网络流量劫持（正确）</strong><br>属于攻击技术，不是 APT 的典型阶段。</p>
</li>
<li><p>A. 水坑攻击<br>属于投递阶段，感染目标常访问的网站</p>
</li>
<li><p>B. 僵尸网络<br>属于 C2 控制阶段。</p>
</li>
<li><p>C. 鱼叉邮件<br>属于投递阶段，发送定向钓鱼邮件</p>
</li>
</ul>
<h3 id="扩展-22"><a href="#扩展-22" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>APT 五阶段：侦察 → 武器化 → 投递 → 利用 → 命令与控制</li>
</ul>
<p>（1）侦察（Reconnaissance）收集目标信息（如员工邮箱、系统漏洞）。</p>
<p>（2）武器化（Weaponization）制作恶意载体（如带漏洞的文档、木马程序）。</p>
<p>（3）投递（Delivery）A. 水坑攻击、C. 鱼叉邮件 属于此阶段！<br>水坑攻击：感染目标常访问的网站。<br>鱼叉邮件：发送定向钓鱼邮件。</p>
<p>（4）利用与安装（Exploitation &amp; Installation）利用漏洞植入后门（如恶意软件）。</p>
<p>（5）命令与控制（Command &amp; Control, C2）B. 僵尸网络 属于此阶段！攻击者通过僵尸网络控制受害主机。</p>
<h2 id="27-邮件服务的接收属于访问控制的哪个环节？（-）"><a href="#27-邮件服务的接收属于访问控制的哪个环节？（-）" class="headerlink" title="27. 邮件服务的接收属于访问控制的哪个环节？（ ）"></a>27. 邮件服务的接收属于访问控制的哪个环节？（ ）</h2><p>A. 主体  B. 客体  C. <strong>授权</strong>  D. 控制</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-26"><a href="#解析-26" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 授权（正确）</strong><br>判断用户是否有权限接收或访问邮件。</p>
</li>
<li><p>A. 主体<br>发起请求的用户。</p>
</li>
<li><p>B. 客体<br>被访问的资源（邮件内容）。</p>
</li>
<li><p>D. 控制<br>执行访问控制策略。</p>
</li>
</ul>
<h3 id="扩展-23"><a href="#扩展-23" class="headerlink" title="扩展"></a>扩展</h3><p>访问控制模型层面的划分：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主体（Subject）</strong></td>
<td>发起访问请求的实体</td>
</tr>
<tr>
<td><strong>客体（Object）</strong></td>
<td>被访问的资源</td>
</tr>
<tr>
<td><strong>授权（Authorization）</strong></td>
<td>判断主体是否有权限访问客体</td>
</tr>
<tr>
<td><strong>控制（Control）</strong></td>
<td>广义的访问控制机制（认证 + 授权 + 审计等）</td>
</tr>
</tbody></table>
<p>邮件服务的接收既不是发邮件也不是存邮件，而是判断某个用户是否有权限读取 &#x2F; 接收这封邮件，所以属于权限判断。</p>
<h2 id="28-Snort-从哪一层抓取数据？（-）"><a href="#28-Snort-从哪一层抓取数据？（-）" class="headerlink" title="28. Snort 从哪一层抓取数据？（ ）"></a>28. Snort 从哪一层抓取数据？（ ）</h2><p>A. 网络层  B. 传输层  C. 应用层  D. <strong>数据链路层</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-27"><a href="#解析-27" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>D. 数据链路层（正确）</strong><br>Snort 通过 libpcap（Linux 为 libpcap，Windows 为 WinPcap&#x2F;Npcap）直接从网卡驱动层捕获原始数据帧（包括以太网帧头、完整负载）。此时数据尚未被操作系统剥离链路层头部，也未传递给上层协议栈（如 IP&#x2F;TCP）。</li>
</ul>
<h3 id="扩展-24"><a href="#扩展-24" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>抓包位置越低，可见数据越原始</li>
</ul>
<h2 id="29-Snort-的检测技术基于？（-）"><a href="#29-Snort-的检测技术基于？（-）" class="headerlink" title="29. Snort 的检测技术基于？（ ）"></a>29. Snort 的检测技术基于？（ ）</h2><p>A. <strong>规则</strong>  B. 概率  C. 行为分析  D. 机器学习</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-28"><a href="#解析-28" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 规则（正确）</strong><br>Snort 是典型的基于规则的 IDS。<br>Snort 是基于规则的误用检测方法。将攻击行为或入侵模式表示成一种规则，只要符合规则就认定它是一种入侵行为。优点是检测起来比较简单，缺点是检测受到规则库限制，无法发现新的攻击，并且容易受干扰，Snort 是典型应用实例。</p>
</li>
<li><p>B &#x2F; C &#x2F; D<br>属于其他 IDS 类型，不是 Snort 核心机制。</p>
</li>
</ul>
<h2 id="30-实现内网-IP-映射到公网-IP-端口号的技术是？（-）"><a href="#30-实现内网-IP-映射到公网-IP-端口号的技术是？（-）" class="headerlink" title="30. 实现内网 IP 映射到公网 IP 端口号的技术是？（ ）"></a>30. 实现内网 IP 映射到公网 IP 端口号的技术是？（ ）</h2><p>A. <strong>PAT</strong>  B. NAT  C. DNAT  D. SNAT</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-29"><a href="#解析-29" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. PAT（正确）</strong><br>动态复用端口号，实现多台内网主机共享一个公网 IP（核心能力）</p>
</li>
<li><p>B. NAT<br>泛指网络地址转换（包含 PAT），但基础 NAT 仅支持 1:1 IP 映射（不涉及端口）</p>
</li>
<li><p>C. DNAT<br>目标地址转换（Destination NAT），用于公网访问内网服务（如端口转发）</p>
</li>
<li><p>D. SNAT<br>源地址转换（Source NAT），用于内网主机主动访问公网（PAT 属于 SNAT 的子集）</p>
</li>
</ul>
<h3 id="扩展-25"><a href="#扩展-25" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>家庭宽带、公司出口网常用 <strong>PAT</strong></li>
</ul>
<h2 id="31-用于破解-Windows-密码的工具是？（-）"><a href="#31-用于破解-Windows-密码的工具是？（-）" class="headerlink" title="31. 用于破解 Windows 密码的工具是？（ ）"></a>31. 用于破解 Windows 密码的工具是？（ ）</h2><p>A. <strong>John the Ripper</strong>  B. L0phtCrack  C. Wireshark  D. Metasploit</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-30"><a href="#解析-30" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. John the Ripper（正确）</strong><br>开源的密码破解工具，专门设计用于破解多种系统的密码哈希，包括 Windows 的 LM（LAN Manager）和 NTLM（NT LAN Manager）哈希。<br>工作原理：通过字典攻击、暴力破解或彩虹表等方式，破解从 SAM（Security Account Manager）文件或 Active Directory 导出的哈希。<br>适用性：跨平台（支持 Windows、Linux、macOS），是 Kali Linux 等渗透测试发行版的预装工具，广泛用于安全审计和 CTF 竞赛。<br>典型用途：破解 Windows 用户密码（如从 SAM 或 NTDS.dit 文件中提取的哈希）。</p>
</li>
<li><p>B. L0phtCrack<br>功能：商业密码恢复工具，专为 Windows 系统设计，支持快速破解 LM&#x2F;NTLM 哈希。<br>工作原理：通过本地或远程提取哈希（如从 SAM 或域控制器），结合字典、彩虹表和分布式破解技术。<br>适用性：曾是 Windows 密码破解的行业标准，但现已较少更新（当前版本为 LC7），部分功能被集成到其他工具中。<br>注意：虽可破解 Windows 密码，但不如 John the Ripper 通用和开源。</p>
</li>
<li><p>C. Wireshark<br>功能：网络协议分析工具，用于抓包和流量分析。与密码破解关系：无法直接破解密码，仅可捕获网络中的明文密码（如 HTTP&#x2F;FTP），但对 Windows 本地密码无效。</p>
</li>
<li><p>D. Metasploit<br>功能：渗透测试框架，用于漏洞利用和后渗透操作。与密码破解的关系：包含模块（如 hashdump）可提取 Windows 哈希，但破解需依赖外部工具（如 John the Ripper），本身不直接提供密码破解功能。</p>
</li>
</ul>
<h2 id="32-Linux-中-passwd-和-shadow-文件存放的目录是？（-）"><a href="#32-Linux-中-passwd-和-shadow-文件存放的目录是？（-）" class="headerlink" title="32. Linux 中 passwd 和 shadow 文件存放的目录是？（ ）"></a>32. Linux 中 <code>passwd</code> 和 <code>shadow</code> 文件存放的目录是？（ ）</h2><p>A. <strong>&#x2F;etc</strong>  B. &#x2F;var&#x2F;log  C. &#x2F;home  D. &#x2F;usr&#x2F;bin</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-31"><a href="#解析-31" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. &#x2F;etc（正确）</strong><br><code>/etc/passwd</code> 和 <code>/etc/shadow</code> 都位于 <code>/etc</code> 目录。</p>
</li>
<li><p>B. &#x2F;var&#x2F;log<br>日志目录。</p>
</li>
<li><p>C. &#x2F;home<br>用户主目录。</p>
</li>
<li><p>D. &#x2F;usr&#x2F;bin<br>可执行程序目录。</p>
</li>
</ul>
<h3 id="扩展-26"><a href="#扩展-26" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><code>passwd</code>：用户信息</li>
<li><code>shadow</code>：加密口令（仅 root 可读）</li>
</ul>
<h2 id="33-恶意代码静态检测方法包括？（-）"><a href="#33-恶意代码静态检测方法包括？（-）" class="headerlink" title="33. 恶意代码静态检测方法包括？（ ）"></a>33. 恶意代码静态检测方法包括？（ ）</h2><p>A. 网络协议分析  B. <strong>文件指纹校验</strong>  C. 行为监控  D. 沙箱执行</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-32"><a href="#解析-32" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 文件指纹校验（正确）</strong><br>通过哈希值比对识别已知恶意代码，是典型静态检测技术。</p>
</li>
<li><p>A. 网络协议分析<br>属于流量分析，不是恶意代码本体检测。</p>
</li>
<li><p>C. 行为监控<br>属于动态分析。</p>
</li>
<li><p>D. 沙箱执行<br>属于动态检测手段。</p>
</li>
</ul>
<h3 id="扩展-27"><a href="#扩展-27" class="headerlink" title="扩展"></a>扩展</h3><p>恶意代码检测技术措施是评估恶意代码检测能力的重要依据。技术检测措施通常包括静态检测和动态检测。其中，静态检测通过搜索目标对象中是否蕴含恶意代码的标识特征来识别，或者通过文件指纹来辨别。而动态检测措施则利用恶意代码运行的行为特征或活动轨迹来判定，具体技术包括安全沙箱、动态调试、系统监测、网络协议分析等。</p>
<h2 id="34-关于防火墙的说法错误的是？（-）"><a href="#34-关于防火墙的说法错误的是？（-）" class="headerlink" title="34. 关于防火墙的说法错误的是？（ ）"></a>34. 关于防火墙的说法错误的是？（ ）</h2><p>A. 支持黑白名单<br>B. <strong>是隔离内外网络的唯一通道</strong><br>C. 不能防御内部攻击<br>D. 可过滤应用层内容</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-33"><a href="#解析-33" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 是隔离内外网络的唯一通道（错误项，正确答案）</strong><br>防火墙并非唯一隔离手段，还包括物理隔离、单向网闸等。</p>
</li>
<li><p>A. 支持黑白名单<br>正确。</p>
</li>
<li><p>C. 不能防御内部攻击<br>一般成立。</p>
</li>
<li><p>D. 可过滤应用层内容<br>应用层防火墙支持。</p>
</li>
</ul>
<h3 id="扩展-28"><a href="#扩展-28" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>防火墙 ≠ 万能安全设备</li>
</ul>
<h2 id="35-Windows-注册表文件保存的目录是？（-）"><a href="#35-Windows-注册表文件保存的目录是？（-）" class="headerlink" title="35. Windows 注册表文件保存的目录是？（ ）"></a>35. Windows 注册表文件保存的目录是？（ ）</h2><p>A. <strong>C:\Windows\System32\config</strong><br>B. C:\Windows\System<br>C. C:\Windows\Regedit<br>D. C:\Windows\SysWOW64</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-34"><a href="#解析-34" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. C:\Windows\System32\config（正确）</strong><br>包含 SAM、SYSTEM、SECURITY 等注册表文件。</p>
</li>
<li><p>其他选项<br>均不是注册表实际存储位置。</p>
</li>
</ul>
<h2 id="36-Kerberos-票据（Ticket）不包含的元素是？（-）"><a href="#36-Kerberos-票据（Ticket）不包含的元素是？（-）" class="headerlink" title="36. Kerberos 票据（Ticket）不包含的元素是？（ ）"></a>36. Kerberos 票据（Ticket）不包含的元素是？（ ）</h2><p>A. 生存期  B. 客户端 IP 地址  C. 时间戳  D. <strong>服务器 IP 地址</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-35"><a href="#解析-35" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>D. 服务器 IP 地址（正确）</strong><br>Ticket 中包含服务主体名，而非 IP 地址。</li>
</ul>
<h3 id="扩展-29"><a href="#扩展-29" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>Kerberos 基于 <strong>时间戳 + 对称密钥</strong>，票据（Ticket）是用于安全的传递用户身份所需要的信息的集合，主要包括客户端 Principal、目的服务方 Principal、客户端 IP 地址、时间戳（分发该 Ticket 的时间）、Ticket 的生存期，以及会话密钥等内容。</li>
</ul>
<h2 id="37-KDC（密钥分发中心）的组成是？（-）"><a href="#37-KDC（密钥分发中心）的组成是？（-）" class="headerlink" title="37. KDC（密钥分发中心）的组成是？（ ）"></a>37. KDC（密钥分发中心）的组成是？（ ）</h2><p>A. <strong>AS 和 TGS</strong>  B. AS 和应用服务器  C. CA 和 RA  D. TGS 和 SS</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-36"><a href="#解析-36" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>A. AS 和 TGS（正确）</strong><br>KDC &#x3D; Authentication Server + Ticket Granting Server。</li>
</ul>
<h3 id="扩展-30"><a href="#扩展-30" class="headerlink" title="扩展"></a>扩展</h3><p>一个 Kerberos 系统涉及四个基本实体：<br>（1）Kerberos 客户机，用户用来访问服务器设备；<br>（2）AS（Authentication Server，认证服务器），识别用户身份并提供 TGS 会话密钥；<br>（3）TGS（Ticket Granting Server，票据发放服务器），为申请服务的用户授予票据（Ticket）；<br>（4）应用服务器（Application Server），为用户提供服务的设备或系统。</p>
<p>其中，通常将 AS 和 TGS 统称为 KDC（Key Distribution Center）。</p>
<h2 id="38-不属于-APT-攻击的是？（-）"><a href="#38-不属于-APT-攻击的是？（-）" class="headerlink" title="38. 不属于 APT 攻击的是？（ ）"></a>38. 不属于 APT 攻击的是？（ ）</h2><p>A. Operation Aurora<br>B. <strong>SYN Flood</strong><br>C. Equation Group<br>D. Stuxnet</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-37"><a href="#解析-37" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. SYN Flood（正确）</strong><br>属于 DoS 攻击，不是 APT。</p>
</li>
<li><p>A &#x2F; C &#x2F; D<br>均是典型 APT 攻击或组织。</p>
</li>
</ul>
<h3 id="扩展-31"><a href="#扩展-31" class="headerlink" title="扩展"></a>扩展</h3><p>APT 的特点：长期、隐蔽、定向，经典 APT 攻击案例：</p>
<ul>
<li><strong>Operation Aurora（2009）</strong>：定向攻击多家跨国企业，窃取源代码&#x2F;邮箱等核心资产。</li>
<li><strong>Stuxnet（2010）</strong>：针对工控系统的定向破坏，国家级攻击代表。</li>
<li><strong>SolarWinds（2020）</strong>：供应链投毒，通过软件更新渗透大量机构。</li>
<li><strong>NotPetya（2017）</strong>：伪装勒索、强破坏性攻击，造成大范围业务瘫痪。</li>
</ul>
<p><strong>典型 APT 组织（常见称呼）</strong></p>
<ul>
<li><strong>Equation Group</strong>：顶级能力组织，长期潜伏与高隐蔽性代表。</li>
<li><strong>APT28 &#x2F; Fancy Bear</strong>：定向窃密与信息战相关活动频繁。</li>
<li><strong>APT29 &#x2F; Cozy Bear</strong>：擅长长期潜伏、凭证&#x2F;邮件体系渗透。</li>
<li><strong>Sandworm</strong>：破坏性行动、关键基础设施攻击相关。</li>
<li><strong>Lazarus Group</strong>：情报与金融&#x2F;破坏行动并行，影响广。</li>
</ul>
<h2 id="39-DAC（自主访问控制）的定义是？（-）"><a href="#39-DAC（自主访问控制）的定义是？（-）" class="headerlink" title="39. DAC（自主访问控制）的定义是？（ ）"></a>39. DAC（自主访问控制）的定义是？（ ）</h2><p>A. <strong>用户按自身策略授权</strong><br>B. 系统强制分配权限<br>C. 基于角色分配权限<br>D. 基于属性动态授权</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-38"><a href="#解析-38" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 用户按自身策略授权（正确）</strong><br>资源所有者决定访问权限。</p>
</li>
<li><p>B. 系统强制分配 MAC</p>
</li>
<li><p>C. 基于角色 RBAC</p>
</li>
<li><p>D. 基于属性 ABAC</p>
</li>
</ul>
<h3 id="扩展-32"><a href="#扩展-32" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>DAC：灵活但安全性较弱</li>
</ul>
<h2 id="40-软件白名单的身份标识通常基于？（-）"><a href="#40-软件白名单的身份标识通常基于？（-）" class="headerlink" title="40. 软件白名单的身份标识通常基于？（ ）"></a>40. 软件白名单的身份标识通常基于？（ ）</h2><p>A. 软件名称<br>B. 软件发布者<br>C. <strong>软件哈希值</strong><br>D. 软件二进制大小</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-39"><a href="#解析-39" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>C. 软件哈希值（正确）</strong><br>哈希值唯一标识程序完整性。</li>
</ul>
<h3 id="扩展-33"><a href="#扩展-33" class="headerlink" title="扩展"></a>扩展</h3><p>在软件白名单技术的实现过程中，常利用软件对应的进程名称、软件文件名称、软件发行商名称、软件二进制程序等相关信息经过密码技术处理后，形成软件白名单身份标识，如软件数字签名或软件 Hash 值。然后，在此基础上进行软件白名单身份检查确认，最后依据软件白名单身份检查结果来控制软件的运行。</p>
<h2 id="41-src-x-y-z-中的-src-表示？（-）"><a href="#41-src-x-y-z-中的-src-表示？（-）" class="headerlink" title="41. src.x.y.z 中的 src 表示？（ ）"></a>41. <code>src.x.y.z</code> 中的 <code>src</code> 表示？（ ）</h2><p>A. <strong>源地址</strong>  B. 目的地址  C. 网络地址  D. 主机地址</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-40"><a href="#解析-40" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 源地址（正确）</strong><br><code>src</code> 是 source 的缩写，表示数据包的源地址。</p>
</li>
<li><p>B. 目的地址<br>通常使用 <code>dst</code> 表示。</p>
</li>
<li><p>C. 网络地址<br>不是协议字段名。</p>
</li>
<li><p>D. 主机地址<br>属于地址含义分类，不是字段名称。</p>
</li>
</ul>
<h2 id="42-ICT-供应链安全目标不包括？（-）"><a href="#42-ICT-供应链安全目标不包括？（-）" class="headerlink" title="42. ICT 供应链安全目标不包括？（ ）"></a>42. ICT 供应链安全目标不包括？（ ）</h2><p>A. 保密性  B. 完整性  C. <strong>不可抵赖性</strong>  D. 可用性</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-41"><a href="#解析-41" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>C. 不可抵赖性（正确）</strong><br>ICT 供应链安全威胁识别参考：ICT 是 Information and Communication Technology 的缩写。</li>
</ul>
<h3 id="扩展-34"><a href="#扩展-34" class="headerlink" title="扩展"></a>扩展</h3><p>  ICT 供应链风险管理的主要目标如下：<br>  完整性：确保在 ICT 供应链的所有环节中，产品、系统、服务及其所包含的组件、部件、元器件、数据等不 被植入、篡改、替换和伪造。<br>  保密性：确保 ICT 供应链上传递的信息不被泄露给未授权者。<br>  可用性：确保需求对 ICT 供应链的使用不会被不合理地拒绝。<br>  可控性：可控性是指需求方对 ICT 产品、服务或供应链的控制能力。</p>
<p>  ICT 供应链主要面临恶意篡改、假冒伪劣、供应中断、信息泄露或违规操作和其他威胁及关键信息基础设施安全威胁。</p>
<h2 id="43-关于网闸（Data-Diode）说法错误的是？（-）"><a href="#43-关于网闸（Data-Diode）说法错误的是？（-）" class="headerlink" title="43. 关于网闸（Data Diode）说法错误的是？（ ）"></a>43. 关于网闸（Data Diode）说法错误的是？（ ）</h2><p>A. 支持文件单向传输<br>B. 主机对网闸可透明操作<br>C. 两台主机操作互斥<br>D. <strong>可防御数字驱动型攻击</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-42"><a href="#解析-42" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 可防御数字驱动型攻击（错误项，正确答案）</strong><br>数字驱动攻击（如 BadUSB）不依赖网络，网闸无法防御。数字驱动型攻击通过恶意外设（U 盘、键盘）触发操作系统漏洞，完全不依赖网络传输。网闸仅能控制网络数据的单向流动，无法防御连接在主机本地的恶意硬件设备。</p>
</li>
<li><p>A &#x2F; B &#x2F; C<br>均符合网闸工作特性。</p>
</li>
</ul>
<h2 id="44-采用椭圆曲线算法的国产密码是？（-）"><a href="#44-采用椭圆曲线算法的国产密码是？（-）" class="headerlink" title="44. 采用椭圆曲线算法的国产密码是？（ ）"></a>44. 采用椭圆曲线算法的国产密码是？（ ）</h2><p>A. SM1  B. <strong>SM2</strong>  C. SM3  D. SM4</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-43"><a href="#解析-43" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>B. SM2（正确）</strong><br>基于椭圆曲线密码体制（ECC）。</li>
</ul>
<h3 id="扩展-35"><a href="#扩展-35" class="headerlink" title="扩展"></a>扩展</h3><table>
<thead>
<tr>
<th>算法名称</th>
<th>算法特性描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>SM1</td>
<td>对称加密，分组长度和密钥长度都为 128 比特</td>
<td></td>
</tr>
<tr>
<td>SM2</td>
<td>非对称加密，用于公钥加密算法、密钥交换协议、数字签名算法</td>
<td>国家标准推荐使用素数域 256 位椭圆曲线</td>
</tr>
<tr>
<td>SM3</td>
<td>杂凑算法，杂凑值长度为 256 比特</td>
<td></td>
</tr>
<tr>
<td>SM4</td>
<td>对称加密，分组长度和密钥长度都为 128 比特</td>
<td></td>
</tr>
<tr>
<td>SM9</td>
<td>标识密码算法</td>
<td></td>
</tr>
</tbody></table>
<h2 id="45-Alice-向-Bob-发送数字签名时使用的密钥是？（-）"><a href="#45-Alice-向-Bob-发送数字签名时使用的密钥是？（-）" class="headerlink" title="45. Alice 向 Bob 发送数字签名时使用的密钥是？（ ）"></a>45. Alice 向 Bob 发送数字签名时使用的密钥是？（ ）</h2><p>A. <strong>Alice 的私钥</strong>  B. Alice 的公钥  C. Bob 的私钥  D. Bob 的公钥</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-44"><a href="#解析-44" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>A. Alice 的私钥（正确）</strong><br>数字签名由发送方私钥生成。</li>
</ul>
<h3 id="扩展-36"><a href="#扩展-36" class="headerlink" title="扩展"></a>扩展</h3><p>数字签名是一种基于<strong>非对称密码</strong>的技术，用来证明“<strong>是谁发的</strong>”以及“<strong>内容有没有被改</strong>”。</p>
<ul>
<li><p><strong>怎么做</strong>：发送方先对消息做 <strong>Hash</strong> 得到摘要，再用<strong>自己的私钥</strong>对摘要进行签名；接收方用<strong>发送方的公钥</strong>验证签名是否匹配。</p>
</li>
<li><p><strong>能解决什么</strong>：</p>
<ol>
<li><strong>身份认证</strong>：确认签名者确实是私钥持有人；</li>
<li><strong>完整性</strong>：消息被篡改会验证失败；</li>
<li><strong>不可否认性</strong>：签名者事后难以否认自己签过（私钥需妥善保管）。</li>
</ol>
</li>
<li><p><strong>注意</strong>：数字签名不是用来保密内容的；要保密需再配合<strong>加密</strong>（如用对称加密传输内容、用公钥加密会话密钥）。</p>
</li>
</ul>
<h2 id="46-攻击树模型的缺点是？（-）"><a href="#46-攻击树模型的缺点是？（-）" class="headerlink" title="46. 攻击树模型的缺点是？（ ）"></a>46. 攻击树模型的缺点是？（ ）</h2><p>A. <strong>无法建模循环事件</strong><br>B. 起源于故障树分析<br>C. 难以量化风险<br>D. 依赖专家经验</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-45"><a href="#解析-45" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>A. 无法建模循环事件（正确）</strong><br>攻击树是层次结构，无法表达循环依赖。</li>
</ul>
<h3 id="扩展-37"><a href="#扩展-37" class="headerlink" title="扩展"></a>扩展</h3><p>攻击树模型：起源于故障树分析方法，经过扩展用 AND-OR 形式的树结构对目标对象进行网络安全威胁分析。可以被 Red Team 用来进行渗透测试，同时也可以被 Blue Team 用来研究防御机制。</p>
<p>优点：能够采取专家头脑风暴法，并且将这些意见融合到攻击树中去；能够进行绩效分析或者概率分析；能够建模非常复杂的攻击场景。</p>
<p>缺点：由于树结构的内在限制，攻击树不能用来建模多重常识攻击、时间依赖及访问控制等场景；不能用来建模循环事件；对于现实中的大规模网络，攻击树方法处理起来将会特别复杂。</p>
<h2 id="47-等级-2-0-要求对系统引导程序进行可信验证的级别是？（-）"><a href="#47-等级-2-0-要求对系统引导程序进行可信验证的级别是？（-）" class="headerlink" title="47. 等级 2.0 要求对系统引导程序进行可信验证的级别是？（ ）"></a>47. 等级 2.0 要求对系统引导程序进行可信验证的级别是？（ ）</h2><p>A. 第一级  B. 第二级  C. <strong>第三级</strong>  D. 第四级</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-46"><a href="#解析-46" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>C. 第三级（正确）</strong><br>第三级要求系统程序（含引导程序）进行可信验证。</li>
</ul>
<h3 id="扩展-38"><a href="#扩展-38" class="headerlink" title="扩展"></a>扩展</h3><p>等保 2.0</p>
<p>第一级：无可信验证相关要求<br>第二级：仅要求对用户身份、重要程序等进行可信验证（如登录认证），未涉及系统引导程序<br>第三级：强制要求对系统引导程序、系统程序等进行可信验证<br>第四级：在第三级基础上增加动态验证，覆盖更多组件</p>
<h2 id="48-等级-2-0-从哪一级开始要求安全审计？（-）"><a href="#48-等级-2-0-从哪一级开始要求安全审计？（-）" class="headerlink" title="48. 等级 2.0 从哪一级开始要求安全审计？（ ）"></a>48. 等级 2.0 从哪一级开始要求安全审计？（ ）</h2><p>A. 第一级  B. <strong>第二级</strong>  C. 第三级  D. 第四级</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-47"><a href="#解析-47" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 第二级（正确）</strong><br>第二级开始要求记录和审计重要安全事件。</p>
</li>
<li><p>A<br>无明确审计要求。</p>
</li>
<li><p>C &#x2F; D<br>在第二级基础上增强。</p>
</li>
</ul>
<h2 id="49-网络信息资产不包括？（-）"><a href="#49-网络信息资产不包括？（-）" class="headerlink" title="49. 网络信息资产不包括？（ ）"></a>49. 网络信息资产不包括？（ ）</h2><p>A. IP 地址  B. MAC 地址  C. 网络拓扑图  D. <strong>通信软件</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-48"><a href="#解析-48" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 通信软件（正确）</strong><br>属于软件资产，而非网络信息资产。</p>
</li>
<li><p>A &#x2F; B &#x2F; C<br>均属于网络信息资产范畴。</p>
</li>
</ul>
<h2 id="50-第二代交换机工作的-OSI-层是？（-）"><a href="#50-第二代交换机工作的-OSI-层是？（-）" class="headerlink" title="50. 第二代交换机工作的 OSI 层是？（ ）"></a>50. 第二代交换机工作的 OSI 层是？（ ）</h2><p>A. 网络层  B. <strong>数据链路层</strong>  C. 传输层  D. 应用层</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-49"><a href="#解析-49" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 数据链路层（正确）</strong><br>二层交换机基于 MAC 地址转发。</p>
</li>
<li><p>A<br>属于三层交换机功能。</p>
</li>
<li><p>C &#x2F; D<br>不属于交换机工作层次。</p>
</li>
</ul>
<h2 id="51-属于主动攻击的是？（-）"><a href="#51-属于主动攻击的是？（-）" class="headerlink" title="51. 属于主动攻击的是？（ ）"></a>51. 属于主动攻击的是？（ ）</h2><p>A. 流量分析  B. 重放攻击  C. <strong>拒绝服务攻击</strong>  D. 嗅探</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-50"><a href="#解析-50" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 拒绝服务攻击（正确）</strong><br>主动破坏系统可用性，直接影响正常服务。</p>
</li>
<li><p>A. 流量分析<br>被动监听行为。</p>
</li>
<li><p>B. 重放攻击<br>通常被归类为被动或中间人攻击。</p>
</li>
<li><p>D. 嗅探<br>被动监听数据。</p>
</li>
</ul>
<h2 id="52-属于网络层加密技术的是？（-）"><a href="#52-属于网络层加密技术的是？（-）" class="headerlink" title="52. 属于网络层加密技术的是？（ ）"></a>52. 属于网络层加密技术的是？（ ）</h2><p>A. SSL  B. SSH  C. <strong>IPSec</strong>  D. PGP</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-51"><a href="#解析-51" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. IPSec（正确）</strong><br>工作在 OSI 网络层。</p>
</li>
<li><p>A. SSL<br>传输层。</p>
</li>
<li><p>B. SSH<br>应用层。</p>
</li>
<li><p>D. PGP<br>应用层数据加密。</p>
</li>
</ul>
<h2 id="53-信息系统安全等级保护的基本对象是？（-）"><a href="#53-信息系统安全等级保护的基本对象是？（-）" class="headerlink" title="53. 信息系统安全等级保护的基本对象是？（ ）"></a>53. 信息系统安全等级保护的基本对象是？（ ）</h2><p>A. 网络  B. 设备  C. 数据  D. <strong>信息系统</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-52"><a href="#解析-52" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 信息系统（正确）</strong><br>等保的定级、备案、测评对象是信息系统整体。</p>
</li>
<li><p>A &#x2F; B &#x2F; C<br>都是系统中的组成要素，而非基本对象。</p>
</li>
</ul>
<h2 id="54-关于对称加密算法说法正确的是？（-）"><a href="#54-关于对称加密算法说法正确的是？（-）" class="headerlink" title="54. 关于对称加密算法说法正确的是？（ ）"></a>54. 关于对称加密算法说法正确的是？（ ）</h2><p>A. 加解密使用不同密钥<br>B. <strong>加解密使用同一密钥</strong><br>C. 密钥分发容易<br>D. 安全性依赖公钥</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-53"><a href="#解析-53" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>B. 加解密使用同一密钥（正确）</strong></p>
</li>
<li><p>A<br>属于非对称加密。</p>
</li>
<li><p>C<br>对称加密的主要难点就是密钥分发。</p>
</li>
<li><p>D<br>公钥体系不适用于对称算法。</p>
</li>
</ul>
<h2 id="55-防止-SQL-注入最有效的方法是？（-）"><a href="#55-防止-SQL-注入最有效的方法是？（-）" class="headerlink" title="55. 防止 SQL 注入最有效的方法是？（ ）"></a>55. 防止 SQL 注入最有效的方法是？（ ）</h2><p>A. 黑名单过滤<br>B. 输入长度限制<br>C. <strong>预编译语句</strong><br>D. 字符替换</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-54"><a href="#解析-54" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 预编译语句（正确）</strong><br>将 SQL 结构与参数分离，从根本上防御注入。</p>
</li>
<li><p>A &#x2F; B &#x2F; D<br>都属于绕过风险较高的防御方式。</p>
</li>
</ul>
<h2 id="56-信息安全管理体系（ISMS）的核心是？（-）"><a href="#56-信息安全管理体系（ISMS）的核心是？（-）" class="headerlink" title="56. 信息安全管理体系（ISMS）的核心是？（ ）"></a>56. 信息安全管理体系（ISMS）的核心是？（ ）</h2><p>A. 技术措施<br>B. 管理制度<br>C. <strong>风险管理</strong><br>D. 安全产品</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-55"><a href="#解析-55" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 风险管理（正确）</strong><br>ISO&#x2F;IEC 27001 的核心思想。</p>
</li>
<li><p>A &#x2F; B &#x2F; D<br>都是风险管理的支撑手段。</p>
</li>
</ul>
<h2 id="57-以下哪项属于完整性保护技术？（-）"><a href="#57-以下哪项属于完整性保护技术？（-）" class="headerlink" title="57. 以下哪项属于完整性保护技术？（ ）"></a>57. 以下哪项属于完整性保护技术？（ ）</h2><p>A. 加密  B. 访问控制  C. <strong>数字签名</strong>  D. 身份认证</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-56"><a href="#解析-56" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 数字签名（正确）</strong><br>可验证数据是否被篡改。</p>
</li>
<li><p>A<br>主要保障保密性。</p>
</li>
<li><p>B<br>控制访问权限。</p>
</li>
<li><p>D<br>验证身份真实性。</p>
</li>
</ul>
<h2 id="58-关于-PKI-的说法正确的是？（-）"><a href="#58-关于-PKI-的说法正确的是？（-）" class="headerlink" title="58. 关于 PKI 的说法正确的是？（ ）"></a>58. 关于 PKI 的说法正确的是？（ ）</h2><p>A. 只用于对称加密<br>B. 不需要 CA<br>C. <strong>提供证书管理体系</strong><br>D. 不能支持数字签名</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-57"><a href="#解析-57" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 提供证书管理体系（正确）</strong><br>PKI 核心是证书的签发、管理、撤销。</p>
</li>
<li><p>A<br>PKI 主要用于非对称密码体系。</p>
</li>
<li><p>B<br>CA 是 PKI 的核心组成部分。</p>
</li>
<li><p>D<br>PKI 广泛用于数字签名。</p>
</li>
</ul>
<h2 id="59-根据《个人信息保护法》，敏感信息不包括？（-）"><a href="#59-根据《个人信息保护法》，敏感信息不包括？（-）" class="headerlink" title="59. 根据《个人信息保护法》，敏感信息不包括？（ ）"></a>59. 根据《个人信息保护法》，敏感信息不包括？（ ）</h2><p>A. <strong>姓名</strong>  B. 生物识别信息  C. 医疗健康信息  D. 行踪轨迹</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-58"><a href="#解析-58" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 姓名（正确）</strong><br>姓名属于一般个人信息，单独使用通常不构成敏感个人信息。</p>
</li>
<li><p>B. 生物识别信息<br>指纹、人脸等，明确属于敏感个人信息。</p>
</li>
<li><p>C. 医疗健康信息<br>属于高度敏感信息。</p>
</li>
<li><p>D. 行踪轨迹<br>可反映个人活动规律，属于敏感个人信息。</p>
</li>
</ul>
<h2 id="60-权限低的用户向权限高的文件写入称为？（-）"><a href="#60-权限低的用户向权限高的文件写入称为？（-）" class="headerlink" title="60. 权限低的用户向权限高的文件写入称为？（ ）"></a>60. 权限低的用户向权限高的文件写入称为？（ ）</h2><p>A. <strong>上写（Write Up）</strong>  B. 下写（Write Down）  C. 上读（Read Up）  D. 下读（Read Down）</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-59"><a href="#解析-59" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 上写（正确）</strong><br>低权限主体向高权限客体写数据。</p>
</li>
<li><p>B. 下写<br>高权限向低权限写。</p>
</li>
<li><p>C. 上读<br>低权限读取高权限对象。</p>
</li>
<li><p>D. 下读<br>高权限读取低权限对象。</p>
</li>
</ul>
<h2 id="61-脆弱性测试（Vulnerability-Test）的目的是？（-）"><a href="#61-脆弱性测试（Vulnerability-Test）的目的是？（-）" class="headerlink" title="61. 脆弱性测试（Vulnerability Test）的目的是？（ ）"></a>61. 脆弱性测试（Vulnerability Test）的目的是？（ ）</h2><p>A. <strong>发现漏洞</strong>  B. 攻击系统  C. 解决问题  D. 定位风险</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-60"><a href="#解析-60" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>A. 发现漏洞（正确）</strong><br>脆弱性测试以“发现”为目标，不进行利用。</p>
</li>
<li><p>B. 攻击系统<br>属于渗透测试范畴。</p>
</li>
<li><p>C. 解决问题<br>是测试后的整改阶段。</p>
</li>
<li><p>D. 定位风险<br>风险评估阶段的目标。</p>
</li>
</ul>
<h2 id="62-防火墙通常部署在（）与外网之间？（-）"><a href="#62-防火墙通常部署在（）与外网之间？（-）" class="headerlink" title="62. 防火墙通常部署在（）与外网之间？（ ）"></a>62. 防火墙通常部署在（）与外网之间？（ ）</h2><p>A. <strong>私有网络</strong>  B. 互联网  C. 虚拟网络  D. 公共网络</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-61"><a href="#解析-61" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>A. 私有网络（正确）</strong><br>防火墙用于保护内网（私有网络）免受外部网络攻击。</li>
</ul>
<h2 id="63-通过伪造信任关系获取信息的社会工程学手段是？（-）"><a href="#63-通过伪造信任关系获取信息的社会工程学手段是？（-）" class="headerlink" title="63. 通过伪造信任关系获取信息的社会工程学手段是？（ ）"></a>63. 通过伪造信任关系获取信息的社会工程学手段是？（ ）</h2><p>A. 网络钓鱼（Phishing）  B. 尾随（Tailgating）  C. <strong>假冒（Impersonation）</strong>  D. 垃圾搜寻（Dumpster Diving）</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-62"><a href="#解析-62" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. 假冒（正确）</strong><br>冒充他人或权威身份获取信任并套取信息。</p>
</li>
<li><p>A. 网络钓鱼<br>多通过邮件或网站诱导。</p>
</li>
<li><p>B. 尾随<br>借助他人进入物理区域。</p>
</li>
<li><p>D. 垃圾搜寻<br>翻找废弃资料获取信息。</p>
</li>
</ul>
<h2 id="64-Web-登录网站常用的认证协议是？（-）"><a href="#64-Web-登录网站常用的认证协议是？（-）" class="headerlink" title="64. Web 登录网站常用的认证协议是？（ ）"></a>64. Web 登录网站常用的认证协议是？（ ）</h2><p>A. BAA  B. Windows Live ID  C. <strong>OAuth</strong>  D. SAML</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-63"><a href="#解析-63" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>C. OAuth（正确）</strong><br>Web 与移动应用中最常用的授权&#x2F;认证框架，常结合 OIDC。</p>
</li>
<li><p>A. BAA<br>不属于 Web 认证协议。</p>
</li>
<li><p>B. Windows Live ID<br>已演进为 Microsoft Account，底层仍是 OAuth&#x2F;OIDC。</p>
</li>
<li><p>D. SAML<br>多用于企业级单点登录。</p>
</li>
</ul>
<h3 id="扩展-39"><a href="#扩展-39" class="headerlink" title="扩展"></a>扩展</h3><p>OAuth 2.0 + OpenID Connect（OIDC）</p>
<p>OAuth 2.0：授权框架（如允许用户用微信登录第三方 App），但本身不直接认证身份。</p>
<p>OpenID Connect：基于 OAuth 2.0 的身份认证层，通过 ID Token（JWT 格式）传递用户身份信息（如姓名、邮箱），实现标准化登录。</p>
<p>普及度：支持主流平台（微信&#x2F;支付宝&#x2F;Google&#x2F;Facebook 登录均基于 OIDC）。占现代 Web 认证方案的 80% 以上（Okta 报告）。</p>
<p>Windows Live ID 微软旧版身份系统（已升级为 Microsoft Account，底层用 OAuth&#x2F;OIDC）</p>
<p>SAML 企业级单点登录（SSO）协议（如用公司账号登录内部系统）</p>
<h2 id="65-SSH-审计中对管理员输入命令的审计属于？（-）"><a href="#65-SSH-审计中对管理员输入命令的审计属于？（-）" class="headerlink" title="65. SSH 审计中对管理员输入命令的审计属于？（ ）"></a>65. SSH 审计中对管理员输入命令的审计属于？（ ）</h2><p>A. 字符审计  B. 图形化审计  C. 会话审计  D. <strong>命令审计</strong></p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-64"><a href="#解析-64" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 命令审计（正确）</strong><br>记录并审计管理员在 SSH 中执行的具体命令，管理员输入的是命令，因此属于命令审计</p>
</li>
<li><p>A. 字符审计<br>字符串审计 原始输入流（如所有键盘输入，包括退格键、误操作等）不适用于 SSH 管理员操作</p>
</li>
<li><p>B. 图形化审计<br>GUI 操作（如远程桌面点击、窗口操作）SSH 是命令行协议，无图形界面</p>
</li>
<li><p>C. 会话审计<br>会话整体信息（登录时间、IP、会话时长）</p>
</li>
</ul>
<p>下面我<strong>严格按图一的格式</strong>，把<strong>图2～图5中的题目</strong>统一整理输出，便于你直接复制、学习或整理笔记（题号 + 题目 + 选项 + 正确答案 + 解析）。</p>
<hr>
<h2 id="66-采用顺序扫描传播的网络蠕虫是？（-）"><a href="#66-采用顺序扫描传播的网络蠕虫是？（-）" class="headerlink" title="66. 采用顺序扫描传播的网络蠕虫是？（ ）"></a>66. 采用顺序扫描传播的网络蠕虫是？（ ）</h2><p>A. 冲击波（Blaster）<br>B. 震荡波（Sasser）<br>C. 红色代码（Code Red）<br>D. SQL Slammer</p>
<p><strong>正确答案：C</strong></p>
<h3 id="解析-65"><a href="#解析-65" class="headerlink" title="解析"></a>解析</h3><ul>
<li>A. 冲击波（Blaster）：随机扫描，生成随机 IP，攻击 TCP 135 端口（RPC 漏洞）。</li>
<li>B. 震荡波（Sasser）：随机扫描，攻击 TCP 445 端口（LSASS 漏洞）。</li>
<li><strong>C. 红色代码（Code Red）：顺序扫描</strong>，从随机起点开始，按顺序扫描连续 IP（如扫描 &#x2F;16 子网），攻击 IIS 服务器的 80 端口。</li>
<li>D. SQL Slammer：完全随机扫描，通过 UDP 1434 端口高速发送探测包，无顺序逻辑。</li>
</ul>
<h2 id="67-利用-DCOM-RPC-漏洞传播的恶意软件是？（-）"><a href="#67-利用-DCOM-RPC-漏洞传播的恶意软件是？（-）" class="headerlink" title="67. 利用 DCOM RPC 漏洞传播的恶意软件是？（ ）"></a>67. 利用 DCOM RPC 漏洞传播的恶意软件是？（ ）</h2><p>A. 冲击波（Blaster）<br>B. 震网（Stuxnet）<br>C. 红色代码（Code Red）<br>D. Conficker</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-66"><a href="#解析-66" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>A. 冲击波（Blaster）</strong>：利用 Windows DCOM RPC 接口缓冲区溢出漏洞（MS03-026，CVE-2003-0352）。</li>
<li>B. 震网（Stuxnet）：通过 U 盘传播 + 攻击 Windows 打印服务漏洞（MS10-061）。</li>
<li>C. 红色代码（Code Red）：攻击 IIS 的 .ida 漏洞（CVE-2001-0500）。</li>
<li>D. Conficker：利用 SMBv1 协议漏洞（MS08-067，CVE-2008-4250）。</li>
</ul>
<h2 id="68-关于-W32-Blaster-Worm-说法正确的是？（-）"><a href="#68-关于-W32-Blaster-Worm-说法正确的是？（-）" class="headerlink" title="68. 关于 W32.Blaster.Worm 说法正确的是？（ ）"></a>68. 关于 W32.Blaster.Worm 说法正确的是？（ ）</h2><p>A. 攻击 Windows Update 阻止补丁下载<br>B. 感染 BIOS 固件<br>C. 通过邮件传播<br>D. 属于勒索软件</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-67"><a href="#解析-67" class="headerlink" title="解析"></a>解析</h3><p>W32.Blaster.Worm 是一种利用 DCOM RPC 漏洞传播的网络蠕虫，传播能力强，感染主机后会导致系统不稳定、频繁重启；同时对 <strong>windowsupdate.com</strong> 发起拒绝服务攻击，使用户无法获取系统补丁。</p>
<hr>
<h2 id="69-终端安全产品的功能指标包括？（-）"><a href="#69-终端安全产品的功能指标包括？（-）" class="headerlink" title="69. 终端安全产品的功能指标包括？（ ）"></a>69. 终端安全产品的功能指标包括？（ ）</h2><p>A. 访问控制<br>B. 不可旁路<br>C. 客体重用<br>D. 安全审计</p>
<p><strong>正确答案：D</strong></p>
<h3 id="解析-68"><a href="#解析-68" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>D. 安全审计（核心功能指标）</strong></p>
<ul>
<li>记录终端操作日志（进程创建、文件修改、网络连接）</li>
<li>提供行为追溯与威胁分析能力</li>
</ul>
</li>
<li><p>A. 访问控制：终端安全的基础防护能力，非专属功能指标，由白名单控制方式实现</p>
</li>
<li><p>B. 不可旁路：安全系统设计原则</p>
</li>
<li><p>C. 客体重用：操作系统存储安全要求</p>
</li>
</ul>
<hr>
<h2 id="70-防火墙弱性评定属于？（-）"><a href="#70-防火墙弱性评定属于？（-）" class="headerlink" title="70. 防火墙弱性评定属于？（ ）"></a>70. 防火墙弱性评定属于？（ ）</h2><p>A. 安全保障指标<br>B. 安全功能指标<br>C. 安全性能指标<br>D. 环境适应性指标</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-69"><a href="#解析-69" class="headerlink" title="解析"></a>解析</h3><p>安全保障指标主要关注产品的<strong>质量和服务保障能力</strong>，包括配置管理、交付与运行、开发与指导文档、测试、脆弱性评定等内容。</p>
<hr>
<h2 id="71-安全设备在网络安全管理体系中属于？（-）"><a href="#71-安全设备在网络安全管理体系中属于？（-）" class="headerlink" title="71. 安全设备在网络安全管理体系中属于？（ ）"></a>71. 安全设备在网络安全管理体系中属于？（ ）</h2><p>A. 管理资源<br>B. 管理主体<br>C. 管理手段<br>D. 管理依据</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-70"><a href="#解析-70" class="headerlink" title="解析"></a>解析</h3><p>网络安全管理体系包括：管理目标、管理手段、管理主体、管理依据、<strong>管理资源</strong>。</p>
<p>管理目标：大的方面包括政治、经济、文化、国防安全等，小的方面则是网络系统的保密、可用、可控等；</p>
<p>管理手段：包括安全评估、安全监管、应急响应、安全协调、安全标准和规范、保密检查、认证和访问控制等；</p>
<p>管理主体：大的方面包括国家网络安全职能部门，小的方面主要是网络管理员、单位负责人等；</p>
<p>管理依据：行政法规、法律、部门规章制度、技术规范等；</p>
<p>管理资源：包括安全设备、管理人员、安全经费、时间等。</p>
<hr>
<h2 id="72-生物识别要素的核心特点是？（-）"><a href="#72-生物识别要素的核心特点是？（-）" class="headerlink" title="72. 生物识别要素的核心特点是？（ ）"></a>72. 生物识别要素的核心特点是？（ ）</h2><p>A. 唯一性和可辨识性<br>B. 唯一性和可用性<br>C. 机密性和可辨识性<br>D. 不可否认性和可用性</p>
<p><strong>正确答案：A</strong></p>
<h3 id="解析-71"><a href="#解析-71" class="headerlink" title="解析"></a>解析</h3><p>生物识别指指纹、虹膜等特征，其核心特性是<strong>唯一性</strong>和<strong>可辨识性</strong>。</p>
<hr>
<h2 id="58-按客体预设权限访问的模型是？（-）"><a href="#58-按客体预设权限访问的模型是？（-）" class="headerlink" title="58. 按客体预设权限访问的模型是？（ ）"></a>58. 按客体预设权限访问的模型是？（ ）</h2><p>A. 自主访问控制（DAC）<br>B. 强制访问控制（MAC）<br>C. 基于角色的访问控制（RBAC）<br>D. 基于属性的访问控制（ABAC）</p>
<p><strong>正确答案：B</strong></p>
<h3 id="解析-72"><a href="#解析-72" class="headerlink" title="解析"></a>解析</h3><ul>
<li><p><strong>强制访问控制（MAC）</strong> 的核心机制是<strong>预设权限</strong>：</p>
<ul>
<li>系统管理员为所有客体（文件、资源）定义安全属性（如密级：公开、秘密、机密）</li>
<li>主体访问必须符合安全策略，用户不能自行修改权限</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>软考信息安全工程师考点概述</title>
    <url>/2026/01/03/%E8%BD%AF%E8%80%83%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%80%83%E7%82%B9%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>软考信息安全工程师涉及到的考试章节和具体考点如下，科目一考点：</p>
<table>
<thead>
<tr>
<th><strong>章节名称</strong></th>
<th><strong>章节内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1. 网络信息安全概述</td>
<td>网络发展现状、安全属性、安全管理、生命周期</td>
</tr>
<tr>
<td>2. 网络攻击原理与常用方法</td>
<td>攻击概述、常见攻击方法、黑客常用工具、攻击案例</td>
</tr>
<tr>
<td>3. 密码学基本理论</td>
<td>概况、密码学体制、常见密码算法、数字签名、安全协议</td>
</tr>
<tr>
<td>4. 网络安全体系与网络安全模型</td>
<td>概述、网络安全体系模型、建设原则、建设内容、参考案例</td>
</tr>
<tr>
<td>5. 物理与环境安全技术</td>
<td>物理安全、环境安全、机房安全、通信安全、设备安全、介质安全</td>
</tr>
<tr>
<td>6. 认证技术原理与应用</td>
<td>概述、认证类型与认证过程、认证技术、认证产品和技术指标</td>
</tr>
<tr>
<td>7. 访问控制技术原理与应用</td>
<td>访问控制原理、模型、类型、策略设计与实现、安全管理、产品</td>
</tr>
<tr>
<td>8. 防火墙技术原理与应用</td>
<td>防火墙原理、类型与实现技术、产品与技术指标、体系结构</td>
</tr>
<tr>
<td>9. VPN 技术原理与应用</td>
<td>概述、类型和实现技术、产品与技术指标、技术应用</td>
</tr>
<tr>
<td>10. 入侵检测技术原理与应用</td>
<td>概述、入侵检测技术、组成与分类、产品与技术指标、应用</td>
</tr>
<tr>
<td>11. 网络物理隔离技术原理与应用</td>
<td>网络物理隔离概述、系统与类型、机制与技术、产品与指标</td>
</tr>
<tr>
<td>12. 网络安全审计技术原理与应用</td>
<td>安全审计概述、组成与类型、机制与实现技术、产品与技术</td>
</tr>
<tr>
<td>13. 网络安全漏洞防护技术原理与应用</td>
<td>网络安全漏洞概述、分类与管理、漏洞扫描技术、处置技术、产品</td>
</tr>
<tr>
<td>14. 恶意代码防范技术原理</td>
<td>计算机病毒、特洛伊木马、网络蠕虫、僵尸网络等</td>
</tr>
<tr>
<td>15. 网络安全主动防御技术与应用</td>
<td>入侵阻断、软件白名单、网络流量清洗、可信计算、数字水印等</td>
</tr>
<tr>
<td>16. 网络安全风险评估技术原理与应用</td>
<td>风险评估概述、评估过程、评估技术、工作流程</td>
</tr>
<tr>
<td>17. 网络安全应急响应技术原理与应用</td>
<td>网络安全应急响应概述、工作机制、预案内容、应急处理</td>
</tr>
<tr>
<td>18. 网络安全测评技术与标准</td>
<td>网络安全测评概述、类型、流程与内容、技术工具、标准</td>
</tr>
<tr>
<td>19. 操作系统安全保护</td>
<td>概述、Windows &#x2F; Linux 操作系统安全、国产操作系统安全</td>
</tr>
<tr>
<td>20. 数据库系统安全</td>
<td>概述、安全机制和技术、Oracle、MS SQL、MySQL、国产数据库安全</td>
</tr>
<tr>
<td>21. 网络设备安全</td>
<td>网络设备安全概述、机制与技术、增强技术、漏洞和解决方法</td>
</tr>
<tr>
<td>22. 网站安全需求分析与安全保护</td>
<td>网络安全威胁、Apache Web 安全、IIS 安全、Web 漏洞、网站安全</td>
</tr>
<tr>
<td>23. 云计算安全需求分析与安全保护</td>
<td>云计算安全威胁、安全需求、安全保护机制与技术、案例</td>
</tr>
<tr>
<td>24. 工控安全需求分析与安全保护</td>
<td>工控系统安全威胁、安全需求、安全保护机制与技术、案例</td>
</tr>
<tr>
<td>25. 移动应用安全需求分析与安全保护</td>
<td>移动应用安全威胁、Android、iOS 安全、保护机制和技术、案例</td>
</tr>
<tr>
<td>26. 大数据安全需求分析与安全保护</td>
<td>大数据安全威胁、安全需求、安全保护机制与技术、案例</td>
</tr>
<tr>
<td>专业英语</td>
<td>专业英语</td>
</tr>
</tbody></table>
<p>科目二考点：</p>
<table>
<thead>
<tr>
<th><strong>考试专题</strong></th>
<th><strong>知识点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>密码学</td>
<td>1. 安全目标等基础概念。<br>2. RSA 加解密详细过程，其他加密算法概述。<br>3. 公钥私钥加解密、数字签名过程，文字表示及识图。<br>4. 密钥管理技术、安全认证协议等。</td>
</tr>
<tr>
<td>网络安全</td>
<td>1. 防火墙概念（iptables 过滤规则及配置命令）、体系结构、包过滤规则填表，Windows &#x2F; Linux 配置。<br>2. 各种网络攻击和威胁，数据敏感度、隐私分类、隐私保护等。<br>3. 网络协议数据包含义分析。<br>4. 重要网络协议如 TCP、DNS、DHCP 等。<br>5. 华为交换机、路由器等安全配置命令。</td>
</tr>
<tr>
<td>信息系统安全</td>
<td>1. 信息安全概述、目标、访问控制原理、BLP 等模型。<br>2. C 语言代码漏洞分析，变量内存图等。<br>3. Linux 重要配置文件名及内容含义、文件权限、配置命令等。<br>4. Windows 重要配置：日志、防火墙、安全策略等界面。</td>
</tr>
<tr>
<td>新技术</td>
<td>移动应用——安卓系统和 iOS 系统；<br>数据敏感度、隐私保护、隐私分类等；<br>其他可能会考察的有：云计算、工控系统、移动应用、大数据、应急响应等安全新技术内容。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>软考</category>
      </categories>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows结束进程</title>
    <url>/2025/12/09/Windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>今天在跑 Springboot 的 Java 项目时，遇到了端口占用问题，记一下 Windows 的根据相关端口杀进程命令。</p>
<p>首先查找占用 8080 的 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></table></figure>

<p>然后根据 PID 强制结束进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /PID 3836</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>实验</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;netstat -ano | findstr :8080</span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       3836</span><br><span class="line">  TCP    [::]:8080              [::]:0                 LISTENING       3836</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;taskkill /F /PID 3836</span><br><span class="line">成功: 已终止 PID 为 3836 的进程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>kali安装ssh</title>
    <url>/2025/12/10/kali%E5%AE%89%E8%A3%85ssh/</url>
    <content><![CDATA[<h1 id="kali-linux-安装ssh服务"><a href="#kali-linux-安装ssh服务" class="headerlink" title="kali linux 安装ssh服务"></a>kali linux 安装ssh服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl start ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh <span class="comment">#设置开机自启</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl status ssh <span class="comment">#查看运行状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Kali Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>uv使用</title>
    <url>/2025/12/10/uv%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>uv是一个用 Rust 编写的极快的 Python 包和项目管理工具。</p>
<p>官方文档参考：<a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a></p>
<h2 id="uv安装"><a href="#uv安装" class="headerlink" title="uv安装"></a>uv安装</h2><p>Linux &amp; MacOS 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Windows powershell 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell -ExecutionPolicy ByPass -c <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>以Windows为例，下载uv并配置环境变量，在powershell中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\<span class="number">77319</span>&gt; powershell <span class="literal">-ExecutionPolicy</span> ByPass <span class="literal">-c</span> <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br><span class="line">Downloading uv <span class="number">0.9</span>.<span class="number">17</span> (x86_64<span class="literal">-pc-windows-msvc</span>)</span><br><span class="line">Installing to C:\Users\<span class="number">77319</span>\.local\bin</span><br><span class="line">  uv.exe</span><br><span class="line">  uvx.exe</span><br><span class="line">  uvw.exe</span><br><span class="line">everything<span class="string">&#x27;s installed!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To add C:\Users\77319\.local\bin to your PATH, either restart your shell or run:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    set Path=C:\Users\77319\.local\bin;%Path%   (cmd)</span></span><br><span class="line"><span class="string">    $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;   (powershell)</span></span><br><span class="line"><span class="string">(base) PS C:\Users\77319&gt; $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入uv -h</p>
<p><img src="/../uploads/uv.png"></p>
<p>即表示安全成功。</p>
<h2 id="uv使用"><a href="#uv使用" class="headerlink" title="uv使用"></a>uv使用</h2><p>以官方实践为例，展示uv如何初始化一个 Python 项目、添加依赖、运行工具、生成锁文件并同步环境。  </p>
<p><code>uv init example</code> — 创建一个新的 Python 项目模板  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~$ uv init myproject_test</span><br><span class="line">Initialized project `myproject-test` at `/home/zyu/myproject_test`</span><br><span class="line">(base) zyu@zyu-virtual-machine:~$ <span class="built_in">cd</span> myproject_test/</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ tree .</span><br><span class="line">.</span><br><span class="line">├── main.py</span><br><span class="line">├── pyproject.toml</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv add ruff</code> — 安装依赖并更新 pyproject  </p>
<p>自动创建项目虚拟环境，安装依赖包ruff，把依赖写入pyproject.toml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv add ruff</span><br><span class="line">Using CPython 3.13.9 interpreter at: /home/zyu/miniconda3/bin/python3</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 864ms</span><br><span class="line">Prepared 1 package <span class="keyword">in</span> 1.30s</span><br><span class="line">Installed 1 package <span class="keyword">in</span> 1ms</span><br><span class="line"> + ruff==0.14.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv run ruff check</code> — 运行 ruff 检查代码  </p>
<p> 使用项目虚拟环境里的 ruff 执行代码风格检查 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv run ruff check</span><br><span class="line">All checks passed!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv lock</code> — 生成锁文件 : 解析所有依赖版本  , 生成 <code>uv.lock</code>（类似 Pipfile.lock &#x2F; poetry.lock），保证这个项目未来依赖安装一致、可复现。  </p>
<p><code>uv sync</code> — 按锁文件同步虚拟环境 ： 根据 <code>uv.lock</code> 安装或更新依赖  ， 确保 <code>.venv/</code> 完全匹配锁文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv lock</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.84ms</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv <span class="built_in">sync</span></span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.70ms</span><br><span class="line">Audited 1 package <span class="keyword">in</span> 0.09ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uvx pycowsay &#39;hello world!&#39; </code> uvx 等价于 <code>uv tool run</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uvx pycowsay <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line">Installed 1 package <span class="keyword">in</span> 5ms</span><br><span class="line">/home/zyu/.cache/uv/archive-v0/nYZiOnUm3DMddg7I9DLwr/lib/python3.13/site-packages/pycowsay/main.py:27: SyntaxWarning: invalid escape sequence <span class="string">&#x27;\ &#x27;</span></span><br><span class="line">  \   ^__^</span><br><span class="line"></span><br><span class="line">  ------------</span><br><span class="line">&lt; hello world! &gt;</span><br><span class="line">  ------------</span><br><span class="line">   \   ^__^</span><br><span class="line">    \  (oo)\_______</span><br><span class="line">       (__)\       )\/\</span><br><span class="line">           ||----w |</span><br><span class="line">           ||     ||</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是官方提供的示例Demo。</p>
<p>在实际项目中使用（以<a href="https://github.com/JordyZomer/codeql-mcp#">https://github.com/JordyZomer/codeql-mcp#</a>为例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">error: No virtual environment found; run `uv venv` to create an environment, or pass `--system` to install into a non-virtual environment</span><br></pre></td></tr></table></figure>

<p> 使用 <code>uv pip</code> 安装依赖，但当前目录没有虚拟环境，所以 uv 不知道该把包装到哪里。  uv 的原则是如果不指定装到哪里，它默认要找一个虚拟环境（.venv），如果找不到就报错。所以需要先创建虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv venv</span><br><span class="line">Using CPython 3.11.7 interpreter at: C:\Users\77319\anaconda3\python.exe</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Activate with: .venv\Scripts\activate</span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">Resolved 60 packages <span class="keyword">in</span> 1.61s</span><br><span class="line">Prepared 60 packages <span class="keyword">in</span> 3.56s</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/60] Installing wheels...                                                warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.                                                                                            </span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.                                                                                    </span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.                                                                             </span><br><span class="line">Installed 60 packages <span class="keyword">in</span> 4.17s</span><br><span class="line"> + annotated-types==0.7.0                                                                       </span><br><span class="line"> + anyio==4.12.0                                                                                </span><br><span class="line"> + attrs==25.4.0                                                                                </span><br><span class="line"> + authlib==1.6.5                                                                               </span><br><span class="line"> + beartype==0.22.8                                                                             </span><br><span class="line"> + cachetools==6.2.2</span><br><span class="line"> + certifi==2025.11.12</span><br><span class="line"> + cffi==2.0.0</span><br><span class="line"> + charset-normalizer==3.4.4</span><br><span class="line"> + click==8.3.1</span><br><span class="line"> + colorama==0.4.6</span><br><span class="line"> + cryptography==46.0.3</span><br><span class="line"> + cyclopts==4.3.0</span><br><span class="line"> + diskcache==5.6.3</span><br><span class="line"> + dnspython==2.8.0</span><br><span class="line"> + docstring-parser==0.17.0</span><br><span class="line"> + docutils==0.22.3</span><br><span class="line"> + email-validator==2.3.0</span><br><span class="line"> + exceptiongroup==1.3.1</span><br><span class="line"> + fastmcp==2.13.3</span><br><span class="line"> + h11==0.16.0</span><br><span class="line"> + httpcore==1.0.9</span><br><span class="line"> + httpx==0.28.1</span><br><span class="line"> + httpx-sse==0.4.3</span><br><span class="line"> + idna==3.11</span><br><span class="line"> + jsonschema==4.25.1</span><br><span class="line"> + jsonschema-path==0.3.4</span><br><span class="line"> + jsonschema-specifications==2025.9.1</span><br><span class="line"> + markdown-it-py==4.0.0</span><br><span class="line"> + mcp==1.22.0</span><br><span class="line"> + mdurl==0.1.2</span><br><span class="line"> + openapi-pydantic==0.5.1</span><br><span class="line"> + pathable==0.4.4</span><br><span class="line"> + pathvalidate==3.3.1</span><br><span class="line"> + platformdirs==4.5.1</span><br><span class="line"> + py-key-value-aio==0.3.0</span><br><span class="line"> + py-key-value-shared==0.3.0</span><br><span class="line"> + pycparser==2.23</span><br><span class="line"> + pydantic==2.12.5</span><br><span class="line"> + pydantic-core==2.41.5</span><br><span class="line"> + pydantic-settings==2.12.0</span><br><span class="line"> + pygments==2.19.2</span><br><span class="line"> + pyjwt==2.10.1</span><br><span class="line"> + pyperclip==1.11.0</span><br><span class="line"> + python-dotenv==1.2.1</span><br><span class="line"> + python-multipart==0.0.20</span><br><span class="line"> + pywin32==311</span><br><span class="line"> + pyyaml==6.0.3</span><br><span class="line"> + referencing==0.36.2</span><br><span class="line"> + requests==2.32.5</span><br><span class="line"> + rich==14.2.0</span><br><span class="line"> + rich-rst==1.3.2</span><br><span class="line"> + rpds-py==0.30.0</span><br><span class="line"> + sse-starlette==3.0.3</span><br><span class="line"> + starlette==0.50.0</span><br><span class="line"> + typing-extensions==4.15.0</span><br><span class="line"> + typing-inspection==0.4.2</span><br><span class="line"> + urllib3==2.6.1</span><br><span class="line"> + uvicorn==0.38.0</span><br><span class="line"> + websockets==15.0.1</span><br></pre></td></tr></table></figure>

<p>关于报错信息可以忽略，大致意思是： uv 想用硬链接（hardlink）加速依赖安装，但我们的缓存目录和安装目录不在同一个文件系统上 → 无法硬链接 → 只能退回到“完整复制”文件，性能稍慢一点。  应该缓存目录在C盘，但是安装目录在D盘。</p>
<p>运行mcp服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">Error: typer is required. Install with <span class="string">&#x27;pip install mcp[cli]&#x27;</span></span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install mcp[cli]</span><br><span class="line">Resolved 37 packages <span class="keyword">in</span> 710ms</span><br><span class="line">Prepared 2 packages <span class="keyword">in</span> 138ms</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/2] Installing wheels...                                                 warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.</span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.</span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.</span><br><span class="line">Installed 2 packages <span class="keyword">in</span> 56ms</span><br><span class="line"> + shellingham==1.5.4</span><br><span class="line"> + typer==0.20.0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>uv</tag>
      </tags>
  </entry>
</search>
