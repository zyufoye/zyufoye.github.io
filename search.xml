<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeQL-MCP架构解读</title>
    <url>/2025/12/15/CodeQL-MCP%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>本片内容以 <a href="https://github.com/JordyZomer/codeql-mcp">https://github.com/JordyZomer/codeql-mcp</a> 为基础，进行 CodeQL MCP 的开发学习。</p>
<h2 id="CodeQL-MCP-整体架构分析"><a href="#CodeQL-MCP-整体架构分析" class="headerlink" title="CodeQL-MCP 整体架构分析"></a>CodeQL-MCP 整体架构分析</h2><p>项目中包含了两个核心文件 <code>codeqlclient.py</code> 和  <code>server.py</code> ：</p>
<p><strong><code>codeqlclient.py</code></strong> 是一个底层通信客户端，负责与 CodeQL 查询服务器建立并管理 JSON-RPC 连接。它封装了进程启动、请求发送、响应解析、异步任务跟踪等复杂逻辑，提供了数据库注册、查询执行、结果解码等核心操作的原始接口。该文件不依赖任何高层框架，专注于可靠、高效地与 CodeQL 引擎交互，可作为独立库在不同上下文中复用。</p>
<p><strong><code>server.py</code></strong> 是一个基于 Model Context Protocol（MCP）的服务层实现，利用 FastMCP 框架将 <code>codeqlclient.py</code> 提供的底层能力包装为用户友好的异步 API 工具。它定义了清晰的 HTTP 可调用接口，处理参数验证、错误反馈和结果格式化，使外部系统能通过标准 MCP 协议便捷地使用 CodeQL 功能，而无需关心底层通信细节。</p>
<p>在 <code>codeqlclient.py</code> 中包含了一个核心类结构 CodeQLQueryServer 主要模块如下：</p>
<ol>
<li>服务器进程管理</li>
</ol>
<ul>
<li>启动&#x2F;停止 ：通过 start() 和 stop() 方法管理 CodeQL 子进程</li>
<li>进程通信 ：使用标准输入&#x2F;输出进行 JSON-RPC 通信</li>
<li>线程管理 ：<ul>
<li>_read_loop() ：主线程，读取服务器响应；_stderr_loop() ：处理标准错误输出；异步处理：支持并发请求</li>
</ul>
</li>
</ul>
<ol start="2">
<li>通信协议层</li>
</ol>
<ul>
<li>JSON-RPC 2.0：定义消息格式，请求&#x2F;响应结构，支持异步调用</li>
</ul>
<ol start="3">
<li>功能模块</li>
</ol>
<ul>
<li><p>数据库管理</p>
<ul>
<li>register_databases() ：注册数据库</li>
<li>deregister_databases() ：注销数据库</li>
</ul>
</li>
<li><p>查询执行</p>
<ul>
<li>evaluate_queries() ：执行完整查询</li>
<li>quick_evaluate() ：快速评估（针对特定代码位置）</li>
<li>evaluate_and_wait() ：同步执行查询</li>
<li>quick_evaluate_and_wait() ：同步快速评估</li>
</ul>
</li>
<li><p>结果处理</p>
<ul>
<li>decode_bqrs() ：解码 BQRS 结果文件</li>
</ul>
</li>
<li><p>代码分析辅助</p>
<ul>
<li>find_class_identifier_position() ：查找类标识符位置</li>
<li>find_predicate_identifier_position() ：查找谓词标识符位置</li>
</ul>
</li>
<li><p>进度回调机制（支持实时进度更新）</p>
<ul>
<li>wait_for_progress_done() ：等待进度完成</li>
<li>wait_for_completion_callback() ：等待异步操作完成</li>
<li>wait_for_progress_done() 创建进度跟踪器</li>
<li>wait_for_completion_callback() 创建完成处理器</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据流：用户请求 -&gt; send_request()-&gt;JSON-RPC 消息-&gt;CodeQL 服务器-&gt;CodeQL 引擎-&gt;服务器响应-&gt;_read_loop()-&gt;_handle_message()-&gt;回调函数</p>
</blockquote>
<span id="more"></span>

<h2 id="关键模块解读"><a href="#关键模块解读" class="headerlink" title="关键模块解读"></a>关键模块解读</h2><h3 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h3><p>启动 CodeQL 查询服务器进程，并建立通信通道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.proc = subprocess.Popen(</span><br><span class="line">    [</span><br><span class="line">        <span class="variable language_">self</span>.codeql_path,        <span class="comment"># CodeQL 可执行文件路径</span></span><br><span class="line">        <span class="string">&quot;execute&quot;</span>,               <span class="comment"># 执行命令</span></span><br><span class="line">        <span class="string">&quot;query-server2&quot;</span>,         <span class="comment"># 启动查询服务器版本2</span></span><br><span class="line">        <span class="string">&quot;--debug&quot;</span>,               <span class="comment"># 启用调试模式</span></span><br><span class="line">        <span class="string">&quot;--tuple-counting&quot;</span>,      <span class="comment"># 启用元组计数（性能监控）</span></span><br><span class="line">        <span class="string">&quot;--threads=0&quot;</span>,           <span class="comment"># 使用所有可用线程（0=自动）</span></span><br><span class="line">        <span class="string">&quot;--evaluator-log-level&quot;</span>, <span class="comment"># 设置评估器日志级别</span></span><br><span class="line">        <span class="string">&quot;5&quot;</span>,                     <span class="comment"># 日志级别5（详细）</span></span><br><span class="line">        <span class="string">&quot;-v&quot;</span>,                    <span class="comment"># 详细输出</span></span><br><span class="line">        <span class="string">&quot;--log-to-stderr&quot;</span>,       <span class="comment"># 日志输出到标准错误</span></span><br><span class="line">    ],</span><br><span class="line">    stdin=subprocess.PIPE,      <span class="comment"># 标准输入管道（用于发送请求）</span></span><br><span class="line">    stdout=subprocess.PIPE,     <span class="comment"># 标准输出管道（用于接收响应）</span></span><br><span class="line">    stderr=subprocess.PIPE,     <span class="comment"># 标准错误管道（用于日志/错误）</span></span><br><span class="line">    text=<span class="literal">True</span>,                  <span class="comment"># 以文本模式处理输入输出</span></span><br><span class="line">    bufsize=<span class="number">1</span>,                  <span class="comment"># 行缓冲模式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>启动读取线程：创建一个守护线程来持续读取服务器的标准输出，处理 JSON-RPC 响应。同时还有读取标准错误输出，防止缓冲区阻塞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.reader_thread = threading.Thread(</span><br><span class="line">    target=<span class="variable language_">self</span>._read_loop,  <span class="comment"># 目标函数：读取循环</span></span><br><span class="line">    daemon=<span class="literal">True</span>              <span class="comment"># 守护线程（主程序退出时自动结束）</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.reader_thread.start()   <span class="comment"># 启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">self</span>.stderr_thread = threading.Thread(</span><br><span class="line">    target=<span class="variable language_">self</span>._stderr_loop,  <span class="comment"># 目标函数：标准错误循环</span></span><br><span class="line">    daemon=<span class="literal">True</span>                <span class="comment"># 守护线程</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">self</span>.stderr_thread.start()     <span class="comment"># 启动线程</span></span><br></pre></td></tr></table></figure>

<h3 id="stderr-loop"><a href="#stderr-loop" class="headerlink" title="_stderr_loop()"></a>_stderr_loop()</h3><p>标准错误处理循环：持续读取 CodeQL服务器的标准错误输出，防止stderr管道堵塞，在 start() 中作为守护线程启动。</p>
<h3 id="read-loop"><a href="#read-loop" class="headerlink" title="_read_loop()"></a>_read_loop()</h3><p>主读取循环：读取并解析服务器响应，处理 JSON-RPC over HTTP 风格的消息格式。</p>
<h3 id="handle-message"><a href="#handle-message" class="headerlink" title="_handle_message()"></a>_handle_message()</h3><p>消息分发器：是核心的消息处理函数，处理三种类型的消息：</p>
<ul>
<li>进度更新消息 ( ql&#x2F;progressUpdated )：处理查询执行进度更新</li>
<li>评估进度消息 ( evaluation&#x2F;progress )：处理评估操作的进度信息</li>
<li>请求响应消息：处理异步请求的响应</li>
</ul>
<h3 id="send"><a href="#send" class="headerlink" title="_send()"></a>_send()</h3><p>发送请求：发送JSON-RPC 请求到服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, payload</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.proc <span class="keyword">or</span> <span class="keyword">not</span> <span class="variable language_">self</span>.proc.stdin:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] Tried to send but process not running.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        data = json.dumps(payload)</span><br><span class="line">        content = <span class="string">f&quot;Content-Length: <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span>\r\n\r\n<span class="subst">&#123;data&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n[→] Sending request:\n<span class="subst">&#123;json.dumps(payload, indent=<span class="number">2</span>)&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.proc.stdin.write(content)</span><br><span class="line">        <span class="variable language_">self</span>.proc.stdin.flush()</span><br></pre></td></tr></table></figure>

<h3 id="send-request"><a href="#send-request" class="headerlink" title="send_request()"></a>send_request()</h3><p>高级发送接口：发送异步请求并管理回调，为每个请求生成唯一ID，关联请求 ID 与回调函数，支持进度回调注册和状态跟踪。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h3><p>停止服务器</p>
<h3 id="find-class-identifier-position"><a href="#find-class-identifier-position" class="headerlink" title="find_class_identifier_position()"></a>find_class_identifier_position()</h3><p>在 QL 文件中查找类名标识符的位置，返回基于 1 的行列坐标。CodeQL 快速评估功能的关键组件，通过定位代码中的特定标识符，实现对部分代码的针对性分析。</p>
<h3 id="find-predicate-identifier-position"><a href="#find-predicate-identifier-position" class="headerlink" title="find_predicate_identifier_position()"></a>find_predicate_identifier_position()</h3><p>在 QL 文件中查找谓词（predicate）名称的位置，返回基于 1 的行列坐标。</p>
<p>类名查找和谓词查找可以用于支持CodeQL的快速评估功能，就是只执行查询的一部分，而不是执行全量查询，可以进行快速迭代和调试。</p>
<h3 id="register-databases-deregister-databases"><a href="#register-databases-deregister-databases" class="headerlink" title="register_databases() &amp;&amp; deregister_databases()"></a>register_databases() &amp;&amp; deregister_databases()</h3><p>注册注销数据库：向 CodeQL 查询服务器注册一个或多个数据库，使其可用于查询执行。</p>
<p>这是CodeQL客户端资源管理的核心，确保数据库在查询执行前正确注册，在执行后及时清理，是高效使用 CodeQL 服务器的关键组件。</p>
<h3 id="evaluate-queries"><a href="#evaluate-queries" class="headerlink" title="evaluate_queries()"></a>evaluate_queries()</h3><p>执行完整的 CodeQL 查询 ：在指定的数据库上运行一个 QL 查询文件，并将结果保存到输出文件。</p>
<ul>
<li>query_path ：QL 查询文件路径</li>
<li>db_path ：CodeQL 数据库路径</li>
<li>output_path ：结果输出文件路径（BQRS 格式）</li>
<li>callback ：异步完成回调（可选）</li>
<li>progress_callback ：进度回调（可选）</li>
</ul>
<p>默认完成处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">on_done</span>(<span class="params">result</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[evaluateQueries] done:&quot;</span>, result)</span><br><span class="line">    <span class="keyword">if</span> result.get(<span class="string">&quot;resultType&quot;</span>) != <span class="number">0</span>:  <span class="comment"># 0表示成功</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;result.get(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;Unknown error&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>发送异步请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.send_request(</span><br><span class="line">    <span class="string">&quot;evaluation/runQuery&quot;</span>,      <span class="comment"># JSON-RPC方法</span></span><br><span class="line">    params,                     <span class="comment"># 参数</span></span><br><span class="line">    callback <span class="keyword">or</span> on_done,        <span class="comment"># 使用用户回调或默认回调</span></span><br><span class="line">    progress_callback=progress_callback  <span class="comment"># 进度回调</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>函数会执行整个 QL 文件的所有查询，支持回调和进度跟踪。</p>
<h3 id="evaluate-and-wait"><a href="#evaluate-and-wait" class="headerlink" title="evaluate_and_wait()"></a>evaluate_and_wait()</h3><p>同步执行完整查询的便捷方法，其中包装了 evaluate_queries() 的异步功能，使用 wait_for_progress_done() 等待查询完成，简化了同步使用场景。</p>
<h3 id="quick-evaluate-and-wait"><a href="#quick-evaluate-and-wait" class="headerlink" title="quick_evaluate_and_wait()"></a>quick_evaluate_and_wait()</h3><p>同步执行快速评估，包装了quick_evaluate() 的异步功能，但是需要指定代码位置（行、列）。</p>
<h3 id="quick-evaluate"><a href="#quick-evaluate" class="headerlink" title="quick_evaluate()"></a>quick_evaluate()</h3><p>执行快速评估（Quick Evaluation） ：只执行 QL 查询文件中 特定代码片段 的查询，而不是整个文件。</p>
<ul>
<li>file_path ：QL 查询文件路径</li>
<li>db_path ：CodeQL 数据库路径</li>
<li>output_path ：结果输出文件路径</li>
<li>start_line , start_col ：起始位置（1-based）</li>
<li>end_line , end_col ：结束位置（1-based）</li>
<li>callback ：异步完成回调</li>
<li>progress_callback ：进度回调</li>
</ul>
<h3 id="wait-for-progress-done-wait-for-completion-callback"><a href="#wait-for-progress-done-wait-for-completion-callback" class="headerlink" title="wait_for_progress_done() &amp;&amp; wait_for_completion_callback()"></a>wait_for_progress_done() &amp;&amp; wait_for_completion_callback()</h3><p>功能 ：创建一个进度完成等待器 和 完成回调等待器。这两个函数都是 异步转同步 的工具：</p>
<ul>
<li>将异步回调模式转换为同步等待模式</li>
<li>简化了不需要复杂异步处理的场景</li>
<li>提供了更直观的API使用方式</li>
</ul>
<h2 id="MCP-Server-构建"><a href="#MCP-Server-构建" class="headerlink" title="MCP Server 构建"></a>MCP Server 构建</h2><p>基于 FastMCP 框架构建的 CodeQL 分析服务器，提供了 6 个工具来与 CodeQL 进行交互。</p>
<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>服务器初始化：使用 FastMCP 创建名为 “CodeQL” 的 MCP 服务器，实例化 CodeQLQueryServer 并启动，用于处理 CodeQL 查询操作。</p>
<h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><ol>
<li>register_database</li>
</ol>
<p>注册 CodeQL 数据库到查询服务器。验证数据库路径和必需的 src.zip 文件是否存在。</p>
<ol start="2">
<li>quick_evaluate</li>
</ol>
<p>快速评估 CodeQL 查询文件中的特定类或谓词，自动定位符号位置并执行评估。</p>
<ol start="3">
<li>decode_bqrs</li>
</ol>
<p>解码 CodeQL 结果文件（.bqrs 格式），支持 CSV（用于问题查询）或 JSON（用于路径问题）格式。</p>
<ol start="4">
<li>evaluate_query</li>
</ol>
<p>在指定数据库上运行完整的 CodeQL 查询文件。</p>
<ol start="5">
<li>find_class_position</li>
</ol>
<p>查找查询文件中类定义的准确位置（行号和列号）。</p>
<ol start="6">
<li>find_predicate_position</li>
</ol>
<p>查找查询文件中谓词定义的准确位置（行号和列号）。</p>
<h3 id="MCP-Server-代码"><a href="#MCP-Server-代码" class="headerlink" title="MCP Server 代码"></a>MCP Server 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mcp = FastMCP(<span class="string">&quot;CodeQL&quot;</span>)</span><br><span class="line">qs = CodeQLQueryServer()</span><br><span class="line">qs.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">register_database</span>(<span class="params">db_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This tool registers a CodeQL database given a path&quot;&quot;&quot;</span></span><br><span class="line">    db_path_resolved = Path(db_path).resolve()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> db_path_resolved.exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Database path does not exist: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    source_zip = db_path_resolved / <span class="string">&quot;src.zip&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> source_zip.exists():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Missing required src.zip in: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    db_entry = &#123;</span><br><span class="line">        <span class="string">&quot;uri&quot;</span>: Path(db_path).resolve().as_uri(),</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;sourceArchiveZip&quot;</span>: (Path(db_path) / <span class="string">&quot;src.zip&quot;</span>).resolve().as_uri(),</span><br><span class="line">            <span class="string">&quot;dbDir&quot;</span>: Path(db_path).resolve().as_uri(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    callback, done, result_holder = qs.wait_for_completion_callback()</span><br><span class="line">    qs.register_databases(</span><br><span class="line">        [db_path],</span><br><span class="line">        callback=callback,</span><br><span class="line">        progress_callback=<span class="keyword">lambda</span> msg: <span class="built_in">print</span>(<span class="string">&quot;[progress] register:&quot;</span>, msg),</span><br><span class="line">    )</span><br><span class="line">    done.wait()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Database registered: <span class="subst">&#123;db_path&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">quick_evaluate</span>(<span class="params"></span></span><br><span class="line"><span class="params">    file: <span class="built_in">str</span>, db: <span class="built_in">str</span>, symbol: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="string">&quot;/tmp/quickeval.bqrs&quot;</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This will allow you to quick_evaluate either a class or a predicate in a codeql query&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start, scol, end, ecol = qs.find_class_identifier_position(file, symbol)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        start, scol, end, ecol = qs.find_predicate_identifier_position(</span><br><span class="line">            file, symbol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qs.quick_evaluate_and_wait(</span><br><span class="line">            file, db, output_path, start, scol, end, ecol</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> re:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;re&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">decode_bqrs</span>(<span class="params">bqrs_path: <span class="built_in">str</span>, fmt: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This can be used to decode CodeQL results, format is either csv for problem queries or json for path-problems&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> qs.decode_bqrs(bqrs_path, fmt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">evaluate_query</span>(<span class="params"></span></span><br><span class="line"><span class="params">    query_path: <span class="built_in">str</span>, db_path: <span class="built_in">str</span>, output_path: <span class="built_in">str</span> = <span class="string">&quot;/tmp/eval.bqrs&quot;</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Runs a CodeQL query on a given database&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qs.evaluate_and_wait(query_path, db_path, output_path)</span><br><span class="line">    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> re:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;CodeQL evaluation failed: <span class="subst">&#123;re&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_class_position</span>(<span class="params">file: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds startline, startcol, endline endcol of a class for quickeval&quot;&quot;&quot;</span></span><br><span class="line">    start, scol, end, ecol = qs.find_class_identifier_position(file, name)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;start_line&quot;</span>: start,</span><br><span class="line">        <span class="string">&quot;start_col&quot;</span>: scol,</span><br><span class="line">        <span class="string">&quot;end_line&quot;</span>: end,</span><br><span class="line">        <span class="string">&quot;end_col&quot;</span>: ecol,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_predicate_position</span>(<span class="params">file: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds startline, startcol, endline endcol of a predicate for quickeval&quot;&quot;&quot;</span></span><br><span class="line">    start, scol, end, ecol = qs.find_predicate_identifier_position(file, name)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;start_line&quot;</span>: start,</span><br><span class="line">        <span class="string">&quot;start_col&quot;</span>: scol,</span><br><span class="line">        <span class="string">&quot;end_line&quot;</span>: end,</span><br><span class="line">        <span class="string">&quot;end_col&quot;</span>: ecol,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting CodeQL MCP server...&quot;</span>)</span><br><span class="line">    mcp.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="MCP-Server-测试"><a href="#MCP-Server-测试" class="headerlink" title="MCP Server 测试"></a>MCP Server 测试</h2><p>以注册数据库为例，进行MCP Server功能测试：</p>
<p>首先启动 MCP Server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(really_mcp) PS D:\Projects\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">[*] Read loop started</span><br><span class="line">INFO:     Started server process [23464]</span><br><span class="line">INFO:     Waiting <span class="keyword">for</span> application startup.</span><br><span class="line">INFO:     Application startup complete.</span><br><span class="line">INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 cursor 的 MCP tools 页面加载对应工具，选择启用状态：</p>
<p><img src="/../uploads/CodeQL_MCP_1.png"></p>
<p>对应配置文件如下：</p>
<p><img src="/../uploads/CodeQL_MCP_2.png"></p>
<p>MCP Server状态与 Tools 调用情况：</p>
<p><img src="/../uploads/CodeQL_MCP_3.png"></p>
<p>以上验证 CodeQL MCP 可成功调用并执行。</p>
<p>与服务器通信的数据包数据：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Accepted</span><br><span class="line">[12/15/25 20:26:54] INFO     Processing request of type CallToolRequest                   server.py:674</span><br><span class="line">[DEBUG] Sending evaluation/registerDatabases with progressId=0</span><br><span class="line"></span><br><span class="line">[→] Sending request:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;method&quot;: &quot;evaluation/registerDatabases&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;body&quot;: &#123;</span><br><span class="line">      &quot;databases&quot;: [</span><br><span class="line">        &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;progressId&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[stdout] Content-Length: 102</span><br><span class="line">[raw response body] &#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:1,&quot;result&quot;:&#123;&quot;registeredDatabases&quot;:[&quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">[←] Received response:</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">    &quot;registeredDatabases&quot;: [</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">      &quot;D:\\Code\\codeql-mcp\\Test_demo\\test_db&quot;</span><br><span class="line">    ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INFO:     127.0.0.1:56577 - &quot;POST /messages/?session_id=d8bc9c141a864777b7a094f0a6abc6ad HTTP/1.1&quot; 202 Accepted</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL入门</title>
    <url>/2025/12/07/CodeQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="CodeQL-入门"><a href="#CodeQL-入门" class="headerlink" title="CodeQL 入门"></a>CodeQL 入门</h1><p>在网络安全和代码审计的领域，静态应用程序安全测试（Static application security testing，SAST）工具层出不穷。但在 2019 年 GitHub 收购 Semmle 之后，CodeQL 迅速成为了业界顶流。</p>
<p>传统的扫描工具往往像是一个黑盒，你输入代码，它吐出报告。但 CodeQL 不同，它的核心理念非常有意思： <code>Code as Data</code> 代码即数据，CodeQL 把源代码转化成一个关系型数据库，而漏洞挖掘的过程，就变成了一次次编写 SQL（其实是 QL）查询语句的过程。</p>
<p>CodeQL 工具包含两大部分组成：</p>
<ul>
<li>核心引擎(闭源)：用于解析源代码并存储于数据库，以及执行 QL 语句从数据库中进行查询；</li>
<li>SDK代码库(开源)：包含各编程语言对应的 QL 代码库(属性&#x2F;谓词&#x2F;等)，以便快速编写查询语句。</li>
</ul>
<p>这给了安全研究员和开发者极大的自由度——不再受限于工具内置的规则，可以自己定义“什么样的代码长相存在漏洞”。这篇 Blog 记录了我第一次使用 CodeQL 进行静态代码分析的过程。</p>
<span id="more"></span>

<h2 id="一、CodeQL-核心工作流"><a href="#一、CodeQL-核心工作流" class="headerlink" title="一、CodeQL 核心工作流"></a>一、CodeQL 核心工作流</h2><p>使用 CodeQL 主要分为三个步骤：</p>
<ol>
<li><p><strong>创建数据库（Create Database）</strong>： 在编译&#x2F;构建代码的过程中，CodeQL 会“旁路监听”，捕捉所有的编译命令、文件结构、函数调用关系，生成一个快照数据库；</p>
</li>
<li><p><strong>编写&#x2F;运行查询（Analyze）</strong>： 使用一种类似 SQL 的面向对象查询语言（QL），在数据库中查找符合特征的代码片段；</p>
</li>
<li><p><strong>生成结果（Results）</strong>： 输出分析报告（通常是 SARIF 格式），定位到具体的代码行号。</p>
</li>
</ol>
<h2 id="二、CodeQL-安装"><a href="#二、CodeQL-安装" class="headerlink" title="二、CodeQL 安装"></a>二、CodeQL 安装</h2><p>运行 CodeQL 需要安装 CodeQL CLI 工具，分开下载的话需要分别下载 CodeQL binary 和 SDK，需要放在相同目录下且版本保持一致，也可以直接下载捆绑包，以 Ubuntu 环境为例，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.16.1/codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvzf codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/aono/codeqlsrc/codeql</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>检测是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql --version</span><br></pre></td></tr></table></figure>

<p>可以使用  <code>codeQL resolve languages</code> 可以查看支持的编程语言。</p>
<h2 id="三、CodeQL-简单使用"><a href="#三、CodeQL-简单使用" class="headerlink" title="三、CodeQL 简单使用"></a>三、CodeQL 简单使用</h2><p>指定项目创建数据库，以 Java 目标（<a href="https://github.com/l4yn3/micro_service_seclab%EF%BC%89%E4%B8%BA%E4%BE%8B%EF%BC%8C%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87">https://github.com/l4yn3/micro_service_seclab）为例，项目通过</a> mvn 构建，首先安装 mvn：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install maven -y</span><br></pre></td></tr></table></figure>

<p>创建数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database create java_db --language=java --source-root=./test/micro_service_seclab/</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_1.png"></p>
<p>使用默认规则进行查询，生成 SARIF 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database analyze java_db/ --format=sarif-latest --output=java_result.sarif</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_2.png"></p>
]]></content>
      <categories>
        <category>SAST</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>SAST</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL入门（二）</title>
    <url>/2025/12/17/CodeQL%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="CodeQL-查询语句编写"><a href="#CodeQL-查询语句编写" class="headerlink" title="CodeQL 查询语句编写"></a>CodeQL 查询语句编写</h2><p>以python为例，编写一个简单的hello world codeql查询。首先需要使用 codeql 创建一个数据库，这样才能为其编写查询语句，使用如下命令创建数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql database create test_db --language=python</span><br></pre></td></tr></table></figure>

<p>此时文件中会多出一个文件夹 test_db 即为当前项目的 codeql 数据库。接下来需要编写查询语句，一个标准的 codeql 查询语句格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Query metadata</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import <span class="comment">/* ... CodeQL libraries or modules ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... Optional, define CodeQL classes and predicates ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="comment">/* ... variable declarations ... */</span></span><br><span class="line"><span class="keyword">where</span> <span class="comment">/* ... logical formula ... */</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/* ... expressions ... */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>语句可以简单理解为：<strong>通过 <code>import</code> 导入哪些库，然后<code>from</code>从哪些数据中，查找 <code>select</code>满足哪些条件<code>where</code>的结果。</strong></p>
</blockquote>
<p>为hello world简单编写一个查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;hello,world&quot;</span><br></pre></td></tr></table></figure>

<p>使用 query run 子命令指定 test_db 数据库执行 helloworld.ql 查询语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db/ helloworld.ql</span><br></pre></td></tr></table></figure>

<p>执行成功，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db/ helloworld.ql</span><br><span class="line"></span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/helloworld.ql.</span><br><span class="line">[1/1 comp 745ms] Compiled /home/zyu/projects/python_codeql_demo/helloworld.ql.</span><br><span class="line">helloworld.ql: Evaluation completed (45ms).</span><br><span class="line">|    col0     |</span><br><span class="line">+-------------+</span><br><span class="line">| hello,world |</span><br><span class="line">Shutting down query evaluator.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了这种 cli 的运行方式，codeql 还提供了另外两种运行方式，分别是 VScode插件和 CI&#x2F;CD 方式：</p>
<ul>
<li><p>CodeQL_cli：适合对项目源码进行批量的规则扫描和检测，使用命令行进行操作；</p>
</li>
<li><p>VSCode插件：适合使用 CodeQL 辅助进行代码审计，使用 VSCode 进行操作；</p>
</li>
<li><p>CI&#x2F;CD：结合规则库将 CodeQL 添加进 CI&#x2F;CD 流程进行持续化的项目安全管理，在 CI&#x2F;CD 流程中自动执行；</p>
</li>
</ul>
<span id="more"></span>

<h2 id="官方-CodeQL-tutorials"><a href="#官方-CodeQL-tutorials" class="headerlink" title="官方 CodeQL tutorials"></a>官方 CodeQL tutorials</h2><p>CodeQL 官方提供了 QL 教程(<a href="https://codeql.github.com/docs/writing-codeql-queries/ql-tutorials/)%E4%BB%A5%E6%B8%B8%E6%88%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B8%AE%E5%8A%A9%E7%94%A8%E6%88%B7%E5%85%A5%E9%97%A8">https://codeql.github.com/docs/writing-codeql-queries/ql-tutorials/)以游戏的方式帮助用户入门</a> QL 并理解基础的语法规则。</p>
<h3 id="CodeQL-baseline"><a href="#CodeQL-baseline" class="headerlink" title="CodeQL baseline"></a>CodeQL baseline</h3><p>官方文档中介绍，更加复杂的通用查询看起来像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="comment">/* ... variable declarations ... */</span></span><br><span class="line"><span class="keyword">where</span> <span class="comment">/* ... logical formulas ... */</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/* ... expressions ... */</span></span><br></pre></td></tr></table></figure>

<p>示例1-以下面的这个为例，查询结果是数字 42：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="type">int</span> x, <span class="type">int</span> y</span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">6</span> <span class="keyword">and</span> y <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">select</span> x <span class="operator">*</span> y</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db demo1.ql</span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo1.ql.</span><br><span class="line">[1/1 comp 805ms] Compiled /home/zyu/projects/python_codeql_demo/demo1.ql.</span><br><span class="line">demo1.ql: Evaluation completed (48ms).</span><br><span class="line">| col0 |</span><br><span class="line">+------+</span><br><span class="line">|   42 |</span><br><span class="line">Shutting down query evaluator.</span><br></pre></td></tr></table></figure>

<p>示例2-多结果查询示例：查询计算 1 到 10 之间的所有勾股数，通过编写类的方式简化ql代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class <span class="type">SmallInt</span> extends <span class="type">int</span> &#123;</span><br><span class="line">  <span class="type">SmallInt</span>() &#123; this <span class="keyword">in</span> [<span class="number">1.</span><span class="number">.10</span>] &#125;</span><br><span class="line">  <span class="type">int</span> square() &#123; <span class="keyword">result</span> <span class="operator">=</span> this<span class="operator">*</span>this &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="type">SmallInt</span> x, <span class="type">SmallInt</span> y, <span class="type">SmallInt</span> z</span><br><span class="line"><span class="keyword">where</span> x.square() <span class="operator">+</span> y.square() <span class="operator">=</span> z.square()</span><br><span class="line"><span class="keyword">select</span> x, y, z</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d test_db demo2.ql</span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo2.ql.</span><br><span class="line">[1/1 comp 900ms] Compiled /home/zyu/projects/python_codeql_demo/demo2.ql.</span><br><span class="line">demo2.ql: Evaluation completed (55ms).</span><br><span class="line">| x | y | z  |</span><br><span class="line">+---+---+----+</span><br><span class="line">| 3 | 4 | 5  |</span><br><span class="line">| 4 | 3 | 5  |</span><br><span class="line">| 6 | 8 | 10 |</span><br><span class="line">| 8 | 6 | 10 |</span><br><span class="line">Shutting down query evaluator.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例3-查询python中超过 7 个参数的函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import python</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Function</span> f</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">count</span>(f.getAnArg()) <span class="operator">&gt;</span> <span class="number">7</span></span><br><span class="line"><span class="keyword">select</span> f</span><br></pre></td></tr></table></figure>

<p>要导入特定编程语言的 CodeQL 库，在查询开始处输入 <code>import language</code> 。from 子句定义了一个变量 f ，代表一个 Python 函数。 where 部分将函数 f 限制为那些具有超过 7 个参数的函数。最后， select 子句列出了这些函数。</p>
<p>在运行这个查询时遇到了一些错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d argdb demo3.ql</span><br><span class="line"></span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo3.ql.</span><br><span class="line">ERROR: could not resolve module python (/home/zyu/projects/python_codeql_demo/demo3.ql:1,8-14)</span><br><span class="line">ERROR: could not resolve <span class="built_in">type</span> Function (/home/zyu/projects/python_codeql_demo/demo3.ql:3,6-14)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析原因，错误信息 <code>could not resolve module python</code> 和 <code>could not resolve type Function</code> 表明 CodeQL 编译器无法找到 Python 标准查询库（Standard QL Libraries）。</p>
<p>缺少 qlpack.yml 文件：CodeQL 现在强烈依赖 “CodeQL Packs” 系统。如果你直接运行一个裸露的 .ql 文件，而该文件所在目录没有声明它依赖 codeql&#x2F;python-all，编译器就不知道 import python 到底是指向哪里的库。</p>
<p>创建 qlpack.yml 文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">my-custom-queries</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">codeql/python-all:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后执行 codeql pack install 出现如下提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARNING: Pack <span class="string">&#x27;codeql/xml&#x27;</span> was found via <span class="string">&#x27;--additional-packs&#x27;</span>. If the generated <span class="string">&#x27;codeql-pack.lock.yml&#x27;</span> file is committed to <span class="built_in">source</span> control, other <span class="built_in">users</span> will also have to use <span class="string">&#x27;--additional-packs&#x27;</span> when compiling or running queries.  (/home/zyu/codeql/qlpacks/codeql/xml/1.0.38/qlpack.yml:1,1-1)</span><br><span class="line">......</span><br><span class="line">WARNING: Pack <span class="string">&#x27;codeql/yaml&#x27;</span> was found via <span class="string">&#x27;--additional-packs&#x27;</span>. If the generated <span class="string">&#x27;codeql-pack.lock.yml&#x27;</span> file is committed to <span class="built_in">source</span> control, other <span class="built_in">users</span> will also have to use <span class="string">&#x27;--additional-packs&#x27;</span> when compiling or running queries.  (/home/zyu/codeql/qlpacks/codeql/yaml/1.0.38/qlpack.yml:1,1-1)</span><br><span class="line">WARNING: To avoid these warnings <span class="keyword">in</span> the future, use the <span class="string">&#x27;--no-strict-mode&#x27;</span> option. (/home/zyu/projects/python_codeql_demo/qlpack.yml:1,1-1)</span><br><span class="line"></span><br><span class="line">Dependencies resolved. Installing packages...</span><br><span class="line">Install location: /home/zyu/.codeql/packages</span><br><span class="line">Nothing to install.</span><br><span class="line">Package install location: /home/zyu/.codeql/packages</span><br><span class="line">Nothing downloaded.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>警告部分大致的意思是：我知道你需要 python-all，我也找到了它。但是 python-all 内部还依赖 dataflow。虽然我现在能找到它们，但因为你没有一个全局的 codeql-workspace.yml 文件来统一管理这些路径，我担心等到你真正运行查询的时候，我可能会找不到这些底层依赖。</p>
<p><strong>但在使用 CodeQL Bundle（下载的那个大压缩包）时，通常 CLI 会自动处理这些路径，所以这些警告往往可以忽略。</strong></p>
<p>返回结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql query run -d argdb demo3.ql</span><br><span class="line"></span><br><span class="line">Compiling query plan <span class="keyword">for</span> /home/zyu/projects/python_codeql_demo/demo3.ql.</span><br><span class="line">[1/1 comp 12s] Compiled /home/zyu/projects/python_codeql_demo/demo3.ql.</span><br><span class="line">demo3.ql: Evaluation completed (113ms).</span><br><span class="line">|           f            |</span><br><span class="line">+------------------------+</span><br><span class="line">| Function test_function |</span><br><span class="line">Shutting down query evaluator.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="官方示例-Find-the-thief"><a href="#官方示例-Find-the-thief" class="headerlink" title="官方示例 Find the thief"></a>官方示例 Find the thief</h3><p>把以下内容转换为 ql 查询：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>小偷身高超过 150 厘米吗？</td>
<td>是</td>
</tr>
<tr>
<td>2</td>
<td>小偷有金发吗？</td>
<td>不</td>
</tr>
<tr>
<td>3</td>
<td>小偷秃头吗？</td>
<td>不</td>
</tr>
<tr>
<td>4</td>
<td>小偷是否小于 30 岁？</td>
<td>不</td>
</tr>
<tr>
<td>5</td>
<td>小偷是否住在城堡的东边？</td>
<td>是</td>
</tr>
<tr>
<td>6</td>
<td>小偷有黑色或棕色头发吗？</td>
<td>是</td>
</tr>
<tr>
<td>7</td>
<td>小偷身高是否超过 180 厘米且低于 190 厘米？</td>
<td>不</td>
</tr>
<tr>
<td>8</td>
<td>小偷是村里年纪最大的人吗？</td>
<td>不</td>
</tr>
<tr>
<td>9</td>
<td>小偷是村里最高的人吗？</td>
<td>不</td>
</tr>
<tr>
<td>10</td>
<td>小偷比村民的平均身高矮吗？</td>
<td>是</td>
</tr>
<tr>
<td>11</td>
<td>小偷是村东部最年长的人吗？</td>
<td>是</td>
</tr>
</tbody></table>
<p>查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import tutorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Person t</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  <span class="comment">/* 1 */</span> t.getHeight() <span class="operator">&gt;</span> <span class="number">150</span> <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 2 */</span> <span class="keyword">not</span> t.getHairColor() <span class="operator">=</span> &quot;blond&quot; <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 3 */</span> <span class="keyword">exists</span> (string c <span class="operator">|</span> t.getHairColor() <span class="operator">=</span> c) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 4 */</span> <span class="keyword">not</span> t.getAge() <span class="operator">&lt;</span> <span class="number">30</span> <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 5 */</span> t.getLocation() <span class="operator">=</span> &quot;east&quot; <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 6 */</span> (t.getHairColor() <span class="operator">=</span> &quot;black&quot; <span class="keyword">or</span> t.getHairColor() <span class="operator">=</span> &quot;brown&quot;) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 7 */</span> <span class="keyword">not</span> (t.getHeight() <span class="operator">&gt;</span> <span class="number">180</span> <span class="keyword">and</span> t.getHeight() <span class="operator">&lt;</span> <span class="number">190</span>) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 8 */</span> <span class="keyword">exists</span>(Person p <span class="operator">|</span> p.getAge() <span class="operator">&gt;</span> t.getAge()) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 9 */</span> <span class="keyword">not</span> t <span class="operator">=</span> <span class="built_in">max</span>(Person p <span class="operator">|</span> <span class="operator">|</span> p <span class="keyword">order</span> <span class="keyword">by</span> p.getHeight()) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 10 */</span> t.getHeight() <span class="operator">&lt;</span> <span class="built_in">avg</span>(<span class="type">float</span> i <span class="operator">|</span> <span class="keyword">exists</span>(Person p <span class="operator">|</span> p.getHeight() <span class="operator">=</span> i) <span class="operator">|</span> i) <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 11 */</span> t <span class="operator">=</span> <span class="built_in">max</span>(Person p <span class="operator">|</span> p.getLocation() <span class="operator">=</span> &quot;east&quot; <span class="operator">|</span> p <span class="keyword">order</span> <span class="keyword">by</span> p.getAge())</span><br><span class="line"><span class="keyword">select</span> &quot;The thief is &quot; <span class="operator">+</span> t <span class="operator">+</span> &quot;!&quot;</span><br></pre></td></tr></table></figure>

<h3 id="官方示例-Catch-the-fire-starter"><a href="#官方示例-Catch-the-fire-starter" class="headerlink" title="官方示例 Catch the fire starter"></a>官方示例 Catch the fire starter</h3><p>本节主要介绍了 codeql 的谓词和类。因为对<strong>谓词</strong>的理解不是很明白，所以这里多一点背景介绍。</p>
<p>学习 QL 谓词和类，作为 QL 侦探解决你的第二个谜团。就像你成功找到小偷并将金冠归还城堡一样，另一场可怕的犯罪发生了。清晨，几个人在村庄北面的田野里纵火，烧毁了所有的庄稼！你现在以 QL 侦探专家的声誉而闻名，因此再次被要求找出罪魁祸首。这次，你有一些额外信息。村庄的南北两侧存在激烈竞争，而且你知道罪犯住在南边。通过以下示例学习如何在 QL 中定义谓词和类。这将使你的查询逻辑更易于理解，并有助于简化你的侦探工作。</p>
<p>这次你只需要考虑一个特定的村民群体，即住在村庄南边的人。你不必在所有查询中都写 <code>getLocation() = &quot;south&quot; </code>，可以定义一个新的谓词 <code>isSouthern </code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">predicate isSouthern(Person p) &#123;</span><br><span class="line">  p.getLocation() <span class="operator">=</span> &quot;south&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谓词 <code>isSouthern(p)</code> 接受一个参数 <code>p</code> 并检查 <code>p</code> 是否满足属性 <code>p.getLocation() = &quot;south&quot;</code> 。</p>
<p>谓词的名称总是以小写字母开头。</p>
<p>王冠被盗后开始实施旅行限制。最初，村民们可以在村庄内自由旅行，没有限制。因此，谓词 isAllowedIn(string region) 对任何人和任何地区都成立。以下查询列出了所有村民，因为他们都可以去北方：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Person p</span><br><span class="line"><span class="keyword">where</span> p.isAllowedIn(&quot;north&quot;)</span><br><span class="line"><span class="keyword">select</span> p</span><br></pre></td></tr></table></figure>

<p>然而，在最近的盗窃事件后，村民们对村周围潜伏的罪犯变得更加担忧，他们不再允许 10 岁以下的儿童离开他们的居住区域。这意味着 <code>isAllowedIn(string region)</code> 不再对所有人和所有地区成立，因此如果 p 是一个孩子，应该暂时覆盖原始谓词。</p>
<p>首先定义一个包含所有 10 岁以下村民的类 <code>Child</code> 。然后你可以将 <code>isAllowedIn(string region)</code> 重新定义为 <code>Child</code> 的成员谓词，以允许儿童只在自己的区域内移动。这由 <code>region = this.getLocation()</code> 表示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Child extends Person &#123;</span><br><span class="line">  <span class="comment">/* the characteristic predicate */</span></span><br><span class="line">  Child() &#123; this.getAge() <span class="operator">&lt;</span> <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a member predicate */</span></span><br><span class="line">  override predicate isAllowedIn(string region) &#123;</span><br><span class="line">    region <span class="operator">=</span> this.getLocation()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在尝试将 <code>isAllowedIn(string region)</code> 应用于一个人 <code>p</code> 。如果 <code>p</code> 不是孩子，则使用原始定义，但如果 <code>p</code> 是孩子，则新的谓词定义会覆盖原始定义。</p>
<p>知道火种者住在南方，而且他们必须能够前往北方。写一个查询来找出可能的嫌疑人。也可以扩展 select 子句来列出嫌疑人的年龄。这样就能清楚地看到所有孩子都被排除在名单之外。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import tutorial</span><br><span class="line"></span><br><span class="line">predicate isSouthern(Person p) &#123; p.getLocation() <span class="operator">=</span> &quot;south&quot; &#125;</span><br><span class="line"></span><br><span class="line">class Southerner extends Person &#123;</span><br><span class="line">  <span class="comment">/* the characteristic predicate */</span></span><br><span class="line">  Southerner() &#123; isSouthern(this) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Person &#123;</span><br><span class="line">  <span class="comment">/* the characteristic predicate */</span></span><br><span class="line">  Child() &#123; this.getAge() <span class="operator">&lt;</span> <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* a member predicate */</span></span><br><span class="line">  override predicate isAllowedIn(string region) &#123; region <span class="operator">=</span> this.getLocation() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Southerner s</span><br><span class="line"><span class="keyword">where</span> s.isAllowedIn(&quot;north&quot;)</span><br><span class="line"><span class="keyword">select</span> s, s.getAge()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SAST</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>SAST</tag>
      </tags>
  </entry>
  <entry>
    <title>Function Call和MCP的区别</title>
    <url>/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）"><a href="#Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）" class="headerlink" title="Function Call和MCP的核心区别梳理（由GPT 5.1 生成）"></a>Function Call和MCP的核心区别梳理（由GPT 5.1 生成）</h2><h2 id="🧩核心区别总结"><a href="#🧩核心区别总结" class="headerlink" title="🧩核心区别总结"></a>🧩核心区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Function Call</th>
<th>MCP（Model Context Protocol）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>让模型按照开发者定义的结构化方式返回“调用某函数所需的参数”。</td>
<td>让模型与外部工具、服务、数据源通过统一协议进行双向通信。</td>
</tr>
<tr>
<td><strong>角色</strong></td>
<td>模型只“产生命令”（函数+参数），不执行。执行由外部应用完成。</td>
<td>除生成调用外，还可以<strong>发现、注册、调度、执行</strong>外部资源。</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单、轻量级、多数场景够用。</td>
<td>更底层、更通用，可连接复杂系统。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>调用某个特定函数、处理结构化任务。</td>
<td>接入多个工具、多数据源、插件系统、企业级工作流。</td>
</tr>
</tbody></table>
<hr>
<span id="more"></span>

<h2 id="🧠Function-Call-是什么？"><a href="#🧠Function-Call-是什么？" class="headerlink" title="🧠Function Call 是什么？"></a>🧠Function Call 是什么？</h2><p><strong>Function Call</strong> 是模型输出的一种结构化格式，模型输出它想调用什么函数并且要传什么参数。模型只负责<strong>输出结构化 JSON</strong>，实际执行由相关程序完成。</p>
<p><strong>Function Call</strong>提供的是 API 层的能力，由开发者定义可调用函数列表，模型产出：函数名 + 参数，适用于简单逻辑。</p>
<h3 id="✔-Function-Call-示例"><a href="#✔-Function-Call-示例" class="headerlink" title="✔ Function Call 示例"></a>✔ Function Call 示例</h3><p>假设开发者定义了一个函数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取城市天气&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;city&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用户问：</p>
<blockquote>
<p>“明天北京天气如何？”</p>
</blockquote>
<p>模型可能返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后 <strong>相关程序</strong> 执行 get_weather(“北京”) 并把结果再返回给模型或用户。</p>
<p>📌 <strong>关键点：模型不会执行，只会返回结构体。</strong></p>
<h2 id="🧠MCP（Model-Context-Protocol）是什么？"><a href="#🧠MCP（Model-Context-Protocol）是什么？" class="headerlink" title="🧠MCP（Model Context Protocol）是什么？"></a>🧠MCP（Model Context Protocol）是什么？</h2><p>MCP 是一个<strong>通用协议</strong>，用于管理工具（tools），连接外部数据源（database、文件系统等），让模型能够发现并调用这些资源，同时统一不同工具的接口格式。</p>
<p>可以把 MCP 理解为：</p>
<blockquote>
<p><strong>模型与外部世界的“操作系统抽象层”</strong><br>它让模型能直接访问文件、数据库、网络等工具。</p>
</blockquote>
<p>它的“能力”比 Function Call 强得多，因为：</p>
<p>👉 <strong>Function Call 只能调用开发人员手工写死的函数</strong><br>👉 <strong>MCP 可以动态加载工具包、文件系统服务、环境服务，让模型像操作系统用户一样访问资源</strong></p>
<hr>
<h3 id="✔-MCP-示例"><a href="#✔-MCP-示例" class="headerlink" title="✔ MCP 示例"></a>✔ MCP 示例</h3><p>假设 MCP 提供一个工具 <code>fs.read_file</code>。</p>
<p>用户问：</p>
<blockquote>
<p>“打开 &#x2F;docs&#x2F;intro.md 读给我听”</p>
</blockquote>
<p>模型实际会产生这样的消息（非 Function Call 风格，而是 MCP 消息协议）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.read_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/intro.md&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>服务端会执行 <strong>read_file</strong> 并返回文件内容。</p>
<p>模型可以继续请求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.write_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/notes.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里是我总结的内容...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里体现 MCP 的本质：</p>
<ul>
<li>模型知道有哪些工具可用</li>
<li>模型直接“操控”这些工具</li>
<li>具有类似“文件读写”等复杂能力</li>
<li>不需要开发者提前硬编码所有函数</li>
</ul>
<h2 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>Function Call</th>
<th>MCP</th>
</tr>
</thead>
<tbody><tr>
<td>工具发现</td>
<td>手工定义</td>
<td>自动注册，模型可自动学习工具能力</td>
</tr>
<tr>
<td>调用方式</td>
<td>结构化 JSON</td>
<td>双向协议、消息通信</td>
</tr>
<tr>
<td>扩展性</td>
<td>每加一个功能都要新增函数定义</td>
<td>新增 MCP 服务即可扩展工具能力</td>
</tr>
<tr>
<td>模型能力</td>
<td>被动</td>
<td>主动、可规划调用流程</td>
</tr>
<tr>
<td>场景</td>
<td>简单 API 调用、数据结构化</td>
<td>IDE、数据库集成、文件系统、GitHub 操作、企业自动化</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java漏洞靶场搭建学习(一)：环境搭建与Springboot架构</title>
    <url>/2025/12/09/Java%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8ESpringboot%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Java漏洞靶场搭建学习"><a href="#Java漏洞靶场搭建学习" class="headerlink" title="Java漏洞靶场搭建学习"></a>Java漏洞靶场搭建学习</h1><p>在学习 Java Web 安全的过程中，目前状态是只能理解相关的漏洞原理，根据 PoC 做题或者复现漏洞，但是这些对于 <strong>代码审计、漏洞挖掘、SDL</strong> 等都没有实质性帮助，想要在学习或工作过程中提升相关能力，计划实现以下目标：</p>
<ul>
<li>理解漏洞产生的真实上下文；</li>
<li>搭建一个可控、可扩展的实验环境；</li>
<li>训练从代码层面定位与修复问题的能力；</li>
</ul>
<p>这篇博客记录了学习搭建 Java 漏洞靶场的过程，作为一个学习记录，为后续能够快速搭建测试环境，验证代码审计工具能力奠定基础。</p>
<span id="more"></span>

<h2 id="项目选用"><a href="#项目选用" class="headerlink" title="项目选用"></a>项目选用</h2><p>本文以 <a href="https://github.com/l4yn3/micro_service_seclab">micro_service_seclab</a> 为基础进行练习。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/l4yn3/micro_service_seclab.git</span><br></pre></td></tr></table></figure>

<p>拿到java项目，导入IDEA，对于有pom.xml的项目，可以直接使用mvn进行构建。</p>
<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--链接数据库</span></span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE micro_service_seclab</span><br><span class="line">  <span class="keyword">CHARACTER SET</span> utf8mb4</span><br><span class="line">  <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用数据库</span></span><br><span class="line">USE micro_service_seclab;</span><br></pre></td></tr></table></figure>

<p>执行sql文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> \d D:\Code\micro_service_seclab</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line">mysql -u root -p micro_service_seclab &lt; micro_service_seclab.sql</span><br></pre></td></tr></table></figure>

<p>需要找到 application.properties  文件，修改对应的数据库用户名和密码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/micro_service_seclab</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=1234</span></span><br></pre></td></tr></table></figure>

<p>在pom.xml的路径下，执行mvn命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure>

<p>启动后访问 <a href="http://127.0.0.1:8080/sqlinjection/one?username=yueshen">http://127.0.0.1:8080/sqlinjection/one?username=yueshen</a> 即可看到返回以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;username&quot;</span>:<span class="string">&quot;yueshen&quot;</span>,<span class="string">&quot;sex&quot;</span>:1,<span class="string">&quot;age&quot;</span>:33&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h2><h3 id="Spring-Boot-三层架构"><a href="#Spring-Boot-三层架构" class="headerlink" title="Spring-Boot 三层架构"></a>Spring-Boot 三层架构</h3><p>该项目核心是一个 Spring Boot Web 应用，通过不同的 Controller 暴露漏洞演示接口；底层再通过 Logic&#x2F;DAO&#x2F;DB&#x2F;MyBatis 访问数据库或触发危险点。</p>
<p>调用链（一次请求的完整路径）：</p>
<blockquote>
<p>HTTP 请求 → controller（漏洞入口） → logic（业务&#x2F;场景封装） → dao&#x2F;mapper（数据访问&#x2F;危险实现） → db&#x2F;mysql</p>
</blockquote>
<p>用通俗的话来记录，就是：</p>
<p>Controller 提供靶场入口，Logic 做业务组织，DAO&#x2F;Mapper 负责数据库或危险 API 调用，data 是实体&#x2F;数据模型，db 是数据库初始化&#x2F;连接辅助。</p>
<ul>
<li><code>Controller</code>：漏洞入口层，对外提供 HTTP API，用户通过 HTTP 打开，它负责把请求带入对应的漏洞场景；</li>
<li><code>Logic</code>：业务场景封装层，存放 Service 的一些东西，把 Controller 参数变成底层可执行的动作；</li>
<li><code>Dao</code>：数据访问层，做数据持久化，方法针对数据库操作；</li>
<li><code>Mapper</code>：MyBatis Mapper 接口层，存放 MyBatis 的接口定义；</li>
<li><code>data</code>：数据模型 实体层 对应数据库表或接口数据结构；</li>
</ul>
<h3 id="部署搭建记录"><a href="#部署搭建记录" class="headerlink" title="部署搭建记录"></a>部署搭建记录</h3><p>首先选择新建项目：</p>
<p><img src="/../uploads/java_range1.png"></p>
<p>通过Springboot Initializr初始化项目:</p>
<p><img src="/../uploads/java_range2.png"></p>
<p>选择相关依赖：</p>
<p><img src="/../uploads/java_range3.png"></p>
<p>初始化项目结构如下：</p>
<p><img src="/../uploads/java_range4.png"></p>
<p>依赖还是存在一些问题，因为靶场对应的是Java1.8版本，但是IDEA创建project时只有17、21和25可选项（这个应该有办法解决，后续再搞），不过目前已经清楚了Springboot的架构是什么样子。</p>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="db-IndexDb-java"><a href="#db-IndexDb-java" class="headerlink" title="db&#x2F;IndexDb.java"></a>db&#x2F;IndexDb.java</h3><p><code>IndexDb.java</code> 是一个基于 <code>JdbcTemplate</code> 的数据库访问类，负责从 students 和 teachers 表中查询数据，同时为了漏洞靶场演示，刻意使用字符串拼接 SQL，存在明显的 SQL 注入风险。</p>
<p>详细解读：</p>
<ul>
<li><p>被标记为 @Repository，供其他层（如 IndexLogic &#x2F; Controller）注入使用。</p>
</li>
<li><p>内部定义了两个 RowMapper，把查询结果映射成 Student 和 Teacher 对象。</p>
</li>
<li><p>提供多种查询方法：</p>
<ol>
<li><p>按用户名模糊查询学生：getStudent &#x2F; getStudentWithOptional</p>
</li>
<li><p>按 id 查询学生：getStudentById</p>
</li>
<li><p>按 id 查询教师：getTeacherById</p>
</li>
<li><p>使用 IN 条件批量用户名查询学生：getStudentWithIn &#x2F; getStudentWithInLong</p>
</li>
</ol>
</li>
</ul>
<p>所有 SQL 都是直接拼接字符串（包括 Optional、List 的拼接）作为靶场中演示 SQL 注入的重要部分。截取部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexDb</span></span><br><span class="line"><span class="comment"> * 使用 Spring 的 JdbcTemplate 直接操作数据库的仓库类。</span></span><br><span class="line"><span class="comment"> * 主要提供针对 students / teachers 表的查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：本类为了配合“Java 漏洞靶场”，大量使用字符串拼接构造 SQL，</span></span><br><span class="line"><span class="comment"> *       实际上存在典型的 SQL 注入风险，用于安全演示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexDb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring 注入 JdbcTemplate，用于执行 SQL 语句</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Student 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Student&gt; ROW_MAPPER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        student.setSex(rs.getInt(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        student.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Teacher 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Teacher&gt; ROW_MAPPER_TEACHER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        teacher.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        teacher.setSex(rs.getBoolean(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        teacher.setName(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生信息。</span></span><br><span class="line"><span class="comment">     * 漏洞点：直接拼接 username 到 SQL 中，存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 安全写法示例（被注释掉）：使用占位符并绑定参数</span></span><br><span class="line">        <span class="comment">// String sql = &quot;select * from students where username like ?&quot;;</span></span><br><span class="line">        <span class="comment">// return jdbcTemplate.query(sql, new Object[]&#123;&quot;%&quot; + username + &quot;%&quot;&#125;, ROW_MAPPER);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名进行模糊查询。</span></span><br><span class="line"><span class="comment">     * 实际上仍然是字符串拼接，同样存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithOptional</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username.get() + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 id 精确查询学生。</span></span><br><span class="line"><span class="comment">     * 漏洞点：将 id 转成字符串再拼接到 SQL 中，存在注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithInt</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where id = &#x27;&quot;</span> + String.valueOf(id) + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithInt, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="logic-IndexLogic-java"><a href="#logic-IndexLogic-java" class="headerlink" title="logic&#x2F;IndexLogic.java"></a>logic&#x2F;IndexLogic.java</h3><p><code>IndexLogic.java</code> 本质上是<strong>Service 层的一个浅封装</strong>：</p>
<ul>
<li>用 <code>@Service</code> 标记，表示这是业务逻辑层的 Bean；</li>
<li>通过 <code>@Autowired</code> 注入 <code>IndexDb</code>（4.1节对应的那个数据库访问类）；</li>
<li>对外提供一组方法：<code>getStudent</code> &#x2F; <code>getStudentById</code> &#x2F; <code>getStudentWithOptional</code> &#x2F; <code>getStudentWithIn</code> &#x2F; <code>getStudentWithInLong</code> &#x2F; <code>getTeacherById</code>；</li>
<li>每个方法都<strong>直接把参数原样转发给 <code>IndexDb</code>，不做额外处理</strong>，相当于“转发层”；</li>
<li>因为 <code>IndexDb</code> 里面的 SQL 是拼接的，所以这些 Service 方法也就“顺带”暴露出 SQL 注入漏洞场景，方便 Controller 调用。</li>
</ul>
<p>可以理解为：<br><strong>Controller -&gt; IndexLogic -&gt; IndexDb -&gt; Databases</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexLogic</span></span><br><span class="line"><span class="comment"> * 业务逻辑层（Service），对外提供学生 / 老师相关的查询接口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当前实现非常薄，只是简单地把调用转发给 IndexDb，</span></span><br><span class="line"><span class="comment"> * 主要起到：Controller 与 DB 操作之间的“中间层”作用，</span></span><br><span class="line"><span class="comment"> * 方便保持三层架构的结构清晰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于底层 IndexDb 使用字符串拼接 SQL，</span></span><br><span class="line"><span class="comment"> * 这些方法实际也用于配合漏洞靶场演示 SQL 注入场景。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexLogic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入数据库访问类 IndexDb</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IndexDb indexDb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudent(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithOptional(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（字符串列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithIn</span><span class="params">(List&lt;String&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithIn(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（Long 列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithInLong</span><span class="params">(List&lt;Long&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithInLong(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据“id/userName”查询老师</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getTeacherById</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getTeacherById(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IndexLogic 是 Controller 和 IndexDb 之间的桥梁，把各种查询操作组织成业务接口，方便暴露为 HTTP 靶场接口。</strong></p>
<hr>
<h3 id="mapper-IStudentMapper-java"><a href="#mapper-IStudentMapper-java" class="headerlink" title="mapper&#x2F;IStudentMapper.java"></a>mapper&#x2F;IStudentMapper.java</h3><p>IStudentMapper 是 students 表的 MyBatis 接口，其中 <code>queryAllByAnnotations</code> 用注解 + <code>$&#123;&#125;</code> 拼串，专门用来检测注解式 SQL 注入漏洞。</p>
<p>Mapper <strong>≈</strong> 映射器，他的作用是把 “Java 方法调用” 映射成 “SQL 语句执行”，再把结果映射回 Java 对象。也可以称为“MyBatis 帮忙自动实现的 DAO 接口”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IStudentMapper</span></span><br><span class="line"><span class="comment"> * MyBatis 的 Mapper 接口，对 students 表提供查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个接口有两个目的：</span></span><br><span class="line"><span class="comment"> * 1）正常的查询方法（queryAll），SQL 通常写在 XML 中；</span></span><br><span class="line"><span class="comment"> * 2）使用注解 + $&#123;&#125; 拼接参数的方式，故意制造 SQL 注入漏洞，</span></span><br><span class="line"><span class="comment"> *    用于测试代码扫描工具是否能识别注解里的注入问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一：常规查询方法</span></span><br><span class="line"><span class="comment">     * SQL 写在 resources/mappers/IStudentMapper.xml 中，</span></span><br><span class="line"><span class="comment">     * 一般会使用 #&#123;name&#125; 这种占位符，属于参数绑定写法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAll</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式二：注解式 SQL，故意使用 $&#123;&#125; 直接拼接参数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里的 SQL：</span></span><br><span class="line"><span class="comment">     *   select * from students where username =&#x27;$&#123;name&#125;&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * $&#123;name&#125; 会被原样替换到 SQL 中，存在明显的 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     * 这是靶场中专门用来测试“静态扫描工具能否发现注解里的 SQL 注入”的例子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from students where username =&#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAllByAnnotations</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="data-Person-java"><a href="#data-Person-java" class="headerlink" title="data&#x2F;Person.java"></a>data&#x2F;Person.java</h3><p>data 文件夹下专门存放了“数据模型”，可以保存数据库和业务里的“实体对象”。同时作为各个层次之间传递数据的载体：</p>
<ul>
<li><p>db&#x2F;IndexDb 查出来的是 List<Student>、List<Teacher></p>
</li>
<li><p>logic&#x2F;IndexLogic 接收&#x2F;返回的也是这些对象</p>
</li>
<li><p>Controller 对外返回的 JSON，其实就是把这些 data 类序列化出去</p>
</li>
</ul>
<p>👉 这样 Controller、Service、DAO 都围绕同一套“数据结构”在交流。</p>
<p>Person 是用 JPA+Hibernate 映射出来的人员表实体，用 UUID 当主键，并强制 username 和 nickname 的唯一性与非空约束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person 实体类：</span></span><br><span class="line"><span class="comment"> * 映射数据库中的 person 表（默认表名），</span></span><br><span class="line"><span class="comment"> * 使用 UUID 作为主键，包含唯一且必填的 username / nickname 字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主键 ID，使用自定义的 UUID 生成策略</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(generator = &quot;idGenerator&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 昵称列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;nickname&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dao-PersonRepository-java"><a href="#dao-PersonRepository-java" class="headerlink" title="dao&#x2F;PersonRepository.java"></a>dao&#x2F;PersonRepository.java</h3><p><code>PersonRepository</code> 是一个基于 Spring Data JPA 的 DAO 接口，负责对 Person 实体做数据库查询：根据 username 和 nickname 查人，供 Controller 或 Service 调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersonRepository</span></span><br><span class="line"><span class="comment"> * 基于 Spring Data JPA 的 DAO 接口，</span></span><br><span class="line"><span class="comment"> * 用于对 Person 实体进行数据库访问操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过继承 JpaRepository，可以直接使用通用的增删改查方法，</span></span><br><span class="line"><span class="comment"> * 同时也可以定义派生查询方法或自定义 <span class="doctag">@Query</span> 查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Person, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Spring Data JPA 的“方法名派生查询”功能，</span></span><br><span class="line"><span class="comment">     * 根据 username 字段查询 Person 列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 等价于：SELECT p FROM Person p WHERE p.username = ?1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 <span class="doctag">@Query</span> 手写 JPQL 查询，根据 nickname 查询。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT nickname FROM Person WHERE nickname = &#x27;?1&#x27;&quot;)</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByNickname</span><span class="params">(String nickname)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="controller-VulnerabilitiesController-java"><a href="#controller-VulnerabilitiesController-java" class="headerlink" title="controller&#x2F;VulnerabilitiesController.java"></a>controller&#x2F;VulnerabilitiesController.java</h3><p><code>controller</code> 文件夹用来存放项目里的控制器类，也就是对外暴露 HTTP 接口的那一层。在 Spring Boot 里，Controller 负责接收浏览器或工具（如 Postman、burp）的请求，解析参数，把请求转交给逻辑层（logic&#x2F;service），再把返回结果封装成 JSON 或页面响应。</p>
]]></content>
      <categories>
        <category>Java Security</category>
      </categories>
      <tags>
        <tag>Java Security</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器系统资源查看</title>
    <url>/2025/12/17/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<h2 id="Linux服务器系统资源查看"><a href="#Linux服务器系统资源查看" class="headerlink" title="Linux服务器系统资源查看"></a>Linux服务器系统资源查看</h2><p>系统性地查看 Linux 服务器资源，也就是看CPU、内存、磁盘、网络、负载、系统等这几个层面，就能了解服务器性能以及运行情况。</p>
<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>查看系统负载和运行时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br><span class="line"></span><br><span class="line">10:35:15 up  1:34, 13 <span class="built_in">users</span>,  load average: 0.41, 0.30, 0.25</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>10:35:15</code> 表示当前系统时间是 10 点 35 分 15 秒，<code>up 1:34</code> 表示系统已经连续运行了 1 小时 34 分钟，<code>13 users</code>表示当前有 13 个用户会话登录到系统中，<code>load average: 0.41, 0.30, 0.25</code> 表示系统负载均值（Load Average），表示正在运行 + 等待运行的进程数量的平均值，三个数字分别表示最近1&#x2F;5&#x2F;15 分钟的平均负载。</p>
<blockquote>
<p><strong>Load Average &#x3D; 在某段时间内，处于「可运行状态」和「不可中断睡眠状态」进程数量的指数加权移动平均（EWMA），统计的是想用 CPU 的进程有多少。</strong></p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line"></span><br><span class="line">top - 10:52:33 up  1:52, 11 <span class="built_in">users</span>,  load average: 1.14, 0.57, 0.32</span><br><span class="line">Tasks: 2645 total,   2 running, 2643 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.8 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem : 10 total, 8 free,  6 used,  4 buff/cache</span><br><span class="line">MiB Swap:  3 total, 2 free,  1 used.  2 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  77552 xrdp      20   0   50360  20344   6856 R  18.0   0.0   0:30.70 xrdp</span><br><span class="line">  77960 mark      20   0 9361988 422920 185124 S  14.1   0.1   0:59.67 gnome-shell</span><br><span class="line">  77569 mark      20   0  382544 138588  80324 S   5.6   0.0   0:11.17 Xorg</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详解 top 输出命令内容：</p>
<p>第一行表示时间、运行时长、登录用户、平均负载；</p>
<p>第二行展示了任务数和进程状态，包含进程&#x2F;线程统计总数、正在 CPU 上运行的（或准备运行的）任务数、睡眠、进程和僵尸进程数量；</p>
<p>第三行展示了 CPU 使用构成，us用户态、sy内核态、ni被nice调整过优先级的用户态进程、id (idle) CPU空闲率、wa CPU在等 IO（磁盘&#x2F;网络存储）导致空转等待率，hi硬中断消耗，si软中断消耗；</p>
<p>第四行展示了内存：total总内存、free完全空闲内存、used真正被进程使用的内存、buff&#x2F;cache文件缓存块设备缓存；</p>
<p>第五行展示了 Swap 交换分区，Swap（交换分区&#x2F;交换文件）是内存不足时的“备用空间”，当 物理内存（RAM）不够用 时，Linux 会把暂时不用的内存页交换到磁盘上的 swap 中，从而防止系统因内存耗尽而直接崩溃（OOM），让系统还能继续运行；</p>
<p>下面展示了系统进程的详细信息：</p>
<p>表头：</p>
<p><code>PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</code></p>
<p>PID：进程号</p>
<p>USER：所属用户</p>
<p>PR：动态优先级（数值越小优先级越高；20 常见）</p>
<p>NI：nice 值（-20 到 19，越小越“抢”CPU；0 默认）</p>
<p>VIRT：虚拟内存占用（进程可见的地址空间总量，包含映射文件、共享库、未实际用到的保留空间等）</p>
<p>RES：常驻内存（实际占用物理内存，最值得关注）</p>
<p>SHR：共享内存部分（共享库等）</p>
<p>S：状态</p>
<p>R&#x3D;运行，S&#x3D;睡眠，D&#x3D;不可中断睡眠(常见 IO 卡住)，Z&#x3D;僵尸</p>
<p>%CPU：CPU 占比（注意：多核时可能 &gt;100%）</p>
<p>%MEM：内存占比</p>
<p>TIME+：累计消耗 CPU 时间</p>
<p>COMMAND：命令名</p>
<h3 id="lscpu"><a href="#lscpu" class="headerlink" title="lscpu"></a>lscpu</h3><p>查看 cpu 架构，重点关注 CPU 型号、数量、解构等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Architecture: x86_64</span><br><span class="line"></span><br><span class="line">Model name: AMD</span><br><span class="line"></span><br><span class="line">CPU(s):                2</span><br><span class="line">Thread(s) per core:    2</span><br><span class="line">Core(s) per socket:    1</span><br><span class="line">Socket(s):             1</span><br></pre></td></tr></table></figure>

<h3 id="free-h"><a href="#free-h" class="headerlink" title="free -h"></a>free -h</h3><p>查看内存资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br><span class="line">             total       used      free      shared  buff/cache   available</span><br><span class="line">Mem:           5Gi        1Gi       4Gi        87Mi         1Gi         3Gi</span><br><span class="line">Swap:          1Gi         0B       1Gi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="df-h"><a href="#df-h" class="headerlink" title="df -h"></a>df -h</h3><p>查看磁盘资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line">Filesystem      Size  Used Avail  Use%  Mounted on</span><br><span class="line">tmpfs             2G  3.9M    1G   50%  /run</span><br><span class="line">/dev/nvme        10G    5G    5G   50%  /</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ip-s-link"><a href="#ip-s-link" class="headerlink" title="ip -s link"></a>ip -s link</h3><p>查看网络资源，这个要视情况而定，还有ss、netstat等命令。</p>
<h3 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h3><p>查看系统及内核版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/os-release</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p>查看系统中安装的所有PCI设备。</p>
<h3 id="nvidia-smi"><a href="#nvidia-smi" class="headerlink" title="nvidia-smi"></a>nvidia-smi</h3><p>查看显卡型号。</p>
<h2 id="服务器使用规范"><a href="#服务器使用规范" class="headerlink" title="服务器使用规范"></a>服务器使用规范</h2><p>w 或 who 查看当前在线登录的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查看当前系统下的所有用户</span></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建用户</span></span><br><span class="line"><span class="built_in">sudo</span> useradd name</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> useradd -m -s /bin/bash name</span><br><span class="line"></span><br><span class="line"><span class="comment"># -m 自动创建家目录，-s指定shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为新用户指定密码</span></span><br><span class="line"><span class="built_in">sudo</span> passwd name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给新用户追加到 sudo 组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG <span class="built_in">sudo</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化版，添加用户时即指定其加入sudo组</span></span><br><span class="line"><span class="built_in">sudo</span> useradd -m -s /bin/bash -G <span class="built_in">sudo</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户环境 - 表示加载用户环境</span></span><br><span class="line">su - name </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO使用记录</title>
    <url>/2025/12/04/HEXO%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Hexo-使用记录"><a href="#Hexo-使用记录" class="headerlink" title="Hexo 使用记录"></a>Hexo 使用记录</h1><p>参考文献： <a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
<p>官方文档：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<h2 id="HEXO-简介"><a href="#HEXO-简介" class="headerlink" title="HEXO 简介"></a>HEXO 简介</h2><p>Hexo 是一个基于 Node.js 的快速、简洁且高效的静态博客框架。它拥有超快的渲染速度、灵活的配置方式，以及丰富的主题与插件生态。借助 Markdown 写作，可以轻松生成优雅的静态网页，并部署到 GitHub Pages、Vercel、Netlify 等任意静态托管平台。无论是想建立个人博客、文档站点，还是打造独特的技术分享空间，Hexo 都能提供流畅而高效的创作体验。</p>
<span id="more"></span>

<h2 id="一、Hexo-安装"><a href="#一、Hexo-安装" class="headerlink" title="一、Hexo 安装"></a>一、Hexo 安装</h2><p>Hexo 是一个快速、简单且功能强大的博客框架，可以使用 Markdown （或其他标记语言）编写文章，Hexo 会在几秒钟内生成带有对应主题的静态文件。</p>
<p>安装 Hexo 需要 Node.js 以及 Git 环境。</p>
<p>Node.js 下载地址 <a href="https://nodejs.org/en/download">Node.js Download</a></p>
<p>Git 下载地址 <a href="https://git-scm.com/install/windows">Git Download</a></p>
<p>所有必需组件安装完毕后，即可使用 npm 安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>初始化 Hexo 站点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexo-site</span><br></pre></td></tr></table></figure>
<p>hexo-site 也可以替换为其他路径名，以 hexo-site 为例，网站根目录被称为 <code>hexo-site</code>。 </p>
<p>初始化完成后，可以到网站根目录下，下载对应主题并进行升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-site</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>运行 npm install 时，对 node_modules 目录下主题所做的任何本地更改都将丢失。如果对主题进行了更改，则应在运行 npm install 之前备份这些更改，然后在安装完成后恢复这些更改。</p>
<p>安装完 Hexo 和 NexT 主题后，可以通过修改配置文件来自定义博客。安装 Hexo 时，配套的配置文件位于网站根目录。博客配置文件名为 _config.yml ；我们称之为 Hexo 配置文件 NexT 主题的配置文件需要您自行创建；请在目录下创建一个 _config.next.yml 文件。 网站根目录我们将其称为 Next 配置文件在以下文本中。</p>
<p>创建空的 _config.next.yml 文件后，可以将主题文件夹中的默认配置选项复制到该文件中，以便进行修改和自定义。根据安装方式，NexT 主题的默认配置文件可能位于 themes&#x2F;next&#x2F;_config.yml 或 node_modules&#x2F;hexo-theme-next&#x2F;_config.yml 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>

<h2 id="二、Hexo-个性化设置"><a href="#二、Hexo-个性化设置" class="headerlink" title="二、Hexo 个性化设置"></a>二、Hexo 个性化设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove unnecessary files after hexo generate.</span></span><br><span class="line">minify: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line">darkmode: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:zyufoye/zyufoye.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、Hexo-新建发布文章"><a href="#三、Hexo-新建发布文章" class="headerlink" title="三、Hexo 新建发布文章"></a>三、Hexo 新建发布文章</h2><p>新建发布文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成并部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp;  hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>同步更新部署到github：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>博客侧边栏添加 menu 菜单，以 tags 和 categories 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>同时在index.md 中设置类别，不然点击跳转后不显示任何内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>: categories</span><br></pre></td></tr></table></figure>

<p>设置文章想要显示的内容时，可以用 more 进行切分， more以上的作为显示内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>以上基本配置和简单使用记录完毕，后续有更多需要再持续更新记录。  </p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO链接站内文章方法</title>
    <url>/2025/12/11/HEXO%E9%93%BE%E6%8E%A5%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Hexo链接站内文章方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link markdown-learning-by-maxiang 点击这里查看这篇文章 %&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>markdown-learning-by-maxiang</code> 为文章名称，我测试了同目录下修改为自己文章名称可以成功，注意不要加路径，如果文章名称有空格就用双引号引起来。<code>点击这里查看这篇文章</code> 是显示的内容，如果不写的话就默认是文章名称。</p>
<p>参考链接：<a href="https://github.com/iissnan/hexo-theme-next/issues/978">https://github.com/iissnan/hexo-theme-next/issues/978</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（一）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-概念"><a href="#MCP-概念" class="headerlink" title="MCP 概念"></a>MCP 概念</h2><p>MCP 编程快速入门，MCP 全称 Model Context Protocol 模型上下文协议，其定义了 LLMs 与外部世界的互动方式，MCP 提供了一种标准化方法，使任意 LLMs 能够轻松连接各种数据源和工具，实现信息的高效交互和处理。</p>
<p>目前的 AI 朝着两个方向发展：<strong>掌握更多信息</strong> 或 <strong>控制更多工具</strong>，在没有联网搜索之前，LLM 的数据来源只有训练时和推理时我们提供的数据。</p>
<p>在MCP出现之前，如果LLM要访问外部数据，通常使用<code>Function Call</code>的方式，<code>Function Call</code>通过给模型预设函数描述（包括函数名、参数说明、返回值格式等），让模型在合适的时候返回一个符合结构的 JSON 格式，外部系统再解析这个 JSON，调用实际的后端函数。关于 <code>Function Call</code> 和<code>MCP</code> 的具体区别在 <a href="/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Function Call和MCP的区别">Function Call和MCP的区别</a></p>
<p>但 <code>Function Call</code> 的方式没有一个统一的开发规范，你开发的函数我不能用，我开发的函数你不能用，而且开发起来很麻烦，为了解决这个问题，MCP 出现了。MCP作为LLMs的标准化工具箱，可以通过MCP调用外界的AI工具，而AI工具在开发的时候也需要遵循MCP协议。MCP 允许应用以标准化的方式向 LLM 提供上下文，并将<strong>提供上下文的逻辑</strong>与<strong>实际的LLM交互逻辑”</strong>解耦。</p>
<p>在没有 MCP 之前，如果我们希望让模型使用本地数据，通常需要把这些数据直接复制到对话框中，让模型从文本中获取信息。而有了 MCP 之后，我们可以为特定能力编写一个 MCP Server，例如数据库读取、GitHub 操作、文件系统访问或获取当前时间等。模型通过 MCP 与这些 Server 通信，就能在无需手动粘贴数据的情况下，实时访问这些外部资源。</p>
<p><img src="/../uploads/MCP_1.png"></p>
<p>MCP 服务器可以提供三种主要类型的功能:</p>
<ol>
<li>资源访问：客户端读取文件等数据；</li>
<li>工具调用：由LLM调用的函数；</li>
<li>Prompt模板：预先编写的帮助客户完成特定任务的Prompt；</li>
</ol>
<span id="more"></span>

<h2 id="MCP-Deno-开发"><a href="#MCP-Deno-开发" class="headerlink" title="MCP Deno 开发"></a>MCP Deno 开发</h2><p>使用python的SDK，简单实现下面功能，用来加深理解：</p>
<ol>
<li>构建可连接到任何 MCP Server 的 MCP Client</li>
<li>创建公开资源、提示和工具的 MCP Server</li>
<li>使用 stdio 和 SSE 等标准传输</li>
<li>处理所有 MCP 协议消息和生命周期事件</li>
</ol>
<p>一般关于MCP的项目，开发者们都喜欢用uv来管理，不晓得为什么，但是跟着用一下，相关安装使用方法参照 <a href="/2025/12/10/uv%E4%BD%BF%E7%94%A8/" title="uv使用">uv使用</a> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的项目</span></span><br><span class="line">uv init mcp-demo</span><br><span class="line"><span class="built_in">cd</span> mcp-demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">uv venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">uv add <span class="string">&quot;mcp[cli]&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这样一个uv管理的python MCP 项目就初始化完成了。</p>
<p>接下来编写第一个简单Demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 FastMCP 实例</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例工具</span></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例资源</span></span><br><span class="line"><span class="meta">@mcp.resource(<span class="params"><span class="string">&quot;greeting://&#123;name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;FastMCP Demo Server is running ......&quot;</span>)</span><br><span class="line">    mcp.run()</span><br></pre></td></tr></table></figure>

<p>示例代码中，使用了FastMCP来初始化一个MCP Server实例，分别创建了三个函数：</p>
<ul>
<li>echo：字符串输出；</li>
<li>add：两个数字相加；</li>
<li>greet：输入字符串，拼接后返回字符串；</li>
</ul>
<p>通过两个注解，赋予了函数不同的能力：</p>
<ul>
<li>@tool()：函数可以直接被AI调用；</li>
<li>@resource()：像API接口一样被调用，其中的参数 greeting:&#x2F;&#x2F;{name} 是一个自定义的 URI， 可以拆解为两个部分。greeting 是随便起的前缀，name是动态参数的名称，在访问的时候需要传入。</li>
</ul>
<p>测试命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mcp dev server.py</span><br></pre></td></tr></table></figure>

<p><code>mcp dev</code>是开发调试模式，输入这条命令后，会打开一个 MCP Inspector ，可以直观地检查和测试 MCP Server（server.py）是否正常工作。</p>
<p><img src="/../uploads/MCP_2.png"></p>
<p>点击 Connect ，选择 Tools，List Tools，即可列出 MCP 中定义的工具，可以输入测试内容进行 run tools测试:</p>
<p><img src="/../uploads/MCP_3.png"></p>
<p>在 Resources 标签页下，可以看到定义的资源函数 greet:</p>
<p><img src="/../uploads/MCP_4.png"></p>
<p>传入动态参数，mcp server 就会返回 json 格式的响应，并将我们输入的 api 拼接后返回。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>博客记录了对于 MCP 的理解，以及一个简单的Demo，后续在这个基础上继续完善。</p>
<p>对 MCP Server 的开发是 MCP应用的重点，作者提到 MCP Server 其实就是定义一些函数，让智能体调用。在函数中可以实现简单逻辑、接口调用和各种操作，并通过注解赋予函数不同的能力。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>什么是MCP？本地如何开发MCP Server：<a href="https://cloud.tencent.com/developer/article/2511642">https://cloud.tencent.com/developer/article/2511642</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP stdio与sse模式的区别</title>
    <url>/2025/12/15/MCP-stdio%E4%B8%8Esse%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="SSE-和-stdio-模式对比"><a href="#SSE-和-stdio-模式对比" class="headerlink" title="SSE 和 stdio 模式对比"></a>SSE 和 stdio 模式对比</h2><h3 id="架构差异"><a href="#架构差异" class="headerlink" title="架构差异"></a>架构差异</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">stdio 模式：</span><br><span class="line">Cursor/Claude Desktop</span><br><span class="line">    └─ 启动子进程：python server.py</span><br><span class="line">        └─ stdin/stdout 通信</span><br><span class="line">        └─ 服务器生命周期由客户端管理</span><br><span class="line"></span><br><span class="line">SSE 模式：</span><br><span class="line">独立运行：python server.py (后台持续运行)</span><br><span class="line">    ↑</span><br><span class="line">    └─ HTTP SSE 连接</span><br><span class="line">    ↑</span><br><span class="line">Cursor/Claude Desktop (通过 HTTP 连接)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>stdio 模式</th>
<th>SSE 模式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>启动方式</strong></td>
<td>客户端自动启动</td>
<td>手动启动（独立进程）</td>
</tr>
<tr>
<td><strong>通信协议</strong></td>
<td>stdin&#x2F;stdout 管道</td>
<td>HTTP + Server-Sent Events</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>单一客户端</td>
<td>多客户端支持</td>
</tr>
<tr>
<td><strong>调试难度</strong></td>
<td>难（日志混在一起）</td>
<td>易（可直接查看终端）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>生产环境</td>
<td>开发调试</td>
</tr>
<tr>
<td><strong>进程管理</strong></td>
<td>自动（随客户端）</td>
<td>手动（需要单独管理）</td>
</tr>
<tr>
<td><strong>网络要求</strong></td>
<td>无</td>
<td>需要监听端口</td>
</tr>
<tr>
<td><strong>日志可见性</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="测试时为什么选择-SSE？"><a href="#测试时为什么选择-SSE？" class="headerlink" title="测试时为什么选择 SSE？"></a>测试时为什么选择 SSE？</h3><ul>
<li><p>✅ 开发调试更方便：可以直接在终端看到所有日志，手动重启服务器，用浏览器测试连接；</p>
</li>
<li><p>✅ 多客户端支持：多个 IDE 可以同时连接，可以同时在 Cursor 和 Claude Desktop 中使用；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（二）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="模型如何确定工具选用？"><a href="#模型如何确定工具选用？" class="headerlink" title="模型如何确定工具选用？"></a>模型如何确定工具选用？</h2><p>Anthropic 详细解释了这个问题：模型在什么时候确定使用哪些工具。</p>
<p>当用户提出一个问题时：</p>
<ol>
<li>客户端（Claude Desktop &#x2F; Cursor）将问题发送给 Claude；</li>
<li>Claude 分析可用的工具，并决定使用哪一个（或多个）；</li>
<li>客户端通过 MCP Server 执行所选的工具；</li>
<li>工具的执行结果被送回给 Claude；</li>
<li>Claude 结合执行结果构造最终的 prompt 并生成自然语言的回应；</li>
<li>回应最终展示给用户！</li>
</ol>
<p>MCP Server 是由 Claude 主动选择并调用的，这个主动选择的过程可以分为两步：</p>
<ol>
<li>由 LLM（Claude）确定使用哪些 MCP Server；</li>
<li>执行对应的 MCP Server 并对执行结果进行重新处理；</li>
</ol>
<p>MCP 流程图如下：</p>
<p><img src="/../uploads/MCP_11.jpg"></p>
<p>流程图展示了 LLM 在接收到用户输入后，根据系统提示中提供的指令与工具描述，决定是否需要调用外部工具（包括 MCP Server 提供的工具）。<br>首先，用户输入与系统 prompt（包含工具的结构化描述）一同交给模型生成 Message1。如果模型判断某个任务需要借助工具完成（Case 1），它会生成一段结构化的 Tool call JSON，并由外部执行环境或 MCP Server 负责实际执行工具逻辑。执行结果再返回给模型，模型基于这份结果生成最终回答；<br>如果模型判断不需要工具（Case 2），则直接生成最终输出。<br>整个流程体现了：LLM 负责“决定用什么工具及如何调用”，而 MCP Servers 等外部系统负责“实际执行任务并返回数据”，从而实现模型与外部能力的协作。</p>
<span id="more"></span>

<h2 id="模型如何智能选择工具？"><a href="#模型如何智能选择工具？" class="headerlink" title="模型如何智能选择工具？"></a>模型如何智能选择工具？</h2><p>模型如何确定该使用哪些工具，MCP 官方提供的 client example 示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="comment"># 初始化所有的 mcp server</span></span><br><span class="line">     <span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable language_">self</span>.servers:</span><br><span class="line">         <span class="keyword">await</span> server.initialize()</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 获取所有的 tools 命名为 all_tools</span></span><br><span class="line">     all_tools = []</span><br><span class="line">     <span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable language_">self</span>.servers:</span><br><span class="line">         tools = <span class="keyword">await</span> server.list_tools()</span><br><span class="line">         all_tools.extend(tools)</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 将所有的 tools 的功能描述格式化成字符串供 LLM 使用</span></span><br><span class="line">     <span class="comment"># tool.format_for_llm() 我放到了这段代码最后，方便阅读。</span></span><br><span class="line">     <span class="comment"># 为 LLM 生成工具说明文档，告诉模型：有哪些工具、各自干啥、要什么参数。</span></span><br><span class="line">     tools_description = <span class="string">&quot;\n&quot;</span>.join(</span><br><span class="line">         [tool.format_for_llm() <span class="keyword">for</span> tool <span class="keyword">in</span> all_tools]</span><br><span class="line">     )</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 这里就不简化了，以供参考，实际上就是基于 prompt 和当前所有工具的信息</span></span><br><span class="line">     <span class="comment"># 询问 LLM（Claude） 应该使用哪些工具。</span></span><br><span class="line">     system_message = (</span><br><span class="line">         <span class="string">&quot;You are a helpful assistant with access to these tools:\n\n&quot;</span></span><br><span class="line">         <span class="string">f&quot;<span class="subst">&#123;tools_description&#125;</span>\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span></span><br><span class="line">         <span class="string">&quot;If no tool is needed, reply directly.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span></span><br><span class="line">         <span class="string">&quot;the exact JSON object format below, nothing else:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">         <span class="string">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\n&#x27;</span></span><br><span class="line">         <span class="string">&#x27;    &quot;arguments&quot;: &#123;\n&#x27;</span></span><br><span class="line">         <span class="string">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\n&#x27;</span></span><br><span class="line">         <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;&#125;\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;After receiving a tool&#x27;s response:\n&quot;</span></span><br><span class="line">         <span class="string">&quot;1. Transform the raw data into a natural, conversational response\n&quot;</span></span><br><span class="line">         <span class="string">&quot;2. Keep responses concise but informative\n&quot;</span></span><br><span class="line">         <span class="string">&quot;3. Focus on the most relevant information\n&quot;</span></span><br><span class="line">         <span class="string">&quot;4. Use appropriate context from the user&#x27;s question\n&quot;</span></span><br><span class="line">         <span class="string">&quot;5. Avoid simply repeating the raw data\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Please use only the tools that are explicitly defined above.&quot;</span></span><br><span class="line">     )</span><br><span class="line">     messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_message&#125;]</span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="comment"># Final... 假设这里已经处理了用户消息输入.</span></span><br><span class="line">         messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 将 system_message 和用户消息输入一起发送给 LLM</span></span><br><span class="line">         llm_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line"> ​</span><br><span class="line">     ... <span class="comment"># 后面和确定使用哪些工具无关</span></span><br><span class="line">     </span><br><span class="line"> ​</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Represents a tool with its properties and formatting.&quot;&quot;&quot;</span></span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">         self, name: <span class="built_in">str</span>, description: <span class="built_in">str</span>, input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span></span><br><span class="line"><span class="params">     </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">         <span class="variable language_">self</span>.name: <span class="built_in">str</span> = name</span><br><span class="line">         <span class="variable language_">self</span>.description: <span class="built_in">str</span> = description</span><br><span class="line">         <span class="variable language_">self</span>.input_schema: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = input_schema</span><br><span class="line"> ​</span><br><span class="line">     <span class="comment"># 把工具的名字 / 工具的用途（description）和工具所需要的参数（args_desc）转化为文本</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">format_for_llm</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">         <span class="string">&quot;&quot;&quot;Format tool information for LLM.</span></span><br><span class="line"><span class="string"> ​</span></span><br><span class="line"><span class="string">         Returns:</span></span><br><span class="line"><span class="string">             A formatted string describing the tool.</span></span><br><span class="line"><span class="string">         &quot;&quot;&quot;</span></span><br><span class="line">         args_desc = []</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&quot;properties&quot;</span> <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema:</span><br><span class="line">             <span class="keyword">for</span> param_name, param_info <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema[<span class="string">&quot;properties&quot;</span>].items():</span><br><span class="line">                 arg_desc = (</span><br><span class="line">                     <span class="string">f&quot;- <span class="subst">&#123;param_name&#125;</span>: <span class="subst">&#123;param_info.get(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;No description&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line">                 )</span><br><span class="line">                 <span class="keyword">if</span> param_name <span class="keyword">in</span> <span class="variable language_">self</span>.input_schema.get(<span class="string">&quot;required&quot;</span>, []):</span><br><span class="line">                     arg_desc += <span class="string">&quot; (required)&quot;</span></span><br><span class="line">                 args_desc.append(arg_desc)</span><br><span class="line"> ​</span><br><span class="line">         <span class="keyword">return</span> <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> Tool: <span class="subst">&#123;self.name&#125;</span></span></span><br><span class="line"><span class="string"> Description: <span class="subst">&#123;self.description&#125;</span></span></span><br><span class="line"><span class="string"> Arguments:</span></span><br><span class="line"><span class="string"> <span class="subst">&#123;<span class="built_in">chr</span>(<span class="number">10</span>).join(args_desc)&#125;</span></span></span><br><span class="line"><span class="string"> &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>模型会通过 Prompt 来确定当前有哪些工具，通过将工具的具体使用描述以文本的形式传递给模型，供模型了解有哪些工具以及结合实时情况进行选择。</p>
<blockquote>
<p><strong>从所有 MCP Server 中“收集工具 → 转成给 LLM 看得懂的文字说明 → 拼到 system prompt 里 → 让 LLM 根据这些工具描述来决定要不要调用工具、调用哪个工具。</strong></p>
</blockquote>
<p>在整个 MCP 的大图景里，这段代码扮演的是<strong>中间协调者 &#x2F; 适配层</strong>：</p>
<ol>
<li>对下游（MCP Servers）</li>
</ol>
<ul>
<li><p>负责初始化所有 MCP Server</p>
</li>
<li><p>通过 list_tools() 探测每个 server 暴露的工具</p>
</li>
<li><p>把工具的 JSON Schema 等结构化信息，抽象成 Tool 对象</p>
</li>
</ul>
<ol start="2">
<li>对上游（LLM）</li>
</ol>
<ul>
<li><p>把所有工具信息整合并转成人类语言说明（format_for_llm）</p>
</li>
<li><p>把说明塞进 system prompt，告诉 LLM 它有哪些能力可以用</p>
</li>
<li><p>通过严格的 JSON 格式约束，让 LLM 以稳定可解析的方式返回“我要用哪个工具+参数”</p>
</li>
</ul>
<ol start="3">
<li>对中间逻辑（Router &#x2F; Orchestrator）</li>
</ol>
<ul>
<li><p>后续根据 LLM 的工具选择 JSON 再去调用相应 MCP server 的 tool</p>
</li>
<li><p>把结果反馈给 LLM，让它生成自然语言答复</p>
</li>
</ul>
<blockquote>
<p><strong>它让“多 MCP Server 的工具”对 LLM 看起来像一组统一、清晰、可选择的工具菜单。</strong></p>
</blockquote>
<h2 id="工具执行和结果反馈机制"><a href="#工具执行和结果反馈机制" class="headerlink" title="工具执行和结果反馈机制"></a>工具执行和结果反馈机制</h2><p>工具的执行就是把 system prompt 指令和工具调用描述，还有用户消息一起发送给模型，然后接收模型的回复。当模型分析用户请求后，它会决定是否需要调用工具。如果回复中包含结构化 json 格式的工具调用请求，则客户端会根据这个 json 代码执行对应的工具。</p>
<p>如果模型执行了 tool call，则工具执行的结果 result 会和 system prompt 和用户消息一起重新发送给模型，请求模型生成最终回复。同时，如果 tool call 的 json 代码存在问题或者模型产生了幻觉，那么系统会 skip 掉无效的调用请求。</p>
<p>工具执行的相关代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">     ... <span class="comment"># 上面已经介绍过了，模型如何选择工具</span></span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="comment"># 假设这里已经处理了用户消息输入.</span></span><br><span class="line">         messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 获取 LLM 的输出</span></span><br><span class="line">         llm_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 处理 LLM 的输出（如果有 tool call 则执行对应的工具）</span></span><br><span class="line">         result = <span class="keyword">await</span> <span class="variable language_">self</span>.process_llm_response(llm_response)</span><br><span class="line"> ​</span><br><span class="line">         <span class="comment"># 如果 result 与 llm_response 不同，说明执行了 tool call （有额外信息了）</span></span><br><span class="line">         <span class="comment"># 则将 tool call 的结果重新发送给 LLM 进行处理。</span></span><br><span class="line">         <span class="keyword">if</span> result != llm_response:</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: result&#125;)</span><br><span class="line"> ​</span><br><span class="line">             final_response = <span class="variable language_">self</span>.llm_client.get_response(messages)</span><br><span class="line">             logging.info(<span class="string">&quot;\nFinal response: %s&quot;</span>, final_response)</span><br><span class="line">             messages.append(</span><br><span class="line">                 &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: final_response&#125;</span><br><span class="line">             )</span><br><span class="line">         <span class="comment"># 否则代表没有执行 tool call，则直接将 LLM 的输出返回给用户。</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: llm_response&#125;) </span><br></pre></td></tr></table></figure>

<p>两个要点：</p>
<ol>
<li>工具对应的文档很重要： 模型通过工具描述文本来理解和选择工具，因此精心编写工具的名称、docstring 和参数说明至关重要；</li>
<li>由于 MCP 的选择是基于 prompt 的，所以任何模型其实都适配 MCP，只要能提供对应的工具描述。但是当你使用非 Claude 模型时，MCP 使用的效果和体验难以保证（没有做专门的训练，这个不太确定，后续需要测试一下）。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><strong>MCP 的本质</strong>：它是一个统一的协议标准，使 AI 模型能够以一致的方式连接各种数据源和工具，类似于 AI 世界的”USB-C”接口。</li>
<li><strong>MCP 的价值</strong>：它解决了传统 function call 的平台依赖问题，提供了更统一、开放、安全、灵活的工具调用机制，让用户和开发者都能从中受益。</li>
<li>使用与开发：对于普通用户，MCP 提供了丰富的现成工具，用户可以在不了解任何技术细节的情况下使用；对于开发者，MCP 提供了清晰的架构和 SDK，使工具开发变得相对简单。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>MCP(Model Context Protocol)一篇就够了：<a href="https://zhuanlan.zhihu.com/p/29001189476">https://zhuanlan.zhihu.com/p/29001189476</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>OSCP学习心得</title>
    <url>/2025/12/12/OSCP%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>在 OSCP 的学习和练习以及打靶场或者渗透测试过程中，我认为本质上不是掌握了多少工具，而是在规定时间内，能不能把渗透的全流程跑完，关键步骤上思维能否发散，能否有较为全面的思考和枚举，所以重心还是在思路上，渗透的思路和应对关键点时的经验，所以记录一些自己的思考。</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>重点在于覆盖面和可用性：</p>
<ul>
<li>覆盖面：全端口（服务）扫描，不要漏掉服务，不然可能会找不到正确的入口点；</li>
<li>可用性：不同服务、版本都有什么漏洞，是否具备利用条件，无法利用的话是不是加了什么限制，是需要绕过限制还是需要转变路径，这些属于能否实现利用的范畴；</li>
</ul>
<blockquote>
<p><strong>信息收集要得出一个结论：我到底能打哪些入口？哪些入口最可能实现边界突破？</strong></p>
</blockquote>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞利用阶段不要盲目跑exp，最好是先验证控制程度，再拿shell。</p>
<p>先确定漏洞是否真实存在，漏洞可控点在哪里，输入如何影响输出，然后再确认控制深度（能否读写文件&#x2F;命令执行&#x2F;鉴权绕过），最后在拿稳定shell。</p>
<blockquote>
<p><strong>先看能不能验证清楚，在考虑能否一步到位。</strong></p>
</blockquote>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>提权并没有深入学习太多，但是感觉应该在于找到“权限边界被破坏”的证据，可以根据历史经验寻找线索，找到稳定可复现的思路。</p>
<h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><blockquote>
<p><strong>信任关系+凭证流向</strong>: 从以控制主机把影响力扩到更有价值的主机&#x2F;账号&#x2F;网段等。</p>
</blockquote>
<hr>
<p>⭐<strong>持续更新 To be continued……</strong></p>
]]></content>
      <categories>
        <category>OSCP</category>
      </categories>
      <tags>
        <tag>OSCP</tag>
        <tag>Penetration Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda安装</title>
    <url>/2025/12/07/Miniconda%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Miniconda 是 Conda 的精简发行版，只包含最核心的包管理系统与 Python，可以快速搭建独立的 Python 环境。在进行数据分析、机器学习或科研开发时，相比于 Anaconda 更轻量、更灵活。</p>
<h2 id="一、Miniconda-安装"><a href="#一、Miniconda-安装" class="headerlink" title="一、Miniconda 安装"></a>一、Miniconda 安装</h2><p>Windows 命令行安装方式，可以快速且安静地下载最新的 64 位 Windows 安装程序，将其重命名为较短的文件名，执行静默安装，然后删除安装程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o .\miniconda.exe</span><br><span class="line">start /wait &quot;&quot; .\miniconda.exe /S</span><br><span class="line">del .\miniconda.exe</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>Windows Powershell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> <span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe&quot;</span> <span class="literal">-outfile</span> <span class="string">&quot;.\miniconda.exe&quot;</span></span><br><span class="line"><span class="built_in">Start-Process</span> <span class="literal">-FilePath</span> <span class="string">&quot;.\miniconda.exe&quot;</span> <span class="literal">-ArgumentList</span> <span class="string">&quot;/S&quot;</span> <span class="literal">-Wait</span></span><br><span class="line"><span class="built_in">del</span> .\miniconda.exe</span><br></pre></td></tr></table></figure>

<p>Linux 64位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="built_in">rm</span> ~/miniconda3/miniconda.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/miniconda3/bin/activate</span><br><span class="line"></span><br><span class="line">conda init --all</span><br></pre></td></tr></table></figure>

<h2 id="二、快速使用"><a href="#二、快速使用" class="headerlink" title="二、快速使用"></a>二、快速使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n environment python=3.12</span><br><span class="line"></span><br><span class="line">conda activate environment</span><br><span class="line"></span><br><span class="line">conda deactivate environment</span><br></pre></td></tr></table></figure>

<p>参考文献：<a href="https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt">https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu通过Ollama部署LLM</title>
    <url>/2025/12/18/Ubuntu%E9%80%9A%E8%BF%87Ollama%E9%83%A8%E7%BD%B2LLM/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Ubuntu 24.04<br>python 3.12.3<br>ollama 0.13.4<br>git 2.43.0</p>
<p>换源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/apt/sources.list.d/ubuntu.sources /etc/apt/sources.list.d/ubuntu.sources.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/apt/sources.list.d/ubuntu.sources</span><br><span class="line"></span><br><span class="line">Types: deb</span><br><span class="line">URIs: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-backports</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line">Types: deb</span><br><span class="line">URIs: https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="line">Suites: noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Ollama-安装"><a href="#Ollama-安装" class="headerlink" title="Ollama 安装"></a>Ollama 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"></span><br><span class="line">ollama --version</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl start ollama</span><br><span class="line"></span><br><span class="line">systemctl status ollama</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ollama</span><br></pre></td></tr></table></figure>

<h2 id="Ollama-命令一览表"><a href="#Ollama-命令一览表" class="headerlink" title="Ollama 命令一览表"></a>Ollama 命令一览表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能说明</th>
<th>常见使用场景 &#x2F; 示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>ollama serve</code></td>
<td>启动 Ollama 后台服务</td>
<td>作为 daemon 运行（一般系统已自动启动）<br><code>ollama serve</code></td>
</tr>
<tr>
<td><code>ollama create</code></td>
<td>创建自定义模型</td>
<td>基于 Modelfile 定制模型（prompt、参数、adapter）<br><code>ollama create mymodel -f Modelfile</code></td>
</tr>
<tr>
<td><code>ollama show</code></td>
<td>查看模型详细信息</td>
<td>查看模型结构、参数、上下文长度等<br><code>ollama show llama3</code></td>
</tr>
<tr>
<td><code>ollama run</code></td>
<td>运行模型（交互或单次）</td>
<td>最常用命令，拉取并运行模型<br><code>ollama run qwen2.5:7b</code></td>
</tr>
<tr>
<td><code>ollama stop</code></td>
<td>停止正在运行的模型</td>
<td>释放内存 &#x2F; CPU<br><code>ollama stop llama3</code></td>
</tr>
<tr>
<td><code>ollama pull</code></td>
<td>从仓库下载模型</td>
<td>只下载不运行<br><code>ollama pull deepseek-coder:6.7b</code></td>
</tr>
<tr>
<td><code>ollama push</code></td>
<td>推送模型到仓库</td>
<td>分享你自定义的模型（需登录）<br><code>ollama push username/mymodel</code></td>
</tr>
<tr>
<td><code>ollama signin</code></td>
<td>登录 ollama.com</td>
<td>用于 push &#x2F; 私有模型<br><code>ollama signin</code></td>
</tr>
<tr>
<td><code>ollama signout</code></td>
<td>登出 ollama.com</td>
<td>退出当前账号<br><code>ollama signout</code></td>
</tr>
<tr>
<td><code>ollama list</code></td>
<td>列出本地已有模型</td>
<td>查看你已下载的模型<br><code>ollama list</code></td>
</tr>
<tr>
<td><code>ollama ps</code></td>
<td>查看正在运行的模型</td>
<td>类似 <code>docker ps</code><br><code>ollama ps</code></td>
</tr>
<tr>
<td><code>ollama cp</code></td>
<td>复制模型</td>
<td>基于现有模型创建新模型<br><code>ollama cp llama3 my-llama3</code></td>
</tr>
<tr>
<td><code>ollama rm</code></td>
<td>删除本地模型</td>
<td>释放磁盘空间<br><code>ollama rm mistral</code></td>
</tr>
<tr>
<td><code>ollama help</code></td>
<td>查看帮助</td>
<td>查看全局或子命令帮助<br><code>ollama help run</code></td>
</tr>
</tbody></table>
<h2 id="Ollama-模型支持"><a href="#Ollama-模型支持" class="headerlink" title="Ollama 模型支持"></a>Ollama 模型支持</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地模型列表</span></span><br><span class="line">ollama list</span><br></pre></td></tr></table></figure>

<p>查看 ollama 中能下载哪些模型：<a href="https://ollama.com/library">https://ollama.com/library</a></p>
<p>开源模型按照综合排序简单列出 10 个</p>
<table>
<thead>
<tr>
<th><strong>Model</strong></th>
<th><strong>description</strong></th>
<th><strong>Tags</strong></th>
<th><strong>Update</strong></th>
</tr>
</thead>
<tbody><tr>
<td>deepseek-r1</td>
<td>DeepSeek-R1 是一系列开放式推理模型，其性能接近领先的模型，例如 O3 和 Gemini 2.5 Pro</td>
<td><code>tools</code> <code>thinking</code> <code>70b</code> <code>671b</code></td>
<td>2025-7</td>
</tr>
<tr>
<td>deepseek-v3.2</td>
<td>DeepSeek-V3.2 是一款兼具高计算效率、卓越推理能力和智能体性能的模型</td>
<td><code>cloud</code></td>
<td>2025-12</td>
</tr>
<tr>
<td>deepseek-coder</td>
<td>DeepSeek Coder 是一个功能强大的编码模型，它经过两万亿个代码和自然语言标记的训练</td>
<td><code>6.7b``33b</code></td>
<td>2024-12</td>
</tr>
<tr>
<td>gemini-3-flash-preview</td>
<td>Gemini 3 Flash 以极低的成本提供专为速度而打造的前沿智能</td>
<td><code>tools</code> <code>thinking</code> <code>cloud</code></td>
<td>2025-12</td>
</tr>
<tr>
<td>gemini-3-pro-preview</td>
<td>谷歌最智能的模型，具备最先进的推理和多模态理解能力，以及强大的智能体和氛围编码能力</td>
<td><code>tools</code> <code>thinking</code> <code>cloud</code></td>
<td>2025-11</td>
</tr>
<tr>
<td>qwen3-coder</td>
<td>阿里巴巴针对智能体和编码任务的高性能长上下文模型</td>
<td><code>tools</code> <code>cloud</code> <code>30b</code> <code>480b</code></td>
<td>2025-10</td>
</tr>
<tr>
<td>qwen3</td>
<td>Qwen3 是 Qwen 系列中最新一代的大型语言模型，提供了一套全面的密集型和混合专家 (MoE) 模型</td>
<td><code>tools</code> <code>thinking</code> <code>32b</code> <code>235b</code></td>
<td>2025-12</td>
</tr>
<tr>
<td>codellama</td>
<td>一个大型语言模型，可以使用文本提示来生成和讨论代码</td>
<td><code>34b</code> <code>70b</code></td>
<td>2023-8</td>
</tr>
<tr>
<td>llama3.1</td>
<td>Llama 3.1 是 Meta 推出的一款全新尖端模型，提供 8B、70B 和 405B 参数大小</td>
<td><code>tools</code> <code>8b</code> <code>70b</code> <code>405b</code></td>
<td>2024-7</td>
</tr>
<tr>
<td>gpt-oss</td>
<td>OpenAI 的开放权重模型专为强大的推理能力、智能体任务和多样化的开发者用例而设计</td>
<td><code>tools</code> <code>thinking</code> <code>cloud</code> <code>20b</code> <code>120b</code></td>
<td>2025-10</td>
</tr>
</tbody></table>
<h2 id="模型下载部署"><a href="#模型下载部署" class="headerlink" title="模型下载部署"></a>模型下载部署</h2><p>以 deepseek-r1:latest 为例，记录部署流程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载模型</span></span><br><span class="line">ollama pull deepseek-r1:latest</span><br><span class="line"></span><br><span class="line">ollama run deepseek-r1:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Web 用户界面中运行 DeepSeek</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line"><span class="built_in">sudo</span> apt install python3-venv</span><br><span class="line">python3 -m venv ~/open-webui-venv</span><br><span class="line"><span class="built_in">source</span> ~/open-webui-venv/bin/activate</span><br><span class="line"></span><br><span class="line">pip install open-webui -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">open-webui serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 http://localhost:8080</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl status open-webui</span><br></pre></td></tr></table></figure>

<p>注意在初次启动时，我们本地只有“大脑”（DeepSeek），Open WebUI 还会试图下载一个“图书管理员”（Embedding 模型）。虽然已经成功部署了 DeepSeek，但 Open WebUI 是一个功能完整的界面系统，它默认开启了<strong>RAG（检索增强生成）</strong>功能（即知识库&#x2F;文档上传功能）。</p>
<p>所以默认还会下载一个 all-MiniLM-L6-v2 模型，它不负责对话。它的唯一作用是将你上传的文档、文字转换成计算机能理解的“向量（数字列表）”。当你问 DeepSeek 关于你上传文档的问题时，Open WebUI 先用这个小模型去搜索文档中的相关段落，然后把段落喂给 DeepSeek。它是“图书管理员”。</p>
<p>如果他发现本地没有默认的 Embedding 模型（all-MiniLM-L6-v2），就会自动去 Hugging Face 下载。也就是说会卡在这里，需要配置国内的镜像源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HF_ENDPOINT=https://hf-mirror.com</span><br></pre></td></tr></table></figure>

<p>成功运行如下图所示：</p>
<p><img src="/../uploads/ollama_1.png"></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（三）</title>
    <url>/2025/12/12/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-Server-开发实践"><a href="#MCP-Server-开发实践" class="headerlink" title="MCP Server 开发实践"></a>MCP Server 开发实践</h2><p>对于大部分 AI 开发者来说，MCP 只需要关心 Server 的实现，通过一个简单示例学习如何实现一个 MCP Server。</p>
<p>MCP Server 可以提供三种主要类型的功能：</p>
<ul>
<li>Resources（资源）：类似文件的数据，可以被客户端读取；</li>
<li>Tools（工具）：可以被LLM调用的函数；</li>
<li>Prompt（提示）：预先编写的模版，帮助用户完成特定任务；</li>
</ul>
<p>任务：使用Python实现一个MCP Server，用来统计当前桌面上的 txt 文件数量和获取对应文件的名字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MCP Server</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;桌面 TXT 文件统计器&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_desktop_txt_files</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Count the number of .txt files on the desktop.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Get the desktop path</span></span><br><span class="line">    username = os.getenv(<span class="string">&quot;USER&quot;</span>) <span class="keyword">or</span> os.getenv(<span class="string">&quot;USERNAME&quot;</span>)</span><br><span class="line">    desktop_path = Path(<span class="string">f&quot;C:\\Users\\<span class="subst">&#123;username&#125;</span>\\Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Count .txt files</span></span><br><span class="line">    txt_files = <span class="built_in">list</span>(desktop_path.glob(<span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(txt_files)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_desktop_txt_files</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get a list of all .txt filenames on the desktop.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Get the desktop path</span></span><br><span class="line">    username = os.getenv(<span class="string">&quot;USER&quot;</span>) <span class="keyword">or</span> os.getenv(<span class="string">&quot;USERNAME&quot;</span>)</span><br><span class="line">    desktop_path = Path(<span class="string">f&quot;C:\\Users\\<span class="subst">&#123;username&#125;</span>\\Desktop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get all .txt files</span></span><br><span class="line">    txt_files = <span class="built_in">list</span>(desktop_path.glob(<span class="string">&quot;*.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the filenames</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> txt_files:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No .txt files found on desktop.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Format the list of filenames</span></span><br><span class="line">    file_list = <span class="string">&quot;\n&quot;</span>.join([<span class="string">f&quot;- <span class="subst">&#123;file.name&#125;</span>&quot;</span> <span class="keyword">for</span> file <span class="keyword">in</span> txt_files])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(txt_files)&#125;</span> .txt files on desktop:\n<span class="subst">&#123;file_list&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Initialize and run the server</span></span><br><span class="line">    mcp.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MCP-Server-测试"><a href="#MCP-Server-测试" class="headerlink" title="MCP Server 测试"></a>MCP Server 测试</h3><p>测试 MCP Server， <code>mcp dev server.py</code> ，进行服务测试。</p>
<p><img src="/../uploads/MCP_12.png"></p>
<p>如图所示，成功生成了对应的 Tool Result ，即为测试成功。</p>
<h3 id="接入-Claude-Desktop"><a href="#接入-Claude-Desktop" class="headerlink" title="接入 Claude Desktop"></a>接入 Claude Desktop</h3><p>这里 Claude Desktop 注册时需要手机号绑定，目前没有外国手机号，所以找了个平替的平台 Trae。</p>
<p>配置文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server_txt&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Users\\77319\\.local\\bin\\uv.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--directory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;D:\\Code\\mcp-demo&quot;</span><span class="punctuation">,</span> <span class="comment">// 你的项目路径（这里是我的）</span></span><br><span class="line">        <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;server_txt.py&quot;</span> <span class="comment">// 你的 MCP Server 文件名</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>手动添加 MCP 配置：</p>
<p><img src="/../uploads/MCP_13.png"></p>
<p>选择 MCP ：</p>
<p><img src="/../uploads/MCP_14.png"></p>
<p>提出问题：帮我分析桌面txt文件的含义</p>
<p>思考过程：</p>
<p>用户让我推测桌面txt文件名的含义，之前已经通过MCP工具获取到桌面上有3个txt文件：</p>
<ul>
<li>3.多模态信息融合.txt</li>
<li>API Key.txt</li>
<li>密码本.txt<br>我需要基于文件名来推测它们的含义，不需要查看文件内容。让我分析每个文件名：</li>
</ul>
<ol>
<li><p>“3.多模态信息融合.txt”：</p>
<ul>
<li>“3.” 可能表示这是一系列文件中的第3个</li>
<li>“多模态信息融合” 是一个专业术语，通常指将不同类型的数据（如文本、图像、音频等）结合起来进行分析和处理</li>
<li>这个文件可能包含关于多模态信息融合技术的笔记、研究或资料</li>
</ul>
</li>
<li><p>“API Key.txt”：</p>
<ul>
<li>“API Key” 是应用程序接口密钥的缩写，用于身份验证和授权</li>
<li>这个文件可能包含各种服务或平台的API密钥</li>
</ul>
</li>
<li><p>“密码本.txt”：</p>
<ul>
<li>“密码本” 通常指存储密码的文档</li>
<li>这个文件可能包含各种账户的用户名和密码信息</li>
</ul>
</li>
</ol>
<p>我需要将这些分析整理成一个清晰的回应。</p>
<p>回复内容：</p>
<p>基于之前获取的桌面上的txt文件名，我可以推测它们的含义。让我分析每个文件名并提供合理的解释。基于桌面txt文件名，我可以做出以下推测：</p>
<ol>
<li><p><strong>3.多模态信息融合.txt</strong></p>
<ul>
<li>“3.” 可能表示这是一系列相关文件中的第3个</li>
<li>“多模态信息融合” 是人工智能领域的专业术语，指将不同类型的数据（如文本、图像、音频、视频等）结合起来进行分析和处理的技术</li>
<li>这个文件很可能包含关于多模态信息融合技术的研究资料、学习笔记或项目文档</li>
</ul>
</li>
<li><p><strong>API Key.txt</strong></p>
<ul>
<li>“API Key”（应用程序接口密钥）是用于身份验证和授权的安全凭证</li>
<li>这个文件可能存储了各种在线服务、开发平台或应用程序的API密钥，方便用户在开发或使用相关服务时快速获取</li>
</ul>
</li>
<li><p><strong>密码本.txt</strong></p>
<ul>
<li>“密码本” 是一个常见的术语，指专门用于记录密码的文档</li>
<li>这个文件很可能包含了用户在各种网站、应用程序或服务上的账户名称和对应的密码信息，用于集中管理和记忆</li>
</ul>
</li>
</ol>
<p>这些文件都与数字信息管理和技术相关，可能是用户在学习、工作或日常使用计算机时创建的重要参考文档。</p>
<p>上述结果表明 MCP Server 已经可以正常工作。</p>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulnhalla QuickStart</title>
    <url>/2025/12/16/Vulnhalla-QuickStart/</url>
    <content><![CDATA[<h2 id="Vulnhalla"><a href="#Vulnhalla" class="headerlink" title="Vulnhalla"></a>Vulnhalla</h2><p>Vulnhalla 可以自动化执行完整的安全分析流程 (<a href="https://github.com/cyberark/Vulnhalla">https://github.com/cyberark/Vulnhalla</a>)</p>
<ol>
<li>从 GitHub 获取指定编程语言的代码库</li>
<li>下载其对应的 CodeQL 数据库（如果可用）</li>
<li>在数据库上运行 CodeQL 查询以检测安全或代码质量问题</li>
<li>使用 LLM（ChatGPT、Gemini 等）对结果进行后续处理，以分类和过滤问题</li>
</ol>
<p>项目提供了直接从 Github fetch repositories 的能力，但是需要本地配置 GitHub API token，为了简化实验流程，就直接把要分析的 Program git clone 到本地，然后本地生成 CodeQL Database 再进行后续的结果处理，<strong>这个 Project 的重点就是在于结果处理</strong>。</p>
<h2 id="🚀-QuickStart"><a href="#🚀-QuickStart" class="headerlink" title="🚀 QuickStart"></a>🚀 QuickStart</h2><p>环境要求：</p>
<ul>
<li>python 3.11</li>
<li>CodeQL CLI</li>
<li>LLM API Key</li>
</ul>
<p>虚拟环境配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n vulnhalla python=3.11</span><br><span class="line"></span><br><span class="line">conda activate vulnhalla</span><br><span class="line"></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>miniconda 下载可参考这篇文章：<a href="/2025/12/07/Miniconda%E5%AE%89%E8%A3%85/" title="Miniconda安装">Miniconda安装</a>。</p>
<p>配置文件修改 project 中以 OpenAI gpt-4o为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODEQL_PATH=codeql</span><br><span class="line">GITHUB_TOKEN=ghp_your_token_here</span><br><span class="line">PROVIDER=openai</span><br><span class="line">MODEL=gpt-4o</span><br><span class="line">OPENAI_API_KEY=your-api-key-here</span><br><span class="line">LLM_TEMPERATURE=0.2</span><br><span class="line">LLM_TOP_P=0.2</span><br><span class="line"></span><br><span class="line"># Optional: Logging Configuration</span><br><span class="line">LOG_LEVEL=INFO                  # DEBUG, INFO, WARNING, ERROR</span><br><span class="line">LOG_FILE=                       # Optional: path to log file (e.g., logs/vulnhalla.log)</span><br><span class="line">LOG_FORMAT=default              # default or json</span><br><span class="line"># LOG_VERBOSE_CONSOLE=false     # If true, WARNING/ERROR use full format (timestamp - logger - level - message)</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>CODEQL_PATH：指定 CodeQL 可执行文件的路径或命令名，用于运行代码安全分析（如漏洞扫描）。如果已加入系统 PATH，直接写 codeql 即可；</li>
<li>GITHUB_TOKEN：GitHub 访问令牌，用于访问私有仓库、拉取代码、调用 GitHub API（如获取 PR、Issue、仓库信息等）；</li>
<li>PROVIDER&#x2F;MODEL&#x2F;OPENAI_API_KEY：大模型相关配置，可替换为对应厂商；</li>
<li>LLM_TEMPERATURE：控制模型输出的随机性，值越低输出越稳定、保守，适合分析、审计、代码检查等场景；</li>
<li>LLM_TOP_P：控制采样范围（nucleus sampling），限制模型在高概率词汇中选择，进一步提升结果一致性和可控性；</li>
<li>LOG_LEVEL&#x3D;INFO：日志级别，控制输出信息的详细程度，DEBUG是最详细的；</li>
<li>LOG_FILE：日志文件输出路径，留空表示仅输出到控制台；</li>
<li>LOG_FORMAT&#x2F;LOG_VERBOSE_CONSOLE：日志格式和日志记录格式；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> .env.example .<span class="built_in">env</span></span><br><span class="line"></span><br><span class="line">python setup.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化CodeQL套件</span></span><br><span class="line"><span class="built_in">cd</span> data/queries/cpp/tools</span><br><span class="line">codeql pack install</span><br><span class="line"><span class="built_in">cd</span> ../issues</span><br><span class="line">codeql pack install</span><br><span class="line"><span class="built_in">cd</span> ../../../..</span><br></pre></td></tr></table></figure>

<p>使用单个命令运行完整的 pipeline：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Analyze a specific repository</span></span><br><span class="line">python src/pipeline.py redis/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Analyze top 100 repositories</span></span><br><span class="line">python src/pipeline.py</span><br></pre></td></tr></table></figure>

<p>这个 pipeline 会自动执行：获取CodeQL数据库，在所有下载的数据库上运行 CodeQL 查询，使用 LLM 分析结果并保存到 output&#x2F;results&#x2F;，打开 UI 浏览结果。</p>
<p>Project 还提供了一个示例脚本，运行一个端到端示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python examples/example.py</span><br></pre></td></tr></table></figure>

<p>这个 example 会获取 videolan&#x2F;vlc 和 redis&#x2F;redis 的 CodeQL 数据库，在所有下载的数据库上运行 CodeQL 查询，使用 LLM 分析结果并保存到 output&#x2F;results&#x2F;。</p>
<p>Vulnhalla 包含一个功能齐全的用户界面，用于浏览和探索分析结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python src/ui/ui_app.py</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">python examples/ui_example.py</span><br></pre></td></tr></table></figure>

<p>至此，Vulnhalla 环境配置完成，可运行一个完整 pipeline。</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>LLM</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>SARIF文件架构解读</title>
    <url>/2025/12/10/SARIF%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="SARIF-文件架构架构解读"><a href="#SARIF-文件架构架构解读" class="headerlink" title="SARIF 文件架构架构解读"></a>SARIF 文件架构架构解读</h2><p>SARIF（Static Analysis Results Interchange Format）本质是一个 JSON 日志规范，用于统一表达静态分析（SAST、Lint、CodeQL、依赖扫描等）的扫描结果，方便不同工具之间共享、聚合、展示与追踪。</p>
<p>SARIF 简单文件结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;https://json.schemastore.org/sarif-2.1.0.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runs&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;tool&#x27;<span class="punctuation">,</span> &#x27;invocations&#x27;<span class="punctuation">,</span> &#x27;artifacts&#x27;<span class="punctuation">,</span> &#x27;results&#x27;<span class="punctuation">,</span> &#x27;columnKind&#x27;<span class="punctuation">,</span>&#x27;properties&#x27;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SARIF &#x3D; 多次运行 runs 的集合，每次运行包含：工具信息 + 运行元数据 + 被分析对象（artifacts）+ 分析结果（results）</p>
</blockquote>
<p>对各部分内容介绍如下：</p>
<ol>
<li>tool 工具信息：检查员身份信息和检查手册，记录了用哪个工具进行了扫描，版本号是多少，包含了 driver 驱动程序信息 和 rules 检查规则清单；</li>
<li>invocations 调用信息：检查员的工作日志，记录了这次检查是在什么环境下进行的，以及是否顺利完成，executionSuccessful: true&#x2F;false；</li>
<li>artifacts 被扫描的文件：检查了哪些地点，列出了所有被 CodeQL 扫描过的源文件（Source Code），包含文件的路径（location），有时也包含文件的具体内容或哈希值，方便后续定位；</li>
<li><strong>results 结果</strong> ：这是问题清单，这是整份报告里最重要的部分，列出了扫描出来的所有 Bug和漏洞信息，关键单：ruleId 记录违反了哪条规则（对应 tool 里的规则），message 记录问题的具体描述，locations 记录了问题在哪个文件的第几行、第几列；</li>
<li>columnKind 列的计算方式：用于告诉 IDE（如 VS Code）如何正确高亮代码；</li>
<li>properties 附加属性：记录了杂项信息，存放标准字段里放不下的、或者工具特有的自定义数据，可能会包含构建时的标签（Build Tags）、项目的元数据（Project Metadata）和一些给特定显示面板用的统计数据；</li>
</ol>
<p>通俗的讲，就是这一次扫描 (run)，是由名为 CodeQL 的 (tool) 进行的。它在一个特定的时间以特定的参数运行 (invocations)，按照特定的刻度标准 (columnKind)，扫描了这一堆文件 (artifacts)，最后发现了这些漏洞 (results)，并在最后贴了一些标签 (properties)。</p>
<span id="more"></span>

<h2 id="关键信息提取"><a href="#关键信息提取" class="headerlink" title="关键信息提取"></a>关键信息提取</h2><p>要在 CodeQL 生成的 SARIF 报告中提取<strong>漏洞点（Sink）</strong>、<strong>漏洞位置</strong>、<strong>数据流（Source 到 Sink）以及控制流</strong>信息，需要研究 <code>runs</code> -&gt; <code>results</code> 数组中的对象。</p>
<p>SARIF 将这些复杂的逻辑封装在了一个层级分明的结构中。以下是提取这些关键信息所对应的具体字段和解析逻辑：</p>
<hr>
<h3 id="提取核心模块：results-数组"><a href="#提取核心模块：results-数组" class="headerlink" title="提取核心模块：results 数组"></a>提取核心模块：<code>results</code> 数组</h3><p>所有的漏洞信息都在 <code>runs[0].results</code> 列表里，需要遍历这个列表，列表中的每一个对象代表一个具体的漏洞实例。</p>
<h3 id="详细提取指南"><a href="#详细提取指南" class="headerlink" title="详细提取指南"></a>详细提取指南</h3><p>需要关注 <code>results</code> 对象下的以下字段：</p>
<h4 id="A-漏洞的基本信息"><a href="#A-漏洞的基本信息" class="headerlink" title="A. 漏洞的基本信息"></a>A. 漏洞的基本信息</h4><ul>
<li><strong>漏洞名称&#x2F;类型</strong>：<code>ruleId</code><ul>
<li>例如：<code>java/sql-injection</code></li>
</ul>
</li>
<li><strong>漏洞简要描述</strong>：<code>message.text</code><ul>
<li>例如：”This query depends on a user-provided value.”</li>
</ul>
</li>
</ul>
<h4 id="B-漏洞位置-爆发点-Sink"><a href="#B-漏洞位置-爆发点-Sink" class="headerlink" title="B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink"></a>B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink</h4><p>这是 CodeQL 认为漏洞最终发生的地方（例如执行 SQL 查询的那一行）。</p>
<ul>
<li><strong>提取字段</strong>：<code>locations</code> 数组</li>
<li><strong>关键逻辑</strong>：通常取 <code>locations[0]</code>（数组的第一个元素）作为主要位置。</li>
<li><strong>具体内容</strong>：<ul>
<li><strong>文件路径</strong>：<code>locations[0].physicalLocation.artifactLocation.uri</code></li>
<li><strong>起始行号</strong>：<code>locations[0].physicalLocation.region.startLine</code></li>
<li><strong>代码片段</strong>（如果有）：<code>locations[0].physicalLocation.region.snippet.text</code></li>
</ul>
</li>
</ul>
<h4 id="C-数据流与控制流"><a href="#C-数据流与控制流" class="headerlink" title="C. 数据流与控制流"></a>C. 数据流与控制流</h4><p>这是最复杂也是最有价值的部分，描述了污点数据（Taint Data）是如何从<strong>输入源（Source）</strong>一步步流向<strong>爆发点（Sink）</strong>的。</p>
<p>CodeQL 将数据流和控制流统一放在 <code>codeFlows</code> 字段中。</p>
<ul>
<li><strong>提取字段</strong>：<code>codeFlows</code> 数组</li>
<li><strong>结构逻辑</strong>：<ol>
<li><code>codeFlows</code> 下通常包含一个或多个 <code>threadFlows</code>（CodeQL 通常只给出一个最具代表性的路径）。</li>
<li><code>threadFlows</code> 下是一个 <code>locations</code> 列表，这是一个<strong>有序数组</strong>，代表了代码执行的步骤。</li>
</ol>
</li>
</ul>
<p><strong>如何解析这个路径链条：</strong></p>
<ul>
<li><strong>Source（污点源头&#x2F;用户输入）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>第一个元素</strong>。</li>
<li>提取：<code>...locations[0].location.physicalLocation</code> (文件和行号)</li>
<li>含义：例如 <code>request.getParameter(&quot;id&quot;)</code>，这是数据进入系统的位置。</li>
</ul>
</li>
<li><strong>Flow Path（传播路径&#x2F;控制流）</strong>：<ul>
<li>是 <code>threadFlows[0].locations</code> 数组的<strong>中间元素</strong>。</li>
<li>这些步骤展示了数据经过了哪些函数调用、赋值操作或判断逻辑。</li>
<li><strong>关键提取</strong>：<code>location.message.text</code> —— 这里通常会说明“数据被传递给参数 x”或“数据通过函数返回值传播”。</li>
</ul>
</li>
<li><strong>Sink（爆发点&#x2F;最终位置）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>最后一个元素</strong>。</li>
<li>这应该与上面提到的 <strong>B. 漏洞位置</strong> 重合。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：需要提取的-JSON-路径映射表"><a href="#总结：需要提取的-JSON-路径映射表" class="headerlink" title="总结：需要提取的 JSON 路径映射表"></a>总结：需要提取的 JSON 路径映射表</h3><p>为了方便编写脚本（如 Python）提取，这是一个速查表：</p>
<table>
<thead>
<tr>
<th align="left">信息类型</th>
<th align="left">SARIF JSON 路径 (假设当前在 results[i] 对象下)</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>漏洞类型</strong></td>
<td align="left"><code>ruleId</code></td>
<td align="left">漏洞的 ID，如 SQL 注入</td>
</tr>
<tr>
<td align="left"><strong>漏洞描述</strong></td>
<td align="left"><code>message.text</code></td>
<td align="left">人类可读的解释</td>
</tr>
<tr>
<td align="left"><strong>漏洞文件</strong></td>
<td align="left"><code>locations[0].physicalLocation.artifactLocation.uri</code></td>
<td align="left">发生漏洞的文件名</td>
</tr>
<tr>
<td align="left"><strong>漏洞行号</strong></td>
<td align="left"><code>locations[0].physicalLocation.region.startLine</code></td>
<td align="left">发生漏洞的行号</td>
</tr>
<tr>
<td align="left"><strong>数据流路径</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations</code></td>
<td align="left">这是一个列表，包含完整路径</td>
</tr>
<tr>
<td align="left"><strong>数据源 (Source)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[0]</code></td>
<td align="left">路径的第一步</td>
</tr>
<tr>
<td align="left"><strong>传播过程</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[1:-1]</code></td>
<td align="left">路径的中间步骤</td>
</tr>
<tr>
<td align="left"><strong>爆发点 (Sink)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[-1]</code></td>
<td align="left">路径的最后一步</td>
</tr>
</tbody></table>
<h3 id="4-举例说明"><a href="#4-举例说明" class="headerlink" title="4. 举例说明"></a>4. 举例说明</h3><p>假设这是一个 SQL 注入的 <code>result</code> 片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ruleId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java/sql-injection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Query depends on user input.&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// ---&gt; 这里是 B: 漏洞最终爆发的位置 (Sink)</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;artifactLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;codeFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// ---&gt; 这里是 C: 完整的数据流/控制流路径</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;threadFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="comment">// 步骤 1: Source (数据源)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Controller.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">15</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User input source...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 2: 中间传播</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Service.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data passed to function...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 3: Sink (通常与 locations[0] 一致)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data used in SQL query...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><strong>判空处理</strong>：不是所有的 <code>results</code> 都有 <code>codeFlows</code>。简单的代码质量检查（比如“变量未使用”）通常只有 <code>locations</code>，没有数据流路径。只有安全类漏洞（如注入、XSS）通常会有 <code>codeFlows</code>。</li>
<li><strong>路径简繁</strong>：CodeQL 生成的 <code>codeFlows</code> 有时非常详细，如果只关注关键跳板，关注 <code>location.message</code> 比较有帮助。</li>
<li><strong>关联位置</strong>：有时还会看到 <code>relatedLocations</code> 字段，这通常用于辅助说明（例如：指出变量定义的位置），如果不需要极高精度，可以暂时忽略。</li>
</ol>
]]></content>
      <categories>
        <category>CodeQL</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>SAST</tag>
        <tag>SARIF</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulnhalla文章阅读</title>
    <url>/2025/12/18/Vulnhalla%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="Vulnhalla-Picking-the-true-vulnerabilities-from-the-CodeQL-haystack"><a href="#Vulnhalla-Picking-the-true-vulnerabilities-from-the-CodeQL-haystack" class="headerlink" title="Vulnhalla: Picking the true vulnerabilities from the CodeQL haystack"></a>Vulnhalla: Picking the true vulnerabilities from the CodeQL haystack</h2><p>从 CodeQL 海量结果中找到真正的漏洞。</p>
<p>这篇文章主要介绍了一种结合 LLM 推理和静态分析来发现漏洞的方法。通过在 CodeQL 之上叠加 LLM，可以显著减少困扰安全团队的大量误报。最终，开发人员和安全研究人员能够专注于真正具有潜在利用价值的漏洞，从而优化工作流程。</p>
<h2 id="使用-LLM-进行漏洞挖掘目前的挑战"><a href="#使用-LLM-进行漏洞挖掘目前的挑战" class="headerlink" title="使用 LLM 进行漏洞挖掘目前的挑战"></a>使用 LLM 进行漏洞挖掘目前的挑战</h2><p>过去，使用大型语言模型（LLM）进行漏洞检测的主要挑战在于大型代码库的上下文窗口有限。然而，如今这种情况正在改变；一些模型现在可以处理多达一百万个 token 。</p>
<p>就如今的 <strong>大模型漏洞挖掘</strong>而言，主要问题可以归结为两个：</p>
<ul>
<li>WHERE</li>
<li>WHAT</li>
</ul>
<p>WHERE 问题在于 LLM 无法确定代码的哪一部分值得关注。在大型代码库中，可能的关注点数量庞大，这意味着模型很容易分心，把注意力放在错误的地方。</p>
<p>问题在于，即使模型检查到了正确的位置，它仍然需要猜测应该查找哪种类型的错误，例如内存问题、竞态条件或 API 误用。如果没有指导，它可能会完全选择错误的类别，从而无法检测到真正的错误。</p>
<p>Google 和 OpenAI 采取了不同的解决方案。Google 的 Deep Sleep 试图通过分析与已知 CVE 关联的代码更改（例如 git diff 或提交补丁）来解决这些问题，并验证修复程序或附近的代码是否包含类似的问题。OpenAI 采取了不同的策略 ，专注于新的代码提交。他们声称大约 1.2% 的提交引入了已知的安全问题，他们的目标是识别并解决这些问题。这有助于通过将关注点缩小到潜在危险的提交来解决“查找位置”问题，但它并没有完全解决“查找内容”问题，因为该模型仍然需要决定在每种情况下要查找哪种类型的错误。</p>
<span id="more"></span>

<h2 id="SAST-with-LLM"><a href="#SAST-with-LLM" class="headerlink" title="SAST with LLM"></a>SAST with LLM</h2><p>本文提出了一种可以解决 WHERE 和 WHAT 的方法：<strong>把静态分析工具和 LLM 结合。</strong></p>
<p>静态分析是指在不执行源代码的情况下，静态地解析源代码以识别安全漏洞的过程。它通过提取变量、结构体和代码关系来实现这一点。这些提取结果会被保存到数据库中，并构建代码流图和数据流图。然后，可以根据预定义的规则或查询来检查这些图。</p>
<p>例如，某条规则可能会标记任何源大小未被目标大小正确限定的 memcpy 调用，这种情况可能导致内存损坏不安全的数据流以及其他关键问题。</p>
<p>CodeQL 分析基于查询，这些查询分为稳定集和实验集。稳定集的误报率较低。</p>
<p>但是 CodeQL存在一个问题，就是<strong>结果数量过多</strong>，潜在的安全漏洞数量过多，导致专家无法进行手动复查，并且忽略这些警报可能会在代码库中留下真正的漏洞，等待耐心的攻击者去发现。</p>
<p><strong>假阳性</strong>是指：</p>
<blockquote>
<p>检测结果显示为“阳性”，但实际上被检测对象并不具备该情况或疾病。说白了就是 “测出来有，但是实际上没有” 。</p>
</blockquote>
<p>关于静态分析工具的研究表明，其中大约 80% 的检测结果是误报，只有 20% 的结果能够得到有效解决。</p>
<p>静态分析虽然稳健，但信噪比可能非常低。正因如此， <strong>单独使用静态分析在大规模应用中会面临挑战 ，所以和 LLM 的结合显得必要。</strong></p>
<h3 id="关键流程"><a href="#关键流程" class="headerlink" title="关键流程"></a>关键流程</h3><p>安全研究人员获取源代码，生成一个 CodeQL 数据库，对数据库运行 CodeQL 查询，然后将结果中的每个警报传递给 LLM，以确定每个警报是真正的问题还是误报。</p>
<p><img src="/../uploads/paper_vuln_1.png"></p>
<h3 id="关键上下文信息提取"><a href="#关键上下文信息提取" class="headerlink" title="关键上下文信息提取"></a>关键上下文信息提取</h3><p>CodeQL 会产出一个漏洞警告，但是也仅仅是一条信息，仅有这个漏洞告警信息是远远不够的，还需要结合源代码来进行深入分析判断，但是要发送多少源代码给 LLM 才能让 LLM 进行精准判断，这是一个要思考的问题，发送内容过多会使 LLM 注意力分散，降低识别到准确漏洞的概率；发送内容过少，会缺少关键信息导致 LLM 误判，文章对这个关键点进行了讨论分析。</p>
<p>为 chatgpt 定制 Custom Instructions 如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">You are a security static-analysis assistant.</span><br><span class="line">You are given:</span><br><span class="line">- Metadata about a CodeQL alert.</span><br><span class="line">- A snippet of C source code that may contain the reported problem.</span><br><span class="line">Your job:</span><br><span class="line">- Decide whether the alert is likely a real bug, given ONLY the code shown.</span><br><span class="line">- Respond VERY BRIEFLY (at most 2 sentences).</span><br><span class="line">Rules:</span><br><span class="line">- If you can determine it IS a real bug, start with: &quot;Bug:&quot; and give a short reason.</span><br><span class="line">- If you can determine it is NOT a real bug, start with: &quot;Not a bug:&quot; and give a short reason.</span><br><span class="line">- If you CANNOT TELL from the snippet and you need more code, start with: &quot;Unknown:&quot; and state EXACTLY what additional code or context you would need.</span><br><span class="line">Do not speculate beyond the shown code.</span><br><span class="line">Do NOT call something a bug unless the code shown is clearly unsafe.</span><br><span class="line">Always list concrete missing pieces when you answer &quot;Unknown:&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只发送出现问题的代码行，chatgpt 会回复无法进行判断，需要更多信息。此时就遇到了一个很有趣的问题：<strong>还需要多少？多少才算足够？</strong></p>
<p>文章又测试了发送漏洞代码行的前四行和后四行代码作为辅助判断的上下文，但是这仍然不足以让 LLM 做出任何可靠的判断。文章讨论了如何判断 LLM 何时拥有足够的上下文信息？是否需要整个文件吗？多个文件？还是只需要完整的函数？所有这些问题都很有意义，这促使促使研究人员从另一个角度思考问题。</p>
<h3 id="Letting-the-LLM-ask-for-its-own-context"><a href="#Letting-the-LLM-ask-for-its-own-context" class="headerlink" title="Letting the LLM ask for its own context"></a>Letting the LLM ask for its own context</h3><p>让 LLM 自行寻找其需要的关键上下文信息，按需上下文索引过程如下图所示：</p>
<p><img src="/../uploads/paper_vuln_2.png"></p>
<p>理论上听起来很棒，但在验证这个理论之前，也就是说只有代码行号时，我们能否提取出函数？事实证明，这并非易事，尤其是在 C 语言中（文章是以 C 语言为基础，但是我想在 Java 上对该框架进行测试）。</p>
<p>文章讨论了使用正则表达式和代码索引器来进行函数抽取，但是正则在 C 语言上不起作用，并且使用代码索引器构建索引库太过漫长，无法将其扩展到大型项目。</p>
<p>然后作者意识到，如果代码索引器基本上执行的是静态分析相同的工作，而我们已经在使用静态分析（CodeQL），为什么不直接使用 CodeQL 数据库来按需提取所有必要的上下文信息呢？</p>
<p>于是，就有了<strong>关键想法</strong>：</p>
<ul>
<li>运行一条 CodeQL 查询，获取起始行小于问题行且结束行大于问题行的函数；</li>
<li>如果 LLM 需要更多上下文，则运行另一个查询并提取必要的上下文，<strong>达成关键信息提取循环</strong>。</li>
</ul>
<p><img src="/../uploads/paper_vuln_3.png"></p>
<p>理论上方法是有效的：</p>
<ul>
<li>它们包括所有第三方代码</li>
<li>它们已经可以通过 GitHub API (CI&#x2F;CD) 获取</li>
<li>无需克隆仓库</li>
<li>查询它们可以获得精确的、编译器级别的结构</li>
</ul>
<p>但是这个想法在执行是遇到了性能瓶颈：为了给 LLM 提供“按需的精确上下文”，他们不得不频繁运行“动态 CodeQL 查询”，而这在性能上几乎不可接受。</p>
<h3 id="解决方案：Pre-Extracting-functions-into-a-CSV"><a href="#解决方案：Pre-Extracting-functions-into-a-CSV" class="headerlink" title="解决方案：Pre-Extracting functions into a CSV"></a>解决方案：Pre-Extracting functions into a CSV</h3><p>与其每次 LLM 请求时都运行每个查询，不如采用更简洁的方法：编写一个 CodeQL 查询，选择数据库中的每个函数（包括调用函数），并将其导出到 CSV 文件中。也许 CSV 文件可能非常大，但我们受限的是时间，而不是空间。</p>
<p>工作流：</p>
<ol>
<li>将所有函数信息提取到 CSV 文件</li>
<li>对代码运行 CodeQL 并保存所有问题</li>
<li>获取每个问题发生的具体位置</li>
<li>扫描 CSV 文件以查找函数：<code>函数起始行 &lt;= 问题行 &lt;= 函数结束行</code></li>
<li>使用 CSV 文件中的信息，直接从代码中提取该函数</li>
<li>如果 LLM 需要调用函数，只需在同一上下文中查找其 ID，并将更新后的上下文发送给 LLM 即可</li>
</ol>
<p>更棒的是，我们还可以节省更多时间，因为每个 CodeQL 数据库都包含一个 src.zip 文件，其中包含用于构建数据库的所有源代码。无需克隆存储库；只需从 GitHub API 下载一次数据库即可。</p>
<p>使用 CSV 文件按需传输上下文：</p>
<p><img src="/../uploads/paper_vuln_4.png"></p>
<h3 id="Guiding-the-LLM-with-high-level-questions"><a href="#Guiding-the-LLM-with-high-level-questions" class="headerlink" title="Guiding the LLM with high-level questions"></a>Guiding the LLM with high-level questions</h3><p>与其直接向 LLM 提供问题，作者提出可以在 LLM 做出判断之前向其提出“ 引导性问题” ，以增强其推理过程。例如：</p>
<p>源缓冲区在哪里声明？它的尺寸是多少？这个尺寸会改变吗？目标缓冲区在哪里声明？这些缓冲区是从其他地方分配的吗？哪些条件或操作会影响它们？</p>
<p>通过引导性问题增加模型思考起作用了，由于 LLM 模型的输出基于之前的文本，这种格式鼓励它逐步推理。通过回答关于变量和流程的针对性问题，该模型模拟了资深研究人员的推理过程，最终决策是在掌握所有正确且与上下文相关的最新信息的情况下做出的。</p>
<p>由于 LLM 现在可以“讲解”变量、大小、赋值和路径，因此它自然而然地避免了以前犯的错误，不需要任何特殊情况的指示，就像一位资深研究员一样。</p>
<p>但需要注意的是，<strong>不同类型的问题需要不同的引导性问题</strong>。对于某些漏洞，LLM 需要分析控制流；对于其他漏洞，它必须分析变量类型；在某些情况下，它还必须关注特殊条件或极端情况。</p>
<h2 id="Running-the-method-in-the-real-world"><a href="#Running-the-method-in-the-real-world" class="headerlink" title="Running the method in the real world"></a>Running the method in the real world</h2><p>在实际环境中运行这个方法：</p>
<ul>
<li><p>静态分析中“位WHERE和“WHAT”问题的实用解答</p>
</li>
<li><p>一个人工智能代理，可以直接从 CodeQL CSV 输出中提取所有必要的上下文信息</p>
</li>
<li><p>一种可靠的方法，可以引导 LLM 评估实际脆弱性，而不是匹配表面模式。</p>
</li>
</ul>
<p>作者使用这种方法对 100 个大型开源 GitHub 存储库（按 C 语言的 star 数选择）运行了该工具，并扫描了多种不同的问题类型。</p>
<p>针对每个问题类别，项目设计了具体的引导性问题，以使 LLM 专注于准确判断可利用性所需的确切语义和上下文。</p>
<p>利用这种方法，项目构建了一个名为 Vulnhalla 的开源工具。它允许用户直接从 GitHub 下载 CodeQL 数据库，对其运行查询，并将结果导入 LLM 模型。对于每个发现，该工具会自动检索相关的代码上下文，并应用针对特定问题的引导性问题。这使得模型能够更准确地推断底层逻辑，过滤掉误报，并仅显示真正具有潜在价值的发现。</p>
<p>Vulnhalla 通过将 CodeQL 与 LLM 支持的推理相结合，解决了大规模静态分析中持续存在的信噪比瓶颈问题，从而实现精确且可扩展的漏洞发现。</p>
<p>该工具目前支持 C 和 C++ 的完整代码导航，并包含多个引导式问题的示例模板。</p>
<p>我们诚邀社区贡献力量，扩展对更多编程语言的支持。这包括编写 CodeQL 查询，根据语言语义将相关数据提取为 CSV 格式，以及创建针对每种问题类型和语言量身定制的引导式问题模板。</p>
<h2 id="Key-Takeaways-and-Next-Steps-for-CodeQL-and-LLM-Vulnerability-Hunting"><a href="#Key-Takeaways-and-Next-Steps-for-CodeQL-and-LLM-Vulnerability-Hunting" class="headerlink" title="Key Takeaways and Next Steps for CodeQL and LLM Vulnerability Hunting"></a>Key Takeaways and Next Steps for CodeQL and LLM Vulnerability Hunting</h2><p>项目贡献点：</p>
<ul>
<li>误报率降低高达 96%</li>
<li>性能优化</li>
<li>增强逻辑推理能力</li>
<li>漏洞挖掘</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.利用大语言模型优化 CodeQL 漏洞挖掘 <a href="https://mp.weixin.qq.com/s/REEcsXvUh4WPHaNC3Qo-jw">https://mp.weixin.qq.com/s/REEcsXvUh4WPHaNC3Qo-jw</a></p>
<p>2.Vulnhalla: Picking the true vulnerabilities from the CodeQL haystack <a href="https://www.cyberark.com/resources/threat-research-blog/vulnhalla-picking-the-true-vulnerabilities-from-the-codeql-haystack">https://www.cyberark.com/resources/threat-research-blog/vulnhalla-picking-the-true-vulnerabilities-from-the-codeql-haystack</a></p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
        <tag>LLM</tag>
        <tag>Papers</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows结束进程</title>
    <url>/2025/12/09/Windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>今天在跑 Springboot 的 Java 项目时，遇到了端口占用问题，记一下 Windows 的根据相关端口杀进程命令。</p>
<p>首先查找占用 8080 的 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></table></figure>

<p>然后根据 PID 强制结束进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /PID 3836</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>实验</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;netstat -ano | findstr :8080</span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       3836</span><br><span class="line">  TCP    [::]:8080              [::]:0                 LISTENING       3836</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;taskkill /F /PID 3836</span><br><span class="line">成功: 已终止 PID 为 3836 的进程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>uv使用</title>
    <url>/2025/12/10/uv%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>uv是一个用 Rust 编写的极快的 Python 包和项目管理工具。</p>
<p>官方文档参考：<a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a></p>
<h2 id="uv安装"><a href="#uv安装" class="headerlink" title="uv安装"></a>uv安装</h2><p>Linux &amp; MacOS 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Windows powershell 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell -ExecutionPolicy ByPass -c <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>以Windows为例，下载uv并配置环境变量，在powershell中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\<span class="number">77319</span>&gt; powershell <span class="literal">-ExecutionPolicy</span> ByPass <span class="literal">-c</span> <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br><span class="line">Downloading uv <span class="number">0.9</span>.<span class="number">17</span> (x86_64<span class="literal">-pc-windows-msvc</span>)</span><br><span class="line">Installing to C:\Users\<span class="number">77319</span>\.local\bin</span><br><span class="line">  uv.exe</span><br><span class="line">  uvx.exe</span><br><span class="line">  uvw.exe</span><br><span class="line">everything<span class="string">&#x27;s installed!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To add C:\Users\77319\.local\bin to your PATH, either restart your shell or run:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    set Path=C:\Users\77319\.local\bin;%Path%   (cmd)</span></span><br><span class="line"><span class="string">    $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;   (powershell)</span></span><br><span class="line"><span class="string">(base) PS C:\Users\77319&gt; $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入uv -h</p>
<p><img src="/../uploads/uv.png"></p>
<p>即表示安全成功。</p>
<h2 id="uv使用"><a href="#uv使用" class="headerlink" title="uv使用"></a>uv使用</h2><p>以官方实践为例，展示uv如何初始化一个 Python 项目、添加依赖、运行工具、生成锁文件并同步环境。  </p>
<p><code>uv init example</code> — 创建一个新的 Python 项目模板  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~$ uv init myproject_test</span><br><span class="line">Initialized project `myproject-test` at `/home/zyu/myproject_test`</span><br><span class="line">(base) zyu@zyu-virtual-machine:~$ <span class="built_in">cd</span> myproject_test/</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ tree .</span><br><span class="line">.</span><br><span class="line">├── main.py</span><br><span class="line">├── pyproject.toml</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv add ruff</code> — 安装依赖并更新 pyproject  </p>
<p>自动创建项目虚拟环境，安装依赖包ruff，把依赖写入pyproject.toml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv add ruff</span><br><span class="line">Using CPython 3.13.9 interpreter at: /home/zyu/miniconda3/bin/python3</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 864ms</span><br><span class="line">Prepared 1 package <span class="keyword">in</span> 1.30s</span><br><span class="line">Installed 1 package <span class="keyword">in</span> 1ms</span><br><span class="line"> + ruff==0.14.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv run ruff check</code> — 运行 ruff 检查代码  </p>
<p> 使用项目虚拟环境里的 ruff 执行代码风格检查 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv run ruff check</span><br><span class="line">All checks passed!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv lock</code> — 生成锁文件 : 解析所有依赖版本  , 生成 <code>uv.lock</code>（类似 Pipfile.lock &#x2F; poetry.lock），保证这个项目未来依赖安装一致、可复现。  </p>
<p><code>uv sync</code> — 按锁文件同步虚拟环境 ： 根据 <code>uv.lock</code> 安装或更新依赖  ， 确保 <code>.venv/</code> 完全匹配锁文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv lock</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.84ms</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv <span class="built_in">sync</span></span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.70ms</span><br><span class="line">Audited 1 package <span class="keyword">in</span> 0.09ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uvx pycowsay &#39;hello world!&#39; </code> uvx 等价于 <code>uv tool run</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uvx pycowsay <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line">Installed 1 package <span class="keyword">in</span> 5ms</span><br><span class="line">/home/zyu/.cache/uv/archive-v0/nYZiOnUm3DMddg7I9DLwr/lib/python3.13/site-packages/pycowsay/main.py:27: SyntaxWarning: invalid escape sequence <span class="string">&#x27;\ &#x27;</span></span><br><span class="line">  \   ^__^</span><br><span class="line"></span><br><span class="line">  ------------</span><br><span class="line">&lt; hello world! &gt;</span><br><span class="line">  ------------</span><br><span class="line">   \   ^__^</span><br><span class="line">    \  (oo)\_______</span><br><span class="line">       (__)\       )\/\</span><br><span class="line">           ||----w |</span><br><span class="line">           ||     ||</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是官方提供的示例Demo。</p>
<p>在实际项目中使用（以<a href="https://github.com/JordyZomer/codeql-mcp#">https://github.com/JordyZomer/codeql-mcp#</a>为例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">error: No virtual environment found; run `uv venv` to create an environment, or pass `--system` to install into a non-virtual environment</span><br></pre></td></tr></table></figure>

<p> 使用 <code>uv pip</code> 安装依赖，但当前目录没有虚拟环境，所以 uv 不知道该把包装到哪里。  uv 的原则是如果不指定装到哪里，它默认要找一个虚拟环境（.venv），如果找不到就报错。所以需要先创建虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv venv</span><br><span class="line">Using CPython 3.11.7 interpreter at: C:\Users\77319\anaconda3\python.exe</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Activate with: .venv\Scripts\activate</span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">Resolved 60 packages <span class="keyword">in</span> 1.61s</span><br><span class="line">Prepared 60 packages <span class="keyword">in</span> 3.56s</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/60] Installing wheels...                                                warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.                                                                                            </span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.                                                                                    </span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.                                                                             </span><br><span class="line">Installed 60 packages <span class="keyword">in</span> 4.17s</span><br><span class="line"> + annotated-types==0.7.0                                                                       </span><br><span class="line"> + anyio==4.12.0                                                                                </span><br><span class="line"> + attrs==25.4.0                                                                                </span><br><span class="line"> + authlib==1.6.5                                                                               </span><br><span class="line"> + beartype==0.22.8                                                                             </span><br><span class="line"> + cachetools==6.2.2</span><br><span class="line"> + certifi==2025.11.12</span><br><span class="line"> + cffi==2.0.0</span><br><span class="line"> + charset-normalizer==3.4.4</span><br><span class="line"> + click==8.3.1</span><br><span class="line"> + colorama==0.4.6</span><br><span class="line"> + cryptography==46.0.3</span><br><span class="line"> + cyclopts==4.3.0</span><br><span class="line"> + diskcache==5.6.3</span><br><span class="line"> + dnspython==2.8.0</span><br><span class="line"> + docstring-parser==0.17.0</span><br><span class="line"> + docutils==0.22.3</span><br><span class="line"> + email-validator==2.3.0</span><br><span class="line"> + exceptiongroup==1.3.1</span><br><span class="line"> + fastmcp==2.13.3</span><br><span class="line"> + h11==0.16.0</span><br><span class="line"> + httpcore==1.0.9</span><br><span class="line"> + httpx==0.28.1</span><br><span class="line"> + httpx-sse==0.4.3</span><br><span class="line"> + idna==3.11</span><br><span class="line"> + jsonschema==4.25.1</span><br><span class="line"> + jsonschema-path==0.3.4</span><br><span class="line"> + jsonschema-specifications==2025.9.1</span><br><span class="line"> + markdown-it-py==4.0.0</span><br><span class="line"> + mcp==1.22.0</span><br><span class="line"> + mdurl==0.1.2</span><br><span class="line"> + openapi-pydantic==0.5.1</span><br><span class="line"> + pathable==0.4.4</span><br><span class="line"> + pathvalidate==3.3.1</span><br><span class="line"> + platformdirs==4.5.1</span><br><span class="line"> + py-key-value-aio==0.3.0</span><br><span class="line"> + py-key-value-shared==0.3.0</span><br><span class="line"> + pycparser==2.23</span><br><span class="line"> + pydantic==2.12.5</span><br><span class="line"> + pydantic-core==2.41.5</span><br><span class="line"> + pydantic-settings==2.12.0</span><br><span class="line"> + pygments==2.19.2</span><br><span class="line"> + pyjwt==2.10.1</span><br><span class="line"> + pyperclip==1.11.0</span><br><span class="line"> + python-dotenv==1.2.1</span><br><span class="line"> + python-multipart==0.0.20</span><br><span class="line"> + pywin32==311</span><br><span class="line"> + pyyaml==6.0.3</span><br><span class="line"> + referencing==0.36.2</span><br><span class="line"> + requests==2.32.5</span><br><span class="line"> + rich==14.2.0</span><br><span class="line"> + rich-rst==1.3.2</span><br><span class="line"> + rpds-py==0.30.0</span><br><span class="line"> + sse-starlette==3.0.3</span><br><span class="line"> + starlette==0.50.0</span><br><span class="line"> + typing-extensions==4.15.0</span><br><span class="line"> + typing-inspection==0.4.2</span><br><span class="line"> + urllib3==2.6.1</span><br><span class="line"> + uvicorn==0.38.0</span><br><span class="line"> + websockets==15.0.1</span><br></pre></td></tr></table></figure>

<p>关于报错信息可以忽略，大致意思是： uv 想用硬链接（hardlink）加速依赖安装，但我们的缓存目录和安装目录不在同一个文件系统上 → 无法硬链接 → 只能退回到“完整复制”文件，性能稍慢一点。  应该缓存目录在C盘，但是安装目录在D盘。</p>
<p>运行mcp服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">Error: typer is required. Install with <span class="string">&#x27;pip install mcp[cli]&#x27;</span></span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install mcp[cli]</span><br><span class="line">Resolved 37 packages <span class="keyword">in</span> 710ms</span><br><span class="line">Prepared 2 packages <span class="keyword">in</span> 138ms</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/2] Installing wheels...                                                 warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.</span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.</span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.</span><br><span class="line">Installed 2 packages <span class="keyword">in</span> 56ms</span><br><span class="line"> + shellingham==1.5.4</span><br><span class="line"> + typer==0.20.0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>uv</tag>
      </tags>
  </entry>
  <entry>
    <title>kali安装ssh</title>
    <url>/2025/12/10/kali%E5%AE%89%E8%A3%85ssh/</url>
    <content><![CDATA[<h1 id="kali-linux-安装ssh服务"><a href="#kali-linux-安装ssh服务" class="headerlink" title="kali linux 安装ssh服务"></a>kali linux 安装ssh服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl start ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh <span class="comment">#设置开机自启</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl status ssh <span class="comment">#查看运行状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Kali Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决VScode和Trae等无法加载conda虚拟环境的问题</title>
    <url>/2025/12/02/%E8%A7%A3%E5%86%B3VScode%E5%92%8CTrae%E7%AD%89%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>使用 conda 或 miniconda 配置虚拟环境时，当启动虚拟环境时，遇到如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是，运行 <code>conda init</code> 后还是不起作用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ conda init</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda.exe</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda-env.exe</span><br><span class="line">......</span><br><span class="line">no change     C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</span><br><span class="line">modified      HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun</span><br></pre></td></tr></table></figure>

<h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>我是 win11 操作系统，需要以 <strong>管理员身份</strong> 打开powershell窗口，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>重新加载即可生效。</p>
<span id="more"></span>

<h1 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h1><p>简单说，这个问题本质上是：<strong>Conda 的初始化脚本被 PowerShell 的安全策略拦住了，所以每次新开终端时，Conda 都没真正“接管”当前 Shell。</strong></p>
<h2 id="1-conda-init-实际在做什么？"><a href="#1-conda-init-实际在做什么？" class="headerlink" title="1. conda init 实际在做什么？"></a>1. <code>conda init</code> 实际在做什么？</h2><p>在 Windows + PowerShell 下，Conda 并不是简单地靠 <code>conda.exe</code> 来完成环境激活的，而是通过一套 <strong>Shell Hook 脚本</strong> 来接管当前会话：</p>
<p><code>conda init</code> 会在 <code>C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</code> 里写入一段初始化代码，这些脚本会去调用 <code>miniconda3\shell\condabin\conda-hook.ps1</code> 等文件，往当前 PowerShell 里注入 <code>conda</code> &#x2F; <code>conda activate</code> 等函数，并设置好 PATH、环境变量等。</p>
<p><strong>只有这些 Hook 每次打开 PowerShell 时能顺利执行，当前终端才真正“支持” <code>conda activate</code>。</strong></p>
<p>所以当你看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实意思是：<strong>当前这个 PowerShell 会话里没有被注入 Conda 的 Hook 脚本</strong>，所以它感觉自己还没 init。</p>
<h2 id="2-PowerShell-执行策略的限制"><a href="#2-PowerShell-执行策略的限制" class="headerlink" title="2. PowerShell 执行策略的限制"></a>2. PowerShell 执行策略的限制</h2><p>PowerShell 为了安全，有一个 <strong>执行策略（Execution Policy）</strong>，决定哪些脚本可以被执行：</p>
<p>常见几种：</p>
<ul>
<li><code>Restricted</code>：完全禁止执行脚本；</li>
<li><code>AllSigned</code>：所有脚本都必须是签名的；</li>
<li><code>RemoteSigned</code>：本地脚本可以执行，从互联网下载的脚本必须签名。</li>
</ul>
<p>在我机器上的情况是：</p>
<ul>
<li><p>Conda 的这些 hook &#x2F; profile 脚本属于 <strong>本地脚本</strong>；</p>
</li>
<li><p>但默认配置策略过于严格，导致：</p>
<ul>
<li>打开 PowerShell 时，<code>profile.ps1</code> &#x2F; <code>conda-hook.ps1</code> 没有被执行；</li>
<li>于是 <code>conda</code> 函数、自动激活逻辑统统都没加载进当前会话；</li>
<li>终端自然就会提示你先 <code>conda init</code>。</li>
</ul>
</li>
</ul>
<p>也就是说：<code>conda init</code> 写入的配置已经在那儿了，但每次启动 PowerShell 时都被策略挡在门外。 当以管理员身份执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>等于允许系统执行本地脚本，只对来源不明的远程脚本做限制。</p>
<p>这样一来，再次打开 PowerShell &#x2F; VSCode 内置终端时，<code>profile.ps1</code> 会被正常加载，里面调用的 <code>conda-hook.ps1</code> 等本地脚本可以顺利执行， VSCode &#x2F; Trae 里就可以正常加载和激活 Conda 虚拟环境，不再报 Run ‘conda init’ before ‘conda activate’错误。</p>
]]></content>
      <categories>
        <category>Trouble shooting</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Trouble shooting</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11 Java环境变量配置</title>
    <url>/2025/12/04/Win11-Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>找到JDK的路径，在系统环境变量中新建变量名和变量值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_202</span><br></pre></td></tr></table></figure>

<p>然后在系统变量path中，新建两条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br><span class="line">%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>验证配置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_202&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;javac -version</span><br><span class="line">javac 1.8.0_202</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
