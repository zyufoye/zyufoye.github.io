<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CodeQL入门</title>
    <url>/2025/12/07/CodeQL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="CodeQL-入门"><a href="#CodeQL-入门" class="headerlink" title="CodeQL 入门"></a>CodeQL 入门</h1><p>在网络安全和代码审计的领域，静态应用程序安全测试（Static application security testing，SAST）工具层出不穷。但在 2019 年 GitHub 收购 Semmle 之后，CodeQL 迅速成为了业界顶流。</p>
<p>传统的扫描工具往往像是一个黑盒，你输入代码，它吐出报告。但 CodeQL 不同，它的核心理念非常有意思： <code>Code as Data</code> 代码即数据，CodeQL 把源代码转化成一个关系型数据库，而漏洞挖掘的过程，就变成了一次次编写 SQL（其实是 QL）查询语句的过程。</p>
<p>CodeQL 工具包含两大部分组成：</p>
<ul>
<li>核心引擎(闭源)：用于解析源代码并存储于数据库，以及执行 QL 语句从数据库中进行查询；</li>
<li>SDK代码库(开源)：包含各编程语言对应的 QL 代码库(属性&#x2F;谓词&#x2F;等)，以便快速编写查询语句。</li>
</ul>
<p>这给了安全研究员和开发者极大的自由度——不再受限于工具内置的规则，可以自己定义“什么样的代码长相存在漏洞”。这篇 Blog 记录了我第一次使用 CodeQL 进行静态代码分析的过程。</p>
<span id="more"></span>

<h2 id="一、CodeQL-核心工作流"><a href="#一、CodeQL-核心工作流" class="headerlink" title="一、CodeQL 核心工作流"></a>一、CodeQL 核心工作流</h2><p>使用 CodeQL 主要分为三个步骤：</p>
<ol>
<li><p><strong>创建数据库（Create Database）</strong>： 在编译&#x2F;构建代码的过程中，CodeQL 会“旁路监听”，捕捉所有的编译命令、文件结构、函数调用关系，生成一个快照数据库；</p>
</li>
<li><p><strong>编写&#x2F;运行查询（Analyze）</strong>： 使用一种类似 SQL 的面向对象查询语言（QL），在数据库中查找符合特征的代码片段；</p>
</li>
<li><p><strong>生成结果（Results）</strong>： 输出分析报告（通常是 SARIF 格式），定位到具体的代码行号。</p>
</li>
</ol>
<h2 id="二、CodeQL-安装"><a href="#二、CodeQL-安装" class="headerlink" title="二、CodeQL 安装"></a>二、CodeQL 安装</h2><p>运行 CodeQL 需要安装 CodeQL CLI 工具，分开下载的话需要分别下载 CodeQL binary 和 SDK，需要放在相同目录下且版本保持一致，也可以直接下载捆绑包，以 Ubuntu 环境为例，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/github/codeql-action/releases/download/codeql-bundle-v2.16.1/codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvzf codeql-bundle-linux64.tar.gz</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/aono/codeqlsrc/codeql</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>检测是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql --version</span><br></pre></td></tr></table></figure>

<p>可以使用  <code>codeQL resolve languages</code> 可以查看支持的编程语言。</p>
<h2 id="三、CodeQL-简单使用"><a href="#三、CodeQL-简单使用" class="headerlink" title="三、CodeQL 简单使用"></a>三、CodeQL 简单使用</h2><p>指定项目创建数据库，以 Java 目标（<a href="https://github.com/l4yn3/micro_service_seclab%EF%BC%89%E4%B8%BA%E4%BE%8B%EF%BC%8C%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87">https://github.com/l4yn3/micro_service_seclab）为例，项目通过</a> mvn 构建，首先安装 mvn：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install maven -y</span><br></pre></td></tr></table></figure>

<p>创建数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database create java_db --language=java --source-root=./test/micro_service_seclab/</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_1.png"></p>
<p>使用默认规则进行查询，生成 SARIF 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./codeql/codeql database analyze java_db/ --format=sarif-latest --output=java_result.sarif</span><br></pre></td></tr></table></figure>

<p><img src="/../uploads/codeql_2.png"></p>
]]></content>
      <categories>
        <category>SAST</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Function Call和MCP的区别</title>
    <url>/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）"><a href="#Function-Call和MCP的核心区别梳理（由GPT-5-1-生成）" class="headerlink" title="Function Call和MCP的核心区别梳理（由GPT 5.1 生成）"></a>Function Call和MCP的核心区别梳理（由GPT 5.1 生成）</h2><h2 id="🧩核心区别总结"><a href="#🧩核心区别总结" class="headerlink" title="🧩核心区别总结"></a>🧩核心区别总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Function Call</th>
<th>MCP（Model Context Protocol）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>让模型按照开发者定义的结构化方式返回“调用某函数所需的参数”。</td>
<td>让模型与外部工具、服务、数据源通过统一协议进行双向通信。</td>
</tr>
<tr>
<td><strong>角色</strong></td>
<td>模型只“产生命令”（函数+参数），不执行。执行由外部应用完成。</td>
<td>除生成调用外，还可以<strong>发现、注册、调度、执行</strong>外部资源。</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单、轻量级、多数场景够用。</td>
<td>更底层、更通用，可连接复杂系统。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>调用某个特定函数、处理结构化任务。</td>
<td>接入多个工具、多数据源、插件系统、企业级工作流。</td>
</tr>
</tbody></table>
<hr>
<span id="more"></span>

<h2 id="🧠Function-Call-是什么？"><a href="#🧠Function-Call-是什么？" class="headerlink" title="🧠Function Call 是什么？"></a>🧠Function Call 是什么？</h2><p><strong>Function Call</strong> 是模型输出的一种结构化格式，模型输出它想调用什么函数并且要传什么参数。模型只负责<strong>输出结构化 JSON</strong>，实际执行由相关程序完成。</p>
<p><strong>Function Call</strong>提供的是 API 层的能力，由开发者定义可调用函数列表，模型产出：函数名 + 参数，适用于简单逻辑。</p>
<h3 id="✔-Function-Call-示例"><a href="#✔-Function-Call-示例" class="headerlink" title="✔ Function Call 示例"></a>✔ Function Call 示例</h3><p>假设开发者定义了一个函数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取城市天气&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;city&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>用户问：</p>
<blockquote>
<p>“明天北京天气如何？”</p>
</blockquote>
<p>模型可能返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;get_weather&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后 <strong>相关程序</strong> 执行 get_weather(“北京”) 并把结果再返回给模型或用户。</p>
<p>📌 <strong>关键点：模型不会执行，只会返回结构体。</strong></p>
<h2 id="🧠MCP（Model-Context-Protocol）是什么？"><a href="#🧠MCP（Model-Context-Protocol）是什么？" class="headerlink" title="🧠MCP（Model Context Protocol）是什么？"></a>🧠MCP（Model Context Protocol）是什么？</h2><p>MCP 是一个<strong>通用协议</strong>，用于管理工具（tools），连接外部数据源（database、文件系统等），让模型能够发现并调用这些资源，同时统一不同工具的接口格式。</p>
<p>可以把 MCP 理解为：</p>
<blockquote>
<p><strong>模型与外部世界的“操作系统抽象层”</strong><br>它让模型能直接访问文件、数据库、网络等工具。</p>
</blockquote>
<p>它的“能力”比 Function Call 强得多，因为：</p>
<p>👉 <strong>Function Call 只能调用开发人员手工写死的函数</strong><br>👉 <strong>MCP 可以动态加载工具包、文件系统服务、环境服务，让模型像操作系统用户一样访问资源</strong></p>
<hr>
<h3 id="✔-MCP-示例"><a href="#✔-MCP-示例" class="headerlink" title="✔ MCP 示例"></a>✔ MCP 示例</h3><p>假设 MCP 提供一个工具 <code>fs.read_file</code>。</p>
<p>用户问：</p>
<blockquote>
<p>“打开 &#x2F;docs&#x2F;intro.md 读给我听”</p>
</blockquote>
<p>模型实际会产生这样的消息（非 Function Call 风格，而是 MCP 消息协议）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.read_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/intro.md&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>服务端会执行 <strong>read_file</strong> 并返回文件内容。</p>
<p>模型可以继续请求：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;call_tool&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tool&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fs.write_file&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/docs/notes.txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;这里是我总结的内容...&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里体现 MCP 的本质：</p>
<ul>
<li>模型知道有哪些工具可用</li>
<li>模型直接“操控”这些工具</li>
<li>具有类似“文件读写”等复杂能力</li>
<li>不需要开发者提前硬编码所有函数</li>
</ul>
<h2 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>Function Call</th>
<th>MCP</th>
</tr>
</thead>
<tbody><tr>
<td>工具发现</td>
<td>手工定义</td>
<td>自动注册，模型可自动学习工具能力</td>
</tr>
<tr>
<td>调用方式</td>
<td>结构化 JSON</td>
<td>双向协议、消息通信</td>
</tr>
<tr>
<td>扩展性</td>
<td>每加一个功能都要新增函数定义</td>
<td>新增 MCP 服务即可扩展工具能力</td>
</tr>
<tr>
<td>模型能力</td>
<td>被动</td>
<td>主动、可规划调用流程</td>
</tr>
<tr>
<td>场景</td>
<td>简单 API 调用、数据结构化</td>
<td>IDE、数据库集成、文件系统、GitHub 操作、企业自动化</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO链接站内文章方法</title>
    <url>/2025/12/11/HEXO%E9%93%BE%E6%8E%A5%E7%AB%99%E5%86%85%E6%96%87%E7%AB%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Hexo链接站内文章方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link markdown-learning-by-maxiang 点击这里查看这篇文章 %&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>markdown-learning-by-maxiang</code> 为文章名称，我测试了同目录下修改为自己文章名称可以成功，注意不要加路径，如果文章名称有空格就用双引号引起来。<code>点击这里查看这篇文章</code> 部分是现实的内容，如果不写的话就默认是文章名称。</p>
<p>参考链接：<a href="https://github.com/iissnan/hexo-theme-next/issues/978">https://github.com/iissnan/hexo-theme-next/issues/978</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO使用记录</title>
    <url>/2025/12/04/HEXO%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Hexo-使用记录"><a href="#Hexo-使用记录" class="headerlink" title="Hexo 使用记录"></a>Hexo 使用记录</h1><p>参考文献： <a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
<p>官方文档：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<h2 id="HEXO-简介"><a href="#HEXO-简介" class="headerlink" title="HEXO 简介"></a>HEXO 简介</h2><p>Hexo 是一个基于 Node.js 的快速、简洁且高效的静态博客框架。它拥有超快的渲染速度、灵活的配置方式，以及丰富的主题与插件生态。借助 Markdown 写作，可以轻松生成优雅的静态网页，并部署到 GitHub Pages、Vercel、Netlify 等任意静态托管平台。无论是想建立个人博客、文档站点，还是打造独特的技术分享空间，Hexo 都能提供流畅而高效的创作体验。</p>
<span id="more"></span>

<h2 id="一、Hexo-安装"><a href="#一、Hexo-安装" class="headerlink" title="一、Hexo 安装"></a>一、Hexo 安装</h2><p>Hexo 是一个快速、简单且功能强大的博客框架，可以使用 Markdown （或其他标记语言）编写文章，Hexo 会在几秒钟内生成带有对应主题的静态文件。</p>
<p>安装 Hexo 需要 Node.js 以及 Git 环境。</p>
<p>Node.js 下载地址 <a href="https://nodejs.org/en/download">Node.js Download</a></p>
<p>Git 下载地址 <a href="https://git-scm.com/install/windows">Git Download</a></p>
<p>所有必需组件安装完毕后，即可使用 npm 安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>初始化 Hexo 站点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexo-site</span><br></pre></td></tr></table></figure>
<p>hexo-site 也可以替换为其他路径名，以 hexo-site 为例，网站根目录被称为 <code>hexo-site</code>。 </p>
<p>初始化完成后，可以到网站根目录下，下载对应主题并进行升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-site</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"></span><br><span class="line">npm install hexo-theme-next@latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>运行 npm install 时，对 node_modules 目录下主题所做的任何本地更改都将丢失。如果对主题进行了更改，则应在运行 npm install 之前备份这些更改，然后在安装完成后恢复这些更改。</p>
<p>安装完 Hexo 和 NexT 主题后，可以通过修改配置文件来自定义博客。安装 Hexo 时，配套的配置文件位于网站根目录。博客配置文件名为 _config.yml ；我们称之为 Hexo 配置文件 NexT 主题的配置文件需要您自行创建；请在目录下创建一个 _config.next.yml 文件。 网站根目录我们将其称为 Next 配置文件在以下文本中。</p>
<p>创建空的 _config.next.yml 文件后，可以将主题文件夹中的默认配置选项复制到该文件中，以便进行修改和自定义。根据安装方式，NexT 主题的默认配置文件可能位于 themes&#x2F;next&#x2F;_config.yml 或 node_modules&#x2F;hexo-theme-next&#x2F;_config.yml 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>

<h2 id="二、Hexo-个性化设置"><a href="#二、Hexo-个性化设置" class="headerlink" title="二、Hexo 个性化设置"></a>二、Hexo 个性化设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow to cache content generation.</span></span><br><span class="line">cache:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove unnecessary files after hexo generate.</span></span><br><span class="line">minify: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line">darkmode: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:zyufoye/zyufoye.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、Hexo-新建发布文章"><a href="#三、Hexo-新建发布文章" class="headerlink" title="三、Hexo 新建发布文章"></a>三、Hexo 新建发布文章</h2><p>新建发布文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章名称&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成并部署：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp;  hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>同步更新部署到github：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>博客侧边栏添加 menu 菜单，以 tags 和 categories 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>同时在index.md 中设置类别，不然点击跳转后不显示任何内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>: categories</span><br></pre></td></tr></table></figure>

<p>设置文章想要显示的内容时，可以用 more 进行切分， more以上的作为显示内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>以上基本配置和简单使用记录完毕，后续有更多需要再持续更新记录。  </p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java漏洞靶场搭建学习(一)：环境搭建与Springboot架构</title>
    <url>/2025/12/09/Java%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8ESpringboot%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Java漏洞靶场搭建学习"><a href="#Java漏洞靶场搭建学习" class="headerlink" title="Java漏洞靶场搭建学习"></a>Java漏洞靶场搭建学习</h1><p>在学习 Java Web 安全的过程中，目前状态是只能理解相关的漏洞原理，根据 PoC 做题或者复现漏洞，但是这些对于 <strong>代码审计、漏洞挖掘、SDL</strong> 等都没有实质性帮助，想要在学习或工作过程中提升相关能力，计划实现以下目标：</p>
<ul>
<li>理解漏洞产生的真实上下文；</li>
<li>搭建一个可控、可扩展的实验环境；</li>
<li>训练从代码层面定位与修复问题的能力；</li>
</ul>
<p>这篇博客记录了学习搭建 Java 漏洞靶场的过程，作为一个学习记录，为后续能够快速搭建测试环境，验证代码审计工具能力奠定基础。</p>
<span id="more"></span>

<h2 id="项目选用"><a href="#项目选用" class="headerlink" title="项目选用"></a>项目选用</h2><p>本文以 <a href="https://github.com/l4yn3/micro_service_seclab">micro_service_seclab</a> 为基础进行练习。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/l4yn3/micro_service_seclab.git</span><br></pre></td></tr></table></figure>

<p>拿到java项目，导入IDEA，对于有pom.xml的项目，可以直接使用mvn进行构建。</p>
<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--链接数据库</span></span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE micro_service_seclab</span><br><span class="line">  <span class="keyword">CHARACTER SET</span> utf8mb4</span><br><span class="line">  <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用数据库</span></span><br><span class="line">USE micro_service_seclab;</span><br></pre></td></tr></table></figure>

<p>执行sql文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> \d D:\Code\micro_service_seclab</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line">mysql -u root -p micro_service_seclab &lt; micro_service_seclab.sql</span><br></pre></td></tr></table></figure>

<p>需要找到 application.properties  文件，修改对应的数据库用户名和密码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/micro_service_seclab</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=1234</span></span><br></pre></td></tr></table></figure>

<p>在pom.xml的路径下，执行mvn命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure>

<p>启动后访问 <a href="http://127.0.0.1:8080/sqlinjection/one?username=yueshen">http://127.0.0.1:8080/sqlinjection/one?username=yueshen</a> 即可看到返回以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;username&quot;</span>:<span class="string">&quot;yueshen&quot;</span>,<span class="string">&quot;sex&quot;</span>:1,<span class="string">&quot;age&quot;</span>:33&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h2><h3 id="Spring-Boot-三层架构"><a href="#Spring-Boot-三层架构" class="headerlink" title="Spring-Boot 三层架构"></a>Spring-Boot 三层架构</h3><p>该项目核心是一个 Spring Boot Web 应用，通过不同的 Controller 暴露漏洞演示接口；底层再通过 Logic&#x2F;DAO&#x2F;DB&#x2F;MyBatis 访问数据库或触发危险点。</p>
<p>调用链（一次请求的完整路径）：</p>
<blockquote>
<p>HTTP 请求 → controller（漏洞入口） → logic（业务&#x2F;场景封装） → dao&#x2F;mapper（数据访问&#x2F;危险实现） → db&#x2F;mysql</p>
</blockquote>
<p>用通俗的话来记录，就是：</p>
<p>Controller 提供靶场入口，Logic 做业务组织，DAO&#x2F;Mapper 负责数据库或危险 API 调用，data 是实体&#x2F;数据模型，db 是数据库初始化&#x2F;连接辅助。</p>
<ul>
<li><code>Controller</code>：漏洞入口层，对外提供 HTTP API，用户通过 HTTP 打开，它负责把请求带入对应的漏洞场景；</li>
<li><code>Logic</code>：业务场景封装层，存放 Service 的一些东西，把 Controller 参数变成底层可执行的动作；</li>
<li><code>Dao</code>：数据访问层，做数据持久化，方法针对数据库操作；</li>
<li><code>Mapper</code>：MyBatis Mapper 接口层，存放 MyBatis 的接口定义；</li>
<li><code>data</code>：数据模型 实体层 对应数据库表或接口数据结构；</li>
</ul>
<h3 id="部署搭建记录"><a href="#部署搭建记录" class="headerlink" title="部署搭建记录"></a>部署搭建记录</h3><p>首先选择新建项目：</p>
<p><img src="/../uploads/java_range1.png"></p>
<p>通过Springboot Initializr初始化项目:</p>
<p><img src="/../uploads/java_range2.png"></p>
<p>选择相关依赖：</p>
<p><img src="/../uploads/java_range3.png"></p>
<p>初始化项目结构如下：</p>
<p><img src="/../uploads/java_range4.png"></p>
<p>依赖还是存在一些问题，因为靶场对应的是Java1.8版本，但是IDEA创建project时只有17、21和25可选项（这个应该有办法解决，后续再搞），不过目前已经清楚了Springboot的架构是什么样子。</p>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="db-IndexDb-java"><a href="#db-IndexDb-java" class="headerlink" title="db&#x2F;IndexDb.java"></a>db&#x2F;IndexDb.java</h3><p><code>IndexDb.java</code> 是一个基于 <code>JdbcTemplate</code> 的数据库访问类，负责从 students 和 teachers 表中查询数据，同时为了漏洞靶场演示，刻意使用字符串拼接 SQL，存在明显的 SQL 注入风险。</p>
<p>详细解读：</p>
<ul>
<li><p>被标记为 @Repository，供其他层（如 IndexLogic &#x2F; Controller）注入使用。</p>
</li>
<li><p>内部定义了两个 RowMapper，把查询结果映射成 Student 和 Teacher 对象。</p>
</li>
<li><p>提供多种查询方法：</p>
<ol>
<li><p>按用户名模糊查询学生：getStudent &#x2F; getStudentWithOptional</p>
</li>
<li><p>按 id 查询学生：getStudentById</p>
</li>
<li><p>按 id 查询教师：getTeacherById</p>
</li>
<li><p>使用 IN 条件批量用户名查询学生：getStudentWithIn &#x2F; getStudentWithInLong</p>
</li>
</ol>
</li>
</ul>
<p>所有 SQL 都是直接拼接字符串（包括 Optional、List 的拼接）作为靶场中演示 SQL 注入的重要部分。截取部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexDb</span></span><br><span class="line"><span class="comment"> * 使用 Spring 的 JdbcTemplate 直接操作数据库的仓库类。</span></span><br><span class="line"><span class="comment"> * 主要提供针对 students / teachers 表的查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：本类为了配合“Java 漏洞靶场”，大量使用字符串拼接构造 SQL，</span></span><br><span class="line"><span class="comment"> *       实际上存在典型的 SQL 注入风险，用于安全演示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexDb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring 注入 JdbcTemplate，用于执行 SQL 语句</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Student 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Student&gt; ROW_MAPPER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        student.setSex(rs.getInt(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        student.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ResultSet 映射为 Teacher 对象的 RowMapper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RowMapper&lt;Teacher&gt; ROW_MAPPER_TEACHER = (rs, i) -&gt; &#123;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        teacher.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        teacher.setSex(rs.getBoolean(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">        teacher.setName(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生信息。</span></span><br><span class="line"><span class="comment">     * 漏洞点：直接拼接 username 到 SQL 中，存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 安全写法示例（被注释掉）：使用占位符并绑定参数</span></span><br><span class="line">        <span class="comment">// String sql = &quot;select * from students where username like ?&quot;;</span></span><br><span class="line">        <span class="comment">// return jdbcTemplate.query(sql, new Object[]&#123;&quot;%&quot; + username + &quot;%&quot;&#125;, ROW_MAPPER);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名进行模糊查询。</span></span><br><span class="line"><span class="comment">     * 实际上仍然是字符串拼接，同样存在 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithOptional</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username.get() + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 id 精确查询学生。</span></span><br><span class="line"><span class="comment">     * 漏洞点：将 id 转成字符串再拼接到 SQL 中，存在注入风险。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithInt</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;select * from students where id = &#x27;&quot;</span> + String.valueOf(id) + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithInt, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="logic-IndexLogic-java"><a href="#logic-IndexLogic-java" class="headerlink" title="logic&#x2F;IndexLogic.java"></a>logic&#x2F;IndexLogic.java</h3><p><code>IndexLogic.java</code> 本质上是<strong>Service 层的一个浅封装</strong>：</p>
<ul>
<li>用 <code>@Service</code> 标记，表示这是业务逻辑层的 Bean；</li>
<li>通过 <code>@Autowired</code> 注入 <code>IndexDb</code>（4.1节对应的那个数据库访问类）；</li>
<li>对外提供一组方法：<code>getStudent</code> &#x2F; <code>getStudentById</code> &#x2F; <code>getStudentWithOptional</code> &#x2F; <code>getStudentWithIn</code> &#x2F; <code>getStudentWithInLong</code> &#x2F; <code>getTeacherById</code>；</li>
<li>每个方法都<strong>直接把参数原样转发给 <code>IndexDb</code>，不做额外处理</strong>，相当于“转发层”；</li>
<li>因为 <code>IndexDb</code> 里面的 SQL 是拼接的，所以这些 Service 方法也就“顺带”暴露出 SQL 注入漏洞场景，方便 Controller 调用。</li>
</ul>
<p>可以理解为：<br><strong>Controller -&gt; IndexLogic -&gt; IndexDb -&gt; Databases</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IndexLogic</span></span><br><span class="line"><span class="comment"> * 业务逻辑层（Service），对外提供学生 / 老师相关的查询接口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当前实现非常薄，只是简单地把调用转发给 IndexDb，</span></span><br><span class="line"><span class="comment"> * 主要起到：Controller 与 DB 操作之间的“中间层”作用，</span></span><br><span class="line"><span class="comment"> * 方便保持三层架构的结构清晰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于底层 IndexDb 使用字符串拼接 SQL，</span></span><br><span class="line"><span class="comment"> * 这些方法实际也用于配合漏洞靶场演示 SQL 注入场景。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexLogic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入数据库访问类 IndexDb</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IndexDb indexDb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名模糊查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudent</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudent(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 id 查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Optional 包装的用户名查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithOptional(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（字符串列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithIn</span><span class="params">(List&lt;String&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithIn(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 IN 条件（Long 列表）批量查询学生</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithInLong</span><span class="params">(List&lt;Long&gt; user_list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getStudentWithInLong(user_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据“id/userName”查询老师</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getTeacherById</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexDb.getTeacherById(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IndexLogic 是 Controller 和 IndexDb 之间的桥梁，把各种查询操作组织成业务接口，方便暴露为 HTTP 靶场接口。</strong></p>
<hr>
<h3 id="mapper-IStudentMapper-java"><a href="#mapper-IStudentMapper-java" class="headerlink" title="mapper&#x2F;IStudentMapper.java"></a>mapper&#x2F;IStudentMapper.java</h3><p>IStudentMapper 是 students 表的 MyBatis 接口，其中 <code>queryAllByAnnotations</code> 用注解 + <code>$&#123;&#125;</code> 拼串，专门用来检测注解式 SQL 注入漏洞。</p>
<p>Mapper <strong>≈</strong> 映射器，他的作用是把 “Java 方法调用” 映射成 “SQL 语句执行”，再把结果映射回 Java 对象。也可以称为“MyBatis 帮忙自动实现的 DAO 接口”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IStudentMapper</span></span><br><span class="line"><span class="comment"> * MyBatis 的 Mapper 接口，对 students 表提供查询方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个接口有两个目的：</span></span><br><span class="line"><span class="comment"> * 1）正常的查询方法（queryAll），SQL 通常写在 XML 中；</span></span><br><span class="line"><span class="comment"> * 2）使用注解 + $&#123;&#125; 拼接参数的方式，故意制造 SQL 注入漏洞，</span></span><br><span class="line"><span class="comment"> *    用于测试代码扫描工具是否能识别注解里的注入问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式一：常规查询方法</span></span><br><span class="line"><span class="comment">     * SQL 写在 resources/mappers/IStudentMapper.xml 中，</span></span><br><span class="line"><span class="comment">     * 一般会使用 #&#123;name&#125; 这种占位符，属于参数绑定写法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAll</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式二：注解式 SQL，故意使用 $&#123;&#125; 直接拼接参数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里的 SQL：</span></span><br><span class="line"><span class="comment">     *   select * from students where username =&#x27;$&#123;name&#125;&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * $&#123;name&#125; 会被原样替换到 SQL 中，存在明显的 SQL 注入风险。</span></span><br><span class="line"><span class="comment">     * 这是靶场中专门用来测试“静态扫描工具能否发现注解里的 SQL 注入”的例子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from students where username =&#x27;$&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">queryAllByAnnotations</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="data-Person-java"><a href="#data-Person-java" class="headerlink" title="data&#x2F;Person.java"></a>data&#x2F;Person.java</h3><p>data 文件夹下专门存放了“数据模型”，可以保存数据库和业务里的“实体对象”。同时作为各个层次之间传递数据的载体：</p>
<ul>
<li><p>db&#x2F;IndexDb 查出来的是 List<Student>、List<Teacher></p>
</li>
<li><p>logic&#x2F;IndexLogic 接收&#x2F;返回的也是这些对象</p>
</li>
<li><p>Controller 对外返回的 JSON，其实就是把这些 data 类序列化出去</p>
</li>
</ul>
<p>👉 这样 Controller、Service、DAO 都围绕同一套“数据结构”在交流。</p>
<p>Person 是用 JPA+Hibernate 映射出来的人员表实体，用 UUID 当主键，并强制 username 和 nickname 的唯一性与非空约束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person 实体类：</span></span><br><span class="line"><span class="comment"> * 映射数据库中的 person 表（默认表名），</span></span><br><span class="line"><span class="comment"> * 使用 UUID 作为主键，包含唯一且必填的 username / nickname 字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主键 ID，使用自定义的 UUID 生成策略</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(generator = &quot;idGenerator&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;username&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 昵称列：唯一、非空，最长 100 字符</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;nickname&quot;, unique = true, nullable = false, length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dao-PersonRepository-java"><a href="#dao-PersonRepository-java" class="headerlink" title="dao&#x2F;PersonRepository.java"></a>dao&#x2F;PersonRepository.java</h3><p><code>PersonRepository</code> 是一个基于 Spring Data JPA 的 DAO 接口，负责对 Person 实体做数据库查询：根据 username 和 nickname 查人，供 Controller 或 Service 调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersonRepository</span></span><br><span class="line"><span class="comment"> * 基于 Spring Data JPA 的 DAO 接口，</span></span><br><span class="line"><span class="comment"> * 用于对 Person 实体进行数据库访问操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过继承 JpaRepository，可以直接使用通用的增删改查方法，</span></span><br><span class="line"><span class="comment"> * 同时也可以定义派生查询方法或自定义 <span class="doctag">@Query</span> 查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Person, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Spring Data JPA 的“方法名派生查询”功能，</span></span><br><span class="line"><span class="comment">     * 根据 username 字段查询 Person 列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 等价于：SELECT p FROM Person p WHERE p.username = ?1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 <span class="doctag">@Query</span> 手写 JPQL 查询，根据 nickname 查询。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT nickname FROM Person WHERE nickname = &#x27;?1&#x27;&quot;)</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">findPersonByNickname</span><span class="params">(String nickname)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="controller-VulnerabilitiesController-java"><a href="#controller-VulnerabilitiesController-java" class="headerlink" title="controller&#x2F;VulnerabilitiesController.java"></a>controller&#x2F;VulnerabilitiesController.java</h3><p><code>controller</code> 文件夹用来存放项目里的控制器类，也就是对外暴露 HTTP 接口的那一层。在 Spring Boot 里，Controller 负责接收浏览器或工具（如 Postman、burp）的请求，解析参数，把请求转交给逻辑层（logic&#x2F;service），再把返回结果封装成 JSON 或页面响应。</p>
]]></content>
      <categories>
        <category>Java Security</category>
      </categories>
      <tags>
        <tag>Java Security</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP编程快速入门（一）</title>
    <url>/2025/12/11/MCP%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="MCP-概念"><a href="#MCP-概念" class="headerlink" title="MCP 概念"></a>MCP 概念</h2><p>MCP 编程快速入门，MCP 全称 Model Context Protocol 模型上下文协议，其定义了 LLMs 与外部世界的互动方式，MCP 提供了一种标准化方法，使任意 LLMs 能够轻松连接各种数据源和工具，实现信息的高效交互和处理。</p>
<p>目前的 AI 朝着两个方向发展：<strong>掌握更多信息</strong> 或 <strong>控制更多工具</strong>，在没有联网搜索之前，LLM 的数据来源只有训练时和推理时我们提供的数据。</p>
<p>在MCP出现之前，如果LLM要访问外部数据，通常使用<code>Function Call</code>的方式，<code>Function Call</code>通过给模型预设函数描述（包括函数名、参数说明、返回值格式等），让模型在合适的时候返回一个符合结构的 JSON 格式，外部系统再解析这个 JSON，调用实际的后端函数。关于 <code>Function Call</code> 和<code>MCP</code> 的具体区别在 <a href="/2025/12/11/Function-Call%E5%92%8CMCP%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Function Call和MCP的区别">Function Call和MCP的区别</a></p>
<p>但 <code>Function Call</code> 的方式没有一个统一的开发规范，你开发的函数我不能用，我开发的函数你不能用，而且开发起来很麻烦，为了解决这个问题，MCP 出现了。MCP作为LLMs的标准化工具箱，可以通过MCP调用外界的AI工具，而AI工具在开发的时候也需要遵循MCP协议。MCP 允许应用以标准化的方式向 LLM 提供上下文，并将<strong>提供上下文的逻辑</strong>与<strong>实际的LLM交互逻辑”</strong>解耦。</p>
<p>在没有 MCP 之前，如果我们希望让模型使用本地数据，通常需要把这些数据直接复制到对话框中，让模型从文本中获取信息。而有了 MCP 之后，我们可以为特定能力编写一个 MCP Server，例如数据库读取、GitHub 操作、文件系统访问或获取当前时间等。模型通过 MCP 与这些 Server 通信，就能在无需手动粘贴数据的情况下，实时访问这些外部资源。</p>
<p><img src="/../uploads/MCP_1.png"></p>
<p>MCP 服务器可以提供三种主要类型的功能:</p>
<ol>
<li>资源访问：客户端读取文件等数据；</li>
<li>工具调用：由LLM调用的函数；</li>
<li>Prompt模板：预先编写的帮助客户完成特定任务的Prompt；</li>
</ol>
<span id="more"></span>

<h2 id="MCP-Deno-开发"><a href="#MCP-Deno-开发" class="headerlink" title="MCP Deno 开发"></a>MCP Deno 开发</h2><p>使用python的SDK，简单实现下面功能，用来加深理解：</p>
<ol>
<li>构建可连接到任何 MCP Server 的 MCP Client</li>
<li>创建公开资源、提示和工具的 MCP Server</li>
<li>使用 stdio 和 SSE 等标准传输</li>
<li>处理所有 MCP 协议消息和生命周期事件</li>
</ol>
<p>一般关于MCP的项目，开发者们都喜欢用uv来管理，不晓得为什么，但是跟着用一下，相关安装使用方法参照 <a href="/2025/12/10/uv%E4%BD%BF%E7%94%A8/" title="uv使用">uv使用</a> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的项目</span></span><br><span class="line">uv init mcp-demo</span><br><span class="line"><span class="built_in">cd</span> mcp-demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">uv venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">uv add <span class="string">&quot;mcp[cli]&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这样一个uv管理的python MCP 项目就初始化完成了。</p>
<p>接下来编写第一个简单Demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 FastMCP 实例</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;Demo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例工具</span></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例资源</span></span><br><span class="line"><span class="meta">@mcp.resource(<span class="params"><span class="string">&quot;greeting://&#123;name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;FastMCP Demo Server is running ......&quot;</span>)</span><br><span class="line">    mcp.run()</span><br></pre></td></tr></table></figure>

<p>示例代码中，使用了FastMCP来初始化一个MCP Server实例，分别创建了三个函数：</p>
<ul>
<li>echo：字符串输出；</li>
<li>add：两个数字相加；</li>
<li>greet：输入字符串，拼接后返回字符串；</li>
</ul>
<p>通过两个注解，赋予了函数不同的能力：</p>
<ul>
<li>@tool()：函数可以直接被AI调用；</li>
<li>@resource()：像API接口一样被调用，其中的参数 greeting:&#x2F;&#x2F;{name} 是一个自定义的 URI， 可以拆解为两个部分。greeting 是随便起的前缀，name是动态参数的名称，在访问的时候需要传入。</li>
</ul>
<p>测试命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mcp dev server.py</span><br></pre></td></tr></table></figure>

<p><code>mcp dev</code>是开发调试模式，输入这条命令后，会打开一个 MCP Inspector ，可以直观地检查和测试 MCP Server（server.py）是否正常工作。</p>
<p><img src="/../uploads/MCP_2.png"></p>
<p>点击 Connect ，选择 Tools，List Tools，即可列出 MCP 中定义的工具，可以输入测试内容进行 run tools测试:</p>
<p><img src="/../uploads/MCP_3.png"></p>
<p>在 Resources 标签页下，可以看到定义的资源函数 greet:</p>
<p><img src="/../uploads/MCP_4.png"></p>
<p>传入动态参数，mcp server 就会返回 json 格式的响应，并将我们输入的 api 拼接后返回。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>博客记录了对于 MCP 的理解，以及一个简单的Demo，后续在这个基础上继续完善。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>什么是MCP？本地如何开发MCP Server：<a href="https://cloud.tencent.com/developer/article/2511642">https://cloud.tencent.com/developer/article/2511642</a></li>
</ul>
]]></content>
      <categories>
        <category>MCP</category>
      </categories>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda安装</title>
    <url>/2025/12/07/Miniconda%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Miniconda 是 Conda 的精简发行版，只包含最核心的包管理系统与 Python，可以快速搭建独立的 Python 环境。在进行数据分析、机器学习或科研开发时，相比于 Anaconda 更轻量、更灵活。</p>
<h2 id="一、Miniconda-安装"><a href="#一、Miniconda-安装" class="headerlink" title="一、Miniconda 安装"></a>一、Miniconda 安装</h2><p>Windows 命令行安装方式，可以快速且安静地下载最新的 64 位 Windows 安装程序，将其重命名为较短的文件名，执行静默安装，然后删除安装程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o .\miniconda.exe</span><br><span class="line">start /wait &quot;&quot; .\miniconda.exe /S</span><br><span class="line">del .\miniconda.exe</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>Windows Powershell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> <span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe&quot;</span> <span class="literal">-outfile</span> <span class="string">&quot;.\miniconda.exe&quot;</span></span><br><span class="line"><span class="built_in">Start-Process</span> <span class="literal">-FilePath</span> <span class="string">&quot;.\miniconda.exe&quot;</span> <span class="literal">-ArgumentList</span> <span class="string">&quot;/S&quot;</span> <span class="literal">-Wait</span></span><br><span class="line"><span class="built_in">del</span> .\miniconda.exe</span><br></pre></td></tr></table></figure>

<p>Linux 64位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="built_in">rm</span> ~/miniconda3/miniconda.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/miniconda3/bin/activate</span><br><span class="line"></span><br><span class="line">conda init --all</span><br></pre></td></tr></table></figure>

<h2 id="二、快速使用"><a href="#二、快速使用" class="headerlink" title="二、快速使用"></a>二、快速使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n environment python=3.12</span><br><span class="line"></span><br><span class="line">conda activate environment</span><br><span class="line"></span><br><span class="line">conda deactivate environment</span><br></pre></td></tr></table></figure>

<p>参考文献：<a href="https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt">https://www.anaconda.com/docs/getting-started/miniconda/install#windows-command-prompt</a></p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>SARIF文件架构解读</title>
    <url>/2025/12/10/SARIF%E6%96%87%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="SARIF-文件架构架构解读"><a href="#SARIF-文件架构架构解读" class="headerlink" title="SARIF 文件架构架构解读"></a>SARIF 文件架构架构解读</h2><p>SARIF（Static Analysis Results Interchange Format）本质是一个 JSON 日志规范，用于统一表达静态分析（SAST、Lint、CodeQL、依赖扫描等）的扫描结果，方便不同工具之间共享、聚合、展示与追踪。</p>
<p>SARIF 简单文件结构如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;$schema&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;https://json.schemastore.org/sarif-2.1.0.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;runs&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;tool&#x27;<span class="punctuation">,</span> &#x27;invocations&#x27;<span class="punctuation">,</span> &#x27;artifacts&#x27;<span class="punctuation">,</span> &#x27;results&#x27;<span class="punctuation">,</span> &#x27;columnKind&#x27;<span class="punctuation">,</span>&#x27;properties&#x27;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SARIF &#x3D; 多次运行 runs 的集合，每次运行包含：工具信息 + 运行元数据 + 被分析对象（artifacts）+ 分析结果（results）</p>
</blockquote>
<p>对各部分内容介绍如下：</p>
<ol>
<li>tool 工具信息：检查员身份信息和检查手册，记录了用哪个工具进行了扫描，版本号是多少，包含了 driver 驱动程序信息 和 rules 检查规则清单；</li>
<li>invocations 调用信息：检查员的工作日志，记录了这次检查是在什么环境下进行的，以及是否顺利完成，executionSuccessful: true&#x2F;false；</li>
<li>artifacts 被扫描的文件：检查了哪些地点，列出了所有被 CodeQL 扫描过的源文件（Source Code），包含文件的路径（location），有时也包含文件的具体内容或哈希值，方便后续定位；</li>
<li><strong>results 结果</strong> ：这是问题清单，这是整份报告里最重要的部分，列出了扫描出来的所有 Bug和漏洞信息，关键单：ruleId 记录违反了哪条规则（对应 tool 里的规则），message 记录问题的具体描述，locations 记录了问题在哪个文件的第几行、第几列；</li>
<li>columnKind 列的计算方式：用于告诉 IDE（如 VS Code）如何正确高亮代码；</li>
<li>properties 附加属性：记录了杂项信息，存放标准字段里放不下的、或者工具特有的自定义数据，可能会包含构建时的标签（Build Tags）、项目的元数据（Project Metadata）和一些给特定显示面板用的统计数据；</li>
</ol>
<p>通俗的讲，就是这一次扫描 (run)，是由名为 CodeQL 的 (tool) 进行的。它在一个特定的时间以特定的参数运行 (invocations)，按照特定的刻度标准 (columnKind)，扫描了这一堆文件 (artifacts)，最后发现了这些漏洞 (results)，并在最后贴了一些标签 (properties)。</p>
<span id="more"></span>

<h2 id="关键信息提取"><a href="#关键信息提取" class="headerlink" title="关键信息提取"></a>关键信息提取</h2><p>要在 CodeQL 生成的 SARIF 报告中提取<strong>漏洞点（Sink）</strong>、<strong>漏洞位置</strong>、<strong>数据流（Source 到 Sink）以及控制流</strong>信息，需要研究 <code>runs</code> -&gt; <code>results</code> 数组中的对象。</p>
<p>SARIF 将这些复杂的逻辑封装在了一个层级分明的结构中。以下是提取这些关键信息所对应的具体字段和解析逻辑：</p>
<hr>
<h3 id="提取核心模块：results-数组"><a href="#提取核心模块：results-数组" class="headerlink" title="提取核心模块：results 数组"></a>提取核心模块：<code>results</code> 数组</h3><p>所有的漏洞信息都在 <code>runs[0].results</code> 列表里，需要遍历这个列表，列表中的每一个对象代表一个具体的漏洞实例。</p>
<h3 id="详细提取指南"><a href="#详细提取指南" class="headerlink" title="详细提取指南"></a>详细提取指南</h3><p>需要关注 <code>results</code> 对象下的以下字段：</p>
<h4 id="A-漏洞的基本信息"><a href="#A-漏洞的基本信息" class="headerlink" title="A. 漏洞的基本信息"></a>A. 漏洞的基本信息</h4><ul>
<li><strong>漏洞名称&#x2F;类型</strong>：<code>ruleId</code><ul>
<li>例如：<code>java/sql-injection</code></li>
</ul>
</li>
<li><strong>漏洞简要描述</strong>：<code>message.text</code><ul>
<li>例如：”This query depends on a user-provided value.”</li>
</ul>
</li>
</ul>
<h4 id="B-漏洞位置-爆发点-Sink"><a href="#B-漏洞位置-爆发点-Sink" class="headerlink" title="B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink"></a>B. 漏洞位置 &#x2F; 爆发点 &#x2F; Sink</h4><p>这是 CodeQL 认为漏洞最终发生的地方（例如执行 SQL 查询的那一行）。</p>
<ul>
<li><strong>提取字段</strong>：<code>locations</code> 数组</li>
<li><strong>关键逻辑</strong>：通常取 <code>locations[0]</code>（数组的第一个元素）作为主要位置。</li>
<li><strong>具体内容</strong>：<ul>
<li><strong>文件路径</strong>：<code>locations[0].physicalLocation.artifactLocation.uri</code></li>
<li><strong>起始行号</strong>：<code>locations[0].physicalLocation.region.startLine</code></li>
<li><strong>代码片段</strong>（如果有）：<code>locations[0].physicalLocation.region.snippet.text</code></li>
</ul>
</li>
</ul>
<h4 id="C-数据流与控制流"><a href="#C-数据流与控制流" class="headerlink" title="C. 数据流与控制流"></a>C. 数据流与控制流</h4><p>这是最复杂也是最有价值的部分，描述了污点数据（Taint Data）是如何从<strong>输入源（Source）</strong>一步步流向<strong>爆发点（Sink）</strong>的。</p>
<p>CodeQL 将数据流和控制流统一放在 <code>codeFlows</code> 字段中。</p>
<ul>
<li><strong>提取字段</strong>：<code>codeFlows</code> 数组</li>
<li><strong>结构逻辑</strong>：<ol>
<li><code>codeFlows</code> 下通常包含一个或多个 <code>threadFlows</code>（CodeQL 通常只给出一个最具代表性的路径）。</li>
<li><code>threadFlows</code> 下是一个 <code>locations</code> 列表，这是一个<strong>有序数组</strong>，代表了代码执行的步骤。</li>
</ol>
</li>
</ul>
<p><strong>如何解析这个路径链条：</strong></p>
<ul>
<li><strong>Source（污点源头&#x2F;用户输入）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>第一个元素</strong>。</li>
<li>提取：<code>...locations[0].location.physicalLocation</code> (文件和行号)</li>
<li>含义：例如 <code>request.getParameter(&quot;id&quot;)</code>，这是数据进入系统的位置。</li>
</ul>
</li>
<li><strong>Flow Path（传播路径&#x2F;控制流）</strong>：<ul>
<li>是 <code>threadFlows[0].locations</code> 数组的<strong>中间元素</strong>。</li>
<li>这些步骤展示了数据经过了哪些函数调用、赋值操作或判断逻辑。</li>
<li><strong>关键提取</strong>：<code>location.message.text</code> —— 这里通常会说明“数据被传递给参数 x”或“数据通过函数返回值传播”。</li>
</ul>
</li>
<li><strong>Sink（爆发点&#x2F;最终位置）</strong>：<ul>
<li>通常是 <code>threadFlows[0].locations</code> 数组的<strong>最后一个元素</strong>。</li>
<li>这应该与上面提到的 <strong>B. 漏洞位置</strong> 重合。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：需要提取的-JSON-路径映射表"><a href="#总结：需要提取的-JSON-路径映射表" class="headerlink" title="总结：需要提取的 JSON 路径映射表"></a>总结：需要提取的 JSON 路径映射表</h3><p>为了方便编写脚本（如 Python）提取，这是一个速查表：</p>
<table>
<thead>
<tr>
<th align="left">信息类型</th>
<th align="left">SARIF JSON 路径 (假设当前在 results[i] 对象下)</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>漏洞类型</strong></td>
<td align="left"><code>ruleId</code></td>
<td align="left">漏洞的 ID，如 SQL 注入</td>
</tr>
<tr>
<td align="left"><strong>漏洞描述</strong></td>
<td align="left"><code>message.text</code></td>
<td align="left">人类可读的解释</td>
</tr>
<tr>
<td align="left"><strong>漏洞文件</strong></td>
<td align="left"><code>locations[0].physicalLocation.artifactLocation.uri</code></td>
<td align="left">发生漏洞的文件名</td>
</tr>
<tr>
<td align="left"><strong>漏洞行号</strong></td>
<td align="left"><code>locations[0].physicalLocation.region.startLine</code></td>
<td align="left">发生漏洞的行号</td>
</tr>
<tr>
<td align="left"><strong>数据流路径</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations</code></td>
<td align="left">这是一个列表，包含完整路径</td>
</tr>
<tr>
<td align="left"><strong>数据源 (Source)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[0]</code></td>
<td align="left">路径的第一步</td>
</tr>
<tr>
<td align="left"><strong>传播过程</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[1:-1]</code></td>
<td align="left">路径的中间步骤</td>
</tr>
<tr>
<td align="left"><strong>爆发点 (Sink)</strong></td>
<td align="left"><code>codeFlows[0].threadFlows[0].locations[-1]</code></td>
<td align="left">路径的最后一步</td>
</tr>
</tbody></table>
<h3 id="4-举例说明"><a href="#4-举例说明" class="headerlink" title="4. 举例说明"></a>4. 举例说明</h3><p>假设这是一个 SQL 注入的 <code>result</code> 片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ruleId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java/sql-injection&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Query depends on user input.&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// ---&gt; 这里是 B: 漏洞最终爆发的位置 (Sink)</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;artifactLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;codeFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// ---&gt; 这里是 C: 完整的数据流/控制流路径</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;threadFlows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;locations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="comment">// 步骤 1: Source (数据源)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Controller.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">15</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User input source...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 2: 中间传播</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/Service.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data passed to function...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 步骤 3: Sink (通常与 locations[0] 一致)</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;physicalLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/DB.java&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;region&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;startLine&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data used in SQL query...&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><strong>判空处理</strong>：不是所有的 <code>results</code> 都有 <code>codeFlows</code>。简单的代码质量检查（比如“变量未使用”）通常只有 <code>locations</code>，没有数据流路径。只有安全类漏洞（如注入、XSS）通常会有 <code>codeFlows</code>。</li>
<li><strong>路径简繁</strong>：CodeQL 生成的 <code>codeFlows</code> 有时非常详细，如果只关注关键跳板，关注 <code>location.message</code> 比较有帮助。</li>
<li><strong>关联位置</strong>：有时还会看到 <code>relatedLocations</code> 字段，这通常用于辅助说明（例如：指出变量定义的位置），如果不需要极高精度，可以暂时忽略。</li>
</ol>
]]></content>
      <categories>
        <category>CodeQL</category>
      </categories>
      <tags>
        <tag>SAST</tag>
        <tag>CodeQL</tag>
        <tag>SARIF</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11 Java环境变量配置</title>
    <url>/2025/12/04/Win11-Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>找到JDK的路径，在系统环境变量中新建变量名和变量值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_202</span><br></pre></td></tr></table></figure>

<p>然后在系统变量path中，新建两条：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br><span class="line">%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>验证配置是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_202&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;javac -version</span><br><span class="line">javac 1.8.0_202</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>kali安装ssh</title>
    <url>/2025/12/10/kali%E5%AE%89%E8%A3%85ssh/</url>
    <content><![CDATA[<h1 id="kali-linux-安装ssh服务"><a href="#kali-linux-安装ssh服务" class="headerlink" title="kali linux 安装ssh服务"></a>kali linux 安装ssh服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl start ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh <span class="comment">#设置开机自启</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> systemctl status ssh <span class="comment">#查看运行状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Kali Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows结束进程</title>
    <url>/2025/12/09/Windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>今天在跑 Springboot 的 Java 项目时，遇到了端口占用问题，记一下 Windows 的根据相关端口杀进程命令。</p>
<p>首先查找占用 8080 的 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></table></figure>

<p>然后根据 PID 强制结束进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /PID 3836</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>实验</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\77319&gt;netstat -ano | findstr :8080</span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       3836</span><br><span class="line">  TCP    [::]:8080              [::]:0                 LISTENING       3836</span><br><span class="line"></span><br><span class="line">C:\Users\77319&gt;taskkill /F /PID 3836</span><br><span class="line">成功: 已终止 PID 为 3836 的进程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>uv使用</title>
    <url>/2025/12/10/uv%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>uv是一个用 Rust 编写的极快的 Python 包和项目管理工具。</p>
<p>官方文档参考：<a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a></p>
<h2 id="uv安装"><a href="#uv安装" class="headerlink" title="uv安装"></a>uv安装</h2><p>Linux &amp; MacOS 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Windows powershell 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powershell -ExecutionPolicy ByPass -c <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>以Windows为例，下载uv并配置环境变量，在powershell中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\<span class="number">77319</span>&gt; powershell <span class="literal">-ExecutionPolicy</span> ByPass <span class="literal">-c</span> <span class="string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span><br><span class="line">Downloading uv <span class="number">0.9</span>.<span class="number">17</span> (x86_64<span class="literal">-pc-windows-msvc</span>)</span><br><span class="line">Installing to C:\Users\<span class="number">77319</span>\.local\bin</span><br><span class="line">  uv.exe</span><br><span class="line">  uvx.exe</span><br><span class="line">  uvw.exe</span><br><span class="line">everything<span class="string">&#x27;s installed!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To add C:\Users\77319\.local\bin to your PATH, either restart your shell or run:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    set Path=C:\Users\77319\.local\bin;%Path%   (cmd)</span></span><br><span class="line"><span class="string">    $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;   (powershell)</span></span><br><span class="line"><span class="string">(base) PS C:\Users\77319&gt; $env:Path = &quot;C:\Users\77319\.local\bin;$env:Path&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入uv -h</p>
<p><img src="/../uploads/uv.png"></p>
<p>即表示安全成功。</p>
<h2 id="uv使用"><a href="#uv使用" class="headerlink" title="uv使用"></a>uv使用</h2><p>以官方实践为例，展示uv如何初始化一个 Python 项目、添加依赖、运行工具、生成锁文件并同步环境。  </p>
<p><code>uv init example</code> — 创建一个新的 Python 项目模板  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~$ uv init myproject_test</span><br><span class="line">Initialized project `myproject-test` at `/home/zyu/myproject_test`</span><br><span class="line">(base) zyu@zyu-virtual-machine:~$ <span class="built_in">cd</span> myproject_test/</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ tree .</span><br><span class="line">.</span><br><span class="line">├── main.py</span><br><span class="line">├── pyproject.toml</span><br><span class="line">└── README.md</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv add ruff</code> — 安装依赖并更新 pyproject  </p>
<p>自动创建项目虚拟环境，安装依赖包ruff，把依赖写入pyproject.toml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv add ruff</span><br><span class="line">Using CPython 3.13.9 interpreter at: /home/zyu/miniconda3/bin/python3</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 864ms</span><br><span class="line">Prepared 1 package <span class="keyword">in</span> 1.30s</span><br><span class="line">Installed 1 package <span class="keyword">in</span> 1ms</span><br><span class="line"> + ruff==0.14.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv run ruff check</code> — 运行 ruff 检查代码  </p>
<p> 使用项目虚拟环境里的 ruff 执行代码风格检查 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv run ruff check</span><br><span class="line">All checks passed!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uv lock</code> — 生成锁文件 : 解析所有依赖版本  , 生成 <code>uv.lock</code>（类似 Pipfile.lock &#x2F; poetry.lock），保证这个项目未来依赖安装一致、可复现。  </p>
<p><code>uv sync</code> — 按锁文件同步虚拟环境 ： 根据 <code>uv.lock</code> 安装或更新依赖  ， 确保 <code>.venv/</code> 完全匹配锁文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv lock</span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.84ms</span><br><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uv <span class="built_in">sync</span></span><br><span class="line">Resolved 2 packages <span class="keyword">in</span> 0.70ms</span><br><span class="line">Audited 1 package <span class="keyword">in</span> 0.09ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uvx pycowsay &#39;hello world!&#39; </code> uvx 等价于 <code>uv tool run</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) zyu@zyu-virtual-machine:~/myproject_test$ uvx pycowsay <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line">Installed 1 package <span class="keyword">in</span> 5ms</span><br><span class="line">/home/zyu/.cache/uv/archive-v0/nYZiOnUm3DMddg7I9DLwr/lib/python3.13/site-packages/pycowsay/main.py:27: SyntaxWarning: invalid escape sequence <span class="string">&#x27;\ &#x27;</span></span><br><span class="line">  \   ^__^</span><br><span class="line"></span><br><span class="line">  ------------</span><br><span class="line">&lt; hello world! &gt;</span><br><span class="line">  ------------</span><br><span class="line">   \   ^__^</span><br><span class="line">    \  (oo)\_______</span><br><span class="line">       (__)\       )\/\</span><br><span class="line">           ||----w |</span><br><span class="line">           ||     ||</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是官方提供的示例Demo。</p>
<p>在实际项目中使用（以<a href="https://github.com/JordyZomer/codeql-mcp#">https://github.com/JordyZomer/codeql-mcp#</a>为例）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">error: No virtual environment found; run `uv venv` to create an environment, or pass `--system` to install into a non-virtual environment</span><br></pre></td></tr></table></figure>

<p> 使用 <code>uv pip</code> 安装依赖，但当前目录没有虚拟环境，所以 uv 不知道该把包装到哪里。  uv 的原则是如果不指定装到哪里，它默认要找一个虚拟环境（.venv），如果找不到就报错。所以需要先创建虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv venv</span><br><span class="line">Using CPython 3.11.7 interpreter at: C:\Users\77319\anaconda3\python.exe</span><br><span class="line">Creating virtual environment at: .venv</span><br><span class="line">Activate with: .venv\Scripts\activate</span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install -r .\requirements.txt</span><br><span class="line">Resolved 60 packages <span class="keyword">in</span> 1.61s</span><br><span class="line">Prepared 60 packages <span class="keyword">in</span> 3.56s</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/60] Installing wheels...                                                warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.                                                                                            </span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.                                                                                    </span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.                                                                             </span><br><span class="line">Installed 60 packages <span class="keyword">in</span> 4.17s</span><br><span class="line"> + annotated-types==0.7.0                                                                       </span><br><span class="line"> + anyio==4.12.0                                                                                </span><br><span class="line"> + attrs==25.4.0                                                                                </span><br><span class="line"> + authlib==1.6.5                                                                               </span><br><span class="line"> + beartype==0.22.8                                                                             </span><br><span class="line"> + cachetools==6.2.2</span><br><span class="line"> + certifi==2025.11.12</span><br><span class="line"> + cffi==2.0.0</span><br><span class="line"> + charset-normalizer==3.4.4</span><br><span class="line"> + click==8.3.1</span><br><span class="line"> + colorama==0.4.6</span><br><span class="line"> + cryptography==46.0.3</span><br><span class="line"> + cyclopts==4.3.0</span><br><span class="line"> + diskcache==5.6.3</span><br><span class="line"> + dnspython==2.8.0</span><br><span class="line"> + docstring-parser==0.17.0</span><br><span class="line"> + docutils==0.22.3</span><br><span class="line"> + email-validator==2.3.0</span><br><span class="line"> + exceptiongroup==1.3.1</span><br><span class="line"> + fastmcp==2.13.3</span><br><span class="line"> + h11==0.16.0</span><br><span class="line"> + httpcore==1.0.9</span><br><span class="line"> + httpx==0.28.1</span><br><span class="line"> + httpx-sse==0.4.3</span><br><span class="line"> + idna==3.11</span><br><span class="line"> + jsonschema==4.25.1</span><br><span class="line"> + jsonschema-path==0.3.4</span><br><span class="line"> + jsonschema-specifications==2025.9.1</span><br><span class="line"> + markdown-it-py==4.0.0</span><br><span class="line"> + mcp==1.22.0</span><br><span class="line"> + mdurl==0.1.2</span><br><span class="line"> + openapi-pydantic==0.5.1</span><br><span class="line"> + pathable==0.4.4</span><br><span class="line"> + pathvalidate==3.3.1</span><br><span class="line"> + platformdirs==4.5.1</span><br><span class="line"> + py-key-value-aio==0.3.0</span><br><span class="line"> + py-key-value-shared==0.3.0</span><br><span class="line"> + pycparser==2.23</span><br><span class="line"> + pydantic==2.12.5</span><br><span class="line"> + pydantic-core==2.41.5</span><br><span class="line"> + pydantic-settings==2.12.0</span><br><span class="line"> + pygments==2.19.2</span><br><span class="line"> + pyjwt==2.10.1</span><br><span class="line"> + pyperclip==1.11.0</span><br><span class="line"> + python-dotenv==1.2.1</span><br><span class="line"> + python-multipart==0.0.20</span><br><span class="line"> + pywin32==311</span><br><span class="line"> + pyyaml==6.0.3</span><br><span class="line"> + referencing==0.36.2</span><br><span class="line"> + requests==2.32.5</span><br><span class="line"> + rich==14.2.0</span><br><span class="line"> + rich-rst==1.3.2</span><br><span class="line"> + rpds-py==0.30.0</span><br><span class="line"> + sse-starlette==3.0.3</span><br><span class="line"> + starlette==0.50.0</span><br><span class="line"> + typing-extensions==4.15.0</span><br><span class="line"> + typing-inspection==0.4.2</span><br><span class="line"> + urllib3==2.6.1</span><br><span class="line"> + uvicorn==0.38.0</span><br><span class="line"> + websockets==15.0.1</span><br></pre></td></tr></table></figure>

<p>关于报错信息可以忽略，大致意思是： uv 想用硬链接（hardlink）加速依赖安装，但我们的缓存目录和安装目录不在同一个文件系统上 → 无法硬链接 → 只能退回到“完整复制”文件，性能稍慢一点。  应该缓存目录在C盘，但是安装目录在D盘。</p>
<p>运行mcp服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv run mcp run server.py -t sse</span><br><span class="line">Error: typer is required. Install with <span class="string">&#x27;pip install mcp[cli]&#x27;</span></span><br><span class="line">(base) PS D:\Code\codeql-mcp&gt; uv pip install mcp[cli]</span><br><span class="line">Resolved 37 packages <span class="keyword">in</span> 710ms</span><br><span class="line">Prepared 2 packages <span class="keyword">in</span> 138ms</span><br><span class="line">░░░░░░░░░░░░░░░░░░░░ [0/2] Installing wheels...                                                 warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.</span><br><span class="line">         If the cache and target directories are on different filesystems, hardlinking may not be supported.</span><br><span class="line">         If this is intentional, <span class="built_in">set</span> `<span class="built_in">export</span> UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.</span><br><span class="line">Installed 2 packages <span class="keyword">in</span> 56ms</span><br><span class="line"> + shellingham==1.5.4</span><br><span class="line"> + typer==0.20.0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>uv</tag>
      </tags>
  </entry>
  <entry>
    <title>解决VScode和Trae等无法加载conda虚拟环境的问题</title>
    <url>/2025/12/02/%E8%A7%A3%E5%86%B3VScode%E5%92%8CTrae%E7%AD%89%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BDconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>使用 conda 或 miniconda 配置虚拟环境时，当启动虚拟环境时，遇到如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是，运行 <code>conda init</code> 后还是不起作用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ conda init</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda.exe</span><br><span class="line">no change     C:\Users\Username\miniconda3\Scripts\conda-env.exe</span><br><span class="line">......</span><br><span class="line">no change     C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</span><br><span class="line">modified      HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun</span><br></pre></td></tr></table></figure>

<h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>我是 win11 操作系统，需要以 <strong>管理员身份</strong> 打开powershell窗口，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>重新加载即可生效。</p>
<span id="more"></span>

<h1 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h1><p>简单说，这个问题本质上是：<strong>Conda 的初始化脚本被 PowerShell 的安全策略拦住了，所以每次新开终端时，Conda 都没真正“接管”当前 Shell。</strong></p>
<h2 id="1-conda-init-实际在做什么？"><a href="#1-conda-init-实际在做什么？" class="headerlink" title="1. conda init 实际在做什么？"></a>1. <code>conda init</code> 实际在做什么？</h2><p>在 Windows + PowerShell 下，Conda 并不是简单地靠 <code>conda.exe</code> 来完成环境激活的，而是通过一套 <strong>Shell Hook 脚本</strong> 来接管当前会话：</p>
<p><code>conda init</code> 会在 <code>C:\Users\Username\Documents\WindowsPowerShell\profile.ps1</code> 里写入一段初始化代码，这些脚本会去调用 <code>miniconda3\shell\condabin\conda-hook.ps1</code> 等文件，往当前 PowerShell 里注入 <code>conda</code> &#x2F; <code>conda activate</code> 等函数，并设置好 PATH、环境变量等。</p>
<p><strong>只有这些 Hook 每次打开 PowerShell 时能顺利执行，当前终端才真正“支持” <code>conda activate</code>。</strong></p>
<p>所以当你看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CondaError: Run <span class="string">&#x27;conda init&#x27;</span> before <span class="string">&#x27;conda activate&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其实意思是：<strong>当前这个 PowerShell 会话里没有被注入 Conda 的 Hook 脚本</strong>，所以它感觉自己还没 init。</p>
<h2 id="2-PowerShell-执行策略的限制"><a href="#2-PowerShell-执行策略的限制" class="headerlink" title="2. PowerShell 执行策略的限制"></a>2. PowerShell 执行策略的限制</h2><p>PowerShell 为了安全，有一个 <strong>执行策略（Execution Policy）</strong>，决定哪些脚本可以被执行：</p>
<p>常见几种：</p>
<ul>
<li><code>Restricted</code>：完全禁止执行脚本；</li>
<li><code>AllSigned</code>：所有脚本都必须是签名的；</li>
<li><code>RemoteSigned</code>：本地脚本可以执行，从互联网下载的脚本必须签名。</li>
</ul>
<p>在我机器上的情况是：</p>
<ul>
<li><p>Conda 的这些 hook &#x2F; profile 脚本属于 <strong>本地脚本</strong>；</p>
</li>
<li><p>但默认配置策略过于严格，导致：</p>
<ul>
<li>打开 PowerShell 时，<code>profile.ps1</code> &#x2F; <code>conda-hook.ps1</code> 没有被执行；</li>
<li>于是 <code>conda</code> 函数、自动激活逻辑统统都没加载进当前会话；</li>
<li>终端自然就会提示你先 <code>conda init</code>。</li>
</ul>
</li>
</ul>
<p>也就是说：<code>conda init</code> 写入的配置已经在那儿了，但每次启动 PowerShell 时都被策略挡在门外。 当以管理员身份执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

<p>等于允许系统执行本地脚本，只对来源不明的远程脚本做限制。</p>
<p>这样一来，再次打开 PowerShell &#x2F; VSCode 内置终端时，<code>profile.ps1</code> 会被正常加载，里面调用的 <code>conda-hook.ps1</code> 等本地脚本可以顺利执行， VSCode &#x2F; Trae 里就可以正常加载和激活 Conda 虚拟环境，不再报 Run ‘conda init’ before ‘conda activate’错误。</p>
]]></content>
      <categories>
        <category>Trouble shooting</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Trouble shooting</tag>
      </tags>
  </entry>
</search>
